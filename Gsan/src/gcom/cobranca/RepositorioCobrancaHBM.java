/*
 * Copyright (C) 2007-2007 the GSAN - Sistema Integrado de Gestão de Serviços de Saneamento
 *
 * This file is part of GSAN, an integrated service management system for Sanitation
 *
 * GSAN is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * GSAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 */

/*
 * GSAN - Sistema Integrado de Gestão de Serviços de Saneamento
 * Copyright (C) <2007> 
 * Adriano Britto Siqueira
 * Alexandre Santos Cabral
 * Ana Carolina Alves Breda
 * Ana Maria Andrade Cavalcante
 * Aryed Lins de Araújo
 * Bruno Leonardo Rodrigues Barros
 * Carlos Elmano Rodrigues Ferreira
 * Cláudio de Andrade Lira
 * Denys Guimarães Guenes Tavares
 * Eduardo Breckenfeld da Rosa Borges
 * Fabíola Gomes de Araújo
 * Flávio Leonardo Cavalcanti Cordeiro
 * Francisco do Nascimento Júnior
 * Homero Sampaio Cavalcanti
 * Ivan Sérgio da Silva Júnior
 * José Edmar de Siqueira
 * José Thiago Tenório Lopes
 * Kássia Regina Silvestre de Albuquerque
 * Leonardo Luiz Vieira da Silva
 * Márcio Roberto Batista da Silva
 * Maria de Fátima Sampaio Leite
 * Micaela Maria Coelho de Araújo
 * Nelson Mendonça de Carvalho
 * Newton Morais e Silva
 * Pedro Alexandre Santos da Silva Filho
 * Rafael Corrêa Lima e Silva
 * Rafael Francisco Pinto
 * Rafael Koury Monteiro
 * Rafael Palermo de Araújo
 * Raphael Veras Rossiter
 * Roberto Sobreira Barbalho
 * Rodrigo Avellar Silveira
 * Rosana Carvalho Barbosa
 * Sávio Luiz de Andrade Cavalcante
 * Tai Mu Shih
 * Thiago Augusto Souza do Nascimento
 * Tiago Moreno Rodrigues
 * Vivianne Barbosa Sousa
 *
 * Este programa é software livre; você pode redistribuí-lo e/ou
 * modificá-lo sob os termos de Licença Pública Geral GNU, conforme
 * publicada pela Free Software Foundation; versão 2 da
 * Licença.
 * Este programa é distribuído na expectativa de ser útil, mas SEM
 * QUALQUER GARANTIA; sem mesmo a garantia implícita de
 * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
 * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais
 * detalhes.
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU
 * junto com este programa; se não, escreva para Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307, USA.
 */
package gcom.cobranca;

import gcom.arrecadacao.ArrecadadorContratoTarifa;
import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.aviso.AvisoDeducoes;
import gcom.arrecadacao.debitoautomatico.DebitoAutomatico;
import gcom.arrecadacao.pagamento.GuiaPagamento;
import gcom.arrecadacao.pagamento.PagamentoSituacao;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.ordemservico.ServicoTipo;
import gcom.atendimentopublico.registroatendimento.AtendimentoMotivoEncerramento;
import gcom.atendimentopublico.registroatendimento.AtendimentoRelacaoTipo;
import gcom.atendimentopublico.registroatendimento.EspecificacaoTipoValidacao;
import gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteRelacaoTipo;
import gcom.cadastro.cliente.ClienteTipo;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.empresa.EmpresaCobrancaFaixa;
import gcom.cadastro.geografico.Microrregiao;
import gcom.cadastro.geografico.Municipio;
import gcom.cadastro.geografico.Regiao;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.CategoriaTipo;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelPerfil;
import gcom.cadastro.localidade.GerenciaRegional;
import gcom.cadastro.localidade.Localidade;
import gcom.cadastro.localidade.Quadra;
import gcom.cadastro.localidade.SetorComercial;
import gcom.cadastro.localidade.UnidadeNegocio;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.bean.ConsultarTransferenciasDebitoHelper;
import gcom.cobranca.bean.DadosConsultaNegativacaoHelper;
import gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper;
import gcom.cobranca.bean.EmitirDocumentoCobrancaBoletimCadastroHelper;
import gcom.cobranca.bean.EmitirDocumentoCobrancaHelper;
import gcom.cobranca.bean.FiltrarDocumentoCobrancaHelper;
import gcom.cobranca.bean.FiltrarRelacaoParcelamentoHelper;
import gcom.cobranca.bean.FiltroSupressoesReligacoesReestabelecimentoHelper;
import gcom.cobranca.bean.PesquisarQtdeRotasSemCriteriosParaAcoesCobranca;
import gcom.cobranca.bean.SituacaoEspecialCobrancaHelper;
import gcom.cobranca.contratoparcelamento.ContratoParcelamento;
import gcom.cobranca.parcelamento.ParcDesctoInativVista;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.cobranca.parcelamento.ParcelamentoDescontoInatividade;
import gcom.cobranca.parcelamento.ParcelamentoFaixaValor;
import gcom.cobranca.parcelamento.ParcelamentoPagamentoCartaoCredito;
import gcom.cobranca.parcelamento.ParcelamentoQuantidadeReparcelamento;
import gcom.cobranca.parcelamento.ParcelamentoSituacao;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.conta.ContaGeral;
import gcom.faturamento.conta.FaturaItem;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.debito.DebitoACobrar;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.faturamento.debito.DebitoTipo;
import gcom.financeiro.FinanciamentoTipo;
import gcom.gui.cobranca.cobrancaporresultado.MovimentarOrdemServicoGerarOSHelper;
import gcom.gui.relatorio.atendimentopublico.FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper;
import gcom.gui.relatorio.cobranca.FaixaHelper;
import gcom.gui.relatorio.cobranca.FiltroRelatorioDocumentosAReceberHelper;
import gcom.micromedicao.ContratoEmpresaServico;
import gcom.micromedicao.consumo.ConsumoHistorico;
import gcom.micromedicao.consumo.LigacaoTipo;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.cobranca.ProtocoloDocumentoCobrancaRelatorioHelper;
import gcom.relatorio.cobranca.RelatorioAcompanhamentoAcoesCobrancaHelper;
import gcom.relatorio.cobranca.RelatorioAnalisePerdasCreditosBean;
import gcom.relatorio.cobranca.RelatorioBoletimMedicaoCobrancaHelper;
import gcom.relatorio.cobranca.parcelamento.RelacaoParcelamentoRelatorioHelper;
import gcom.util.CollectionUtil;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorException;
import gcom.util.ErroRepositorioException;
import gcom.util.HibernateUtil;
import gcom.util.RepositorioUtilHBM;
import gcom.util.Util;
import gcom.util.filtro.Filtro;
import gcom.util.filtro.GeradorHQLCondicional;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.StatelessSession;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Restrictions;

/**
 * Repositorio para cobrança
 * 
 * @author Rafael Santos
 * @since 02/01/2006
 */
public class RepositorioCobrancaHBM implements IRepositorioCobranca {

	/** Repositorio Cobranca Hibernate */
	private static RepositorioCobrancaHBM instancia;

	/**
	 * Construtor da classe RepositorioAcessoHBM
	 */
	protected RepositorioCobrancaHBM() {
	}

	/**
	 * Retorna o valor de instancia
	 * 
	 * @return O valor de instancia
	 */
	public static RepositorioCobrancaHBM getInstancia() {

		String dialect = HibernateUtil.getDialect();

		if (dialect.toUpperCase().contains("ORACLE")) {
			if (instancia == null) {
				instancia = new RepositorioCobrancaHBM();
			}
		} else {
			if (instancia == null) {
				instancia = new RepositorioCobrancaPostgresHBM();
			}
		}

		return instancia;
	}

	/**
	 * Faz parte de [UC0178] Religar Automaticamente Imóvel Cortado Author:
	 * Rafael Santos Data: 02/01/2006 Pesquisa os imoveis cortados há 60 dias ou
	 * mais a data do último dia do mês de faturamento
	 * 
	 * @return Colecção de Matriculas
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Collection pesquisarImoveisCortados(String situacaoEsgotoLigado,
			String situacaoAguaCortado, Date anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select i.id "
					+ "from Imovel i "
					+ "inner join i.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "inner join i.ligacaoAgua ligacaoAgua "
					+ "inner join i.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "inner join i.ligacaoEsgoto ligacaoEsgoto "
					+ "where ligacaoAguaSituacao.id = :situacao and "
					+ "ligacaoAgua.dataCorte <= :anoMesReferencia and "
					+ "((ligacaoEsgotoSituacao.id != :situacaoEsgoto)  or "
					+ "(ligacaoEsgotoSituacao.id = :situacaoEsgoto and "
					+ "(ligacaoEsgoto.consumoMinimo = 0 or "
					+ "ligacaoEsgoto.consumoMinimo is null)))";

			retorno = session
					.createQuery(consulta)
					.setInteger("situacao",
							new Integer(situacaoAguaCortado).intValue())
					.setDate("anoMesReferencia", anoMesReferenciaFaturamento)
					.setInteger("situacaoEsgoto",
							new Integer(situacaoEsgotoLigado).intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0178] Religar Automaticamente Imóvel Cortado Author:
	 * Rafael Santos Data: 02/01/2006 Caso o imovel possua hidrometro na ligação
	 * de água e o tipo do ultimo consumo faturado tenha sido real
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param anoMesFaturamento
	 *            Ano Mes Faturamento
	 * @param consumoTipoReal
	 *            Tipo de Consumo Real
	 * @param ligacaoTipoLigacaoAgua
	 *            Tipo de Ligação Agua
	 * @return Consumo Historico do Imovel
	 * @throws ErroRepositorioException
	 *             Erro no Repositorio
	 */
	public String pesquisarImoveisHidrometroAguaConsumoFaturadoReal(String id,
			String anoMesFaturamento, String consumoTipoReal,
			String ligacaoTipoLigacaoAgua) throws ErroRepositorioException {

		String idConsumoHistorico = null;
		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ch.id from ConsumoHistorico ch "
					+ "inner join ch.imovel im "
					+ "inner join ch.imovel.ligacaoAgua la "
					+ "inner join la.hidrometroInstalacaoHistorico "
					+ "inner join ch.consumoTipo ct "
					+ "inner join ch.ligacaoTipo lt "
					+ "where la.hidrometroInstalacaoHistorico is not null "
					+ "and ct.id = :idConsumo and lt.id = :ligacaoAgua "
					+ " and ch.referenciaFaturamento = :anoMesReferencia "
					+ " and im.id = :idImovel";

			retorno = session
					.createQuery(consulta)
					.setInteger("idConsumo",
							new Integer(consumoTipoReal).intValue())
					.setInteger("ligacaoAgua",
							new Integer(ligacaoTipoLigacaoAgua).intValue())
					.setInteger("anoMesReferencia",
							new Integer(anoMesFaturamento).intValue())
					.setInteger("idImovel", new Integer(id).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {

				idConsumoHistorico = ((Integer) retorno).toString();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idConsumoHistorico;
	}

	/**
	 * [UC0178] Religar Automaticamente Imóvel Cortado Auhtor: Rafael Santos
	 * Data: 03/01/2006
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param situacaoAguaLigado
	 *            Situação Agua
	 * @param dataReligacaoAgua
	 *            Data Religacao Agua
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void religarImovelCortado(String id, String situacaoAguaLigado,
			Date dataReligacaoAgua) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;
		String atualizarLigacaoAgua;

		try {
			System.out.println("Entrou.....");
			atualizarImovel = "update gcom.cadastro.imovel.Imovel "
					+ "set last_id = :situacaoAgua where imov_id = :id";

			session.createQuery(atualizarImovel)
					.setInteger("situacaoAgua",
							new Integer(situacaoAguaLigado).intValue())
					.setInteger("id", new Integer(id).intValue())
					.executeUpdate();

			atualizarLigacaoAgua = "update gcom.atendimentopublico.ligacaoagua.LigacaoAgua "
					+ "set lagu_dtreligacaoagua = :data"
					+ " where hidi_id = :id";

			session.createQuery(atualizarLigacaoAgua)
					.setDate("data", dataReligacaoAgua)
					.setInteger("id", new Integer(id).intValue())
					.executeUpdate();
		} catch (Exception e) {
			System.out.println("Erro");

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos de um imóvel
	 * Author: Rafael Santos Data: 03/01/2006
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param contaSituacaoNormal
	 *            Situação Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situação Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situação Incluída de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Coleção de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImovel(Integer idImovel,
			int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento, "
					+ "conta.iper_id as imovelPerfil, categoria.catg_iccobrancaacrescimos icAcrescimos "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "INNER JOIN cadastro.imovel imovel on imovel.imov_id = conta.imov_id "
					+ "INNER JOIN cadastro.categoria categoria on categoria.catg_id = imovel.imov_idcategoriaprincipal "
					+ "WHERE conta.imov_id = :idImovel "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) ";

			if (anoMesInicialReferenciaDebito != null
					&& anoMesFinalReferenciaDebito != null) {

				consulta += "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia ";

			}

			// consulta += " and (pagto.pgmt_id is null) "
			consulta += "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			consulta += " GROUP BY conta.iper_id, conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id, categoria.catg_iccobrancaacrescimos ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";

			if (anoMesInicialReferenciaDebito != null
					&& anoMesFinalReferenciaDebito != null) {
				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("imovelPerfil", Hibernate.INTEGER)
						.addScalar("icAcrescimos", Hibernate.INTEGER)
						.setInteger("idImovel", idImovel)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia",
								new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia",
								new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			} else {

				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("imovelPerfil", Hibernate.INTEGER)
						.addScalar("icAcrescimos", Hibernate.INTEGER)
						.setInteger("idImovel", idImovel)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos
	 * de um cliente Author: Rafael Santos Data: 05/01/2006
	 * 
	 * @param idsContas
	 *            Coleção de Ids das Contas
	 * @param contaSituacaoNormal
	 *            Situação Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situação Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situação Incluída de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Coleção de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasCliente(Integer idCliente,
			Short relacaoTipo, int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento,conta.parc_id as idParcelamento, "
					+ "conta.iper_id as imovelPerfil, categoria.catg_iccobrancaacrescimos as icAcrescimos "
					+ "FROM cadastro.cliente_conta clieConta "
					+ "INNER JOIN faturamento.conta conta on conta.cnta_id = clieConta.cnta_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "INNER JOIN cadastro.imovel imovel on imovel.imov_id = conta.imov_id "
					+ "INNER JOIN cadastro.categoria categoria on categoria.catg_id = imovel.imov_idcategoriaprincipal "					
					+ "WHERE clieConta.clie_id = :idCliente "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (relacaoTipo != null) {
				consulta += "and clieConta.crtp_id = " + relacaoTipo.toString();
			}

			consulta += " GROUP BY conta.iper_id, conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id, categoria.catg_iccobrancaacrescimos";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("dataRevisao", Hibernate.DATE)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("idSituacaoAtual", Hibernate.INTEGER)
					.addScalar("digitoVerificador", Hibernate.SHORT)
					.addScalar("idMotivoRevisao", Hibernate.INTEGER)
					.addScalar("ultimaAlteracao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("consumoAgua", Hibernate.INTEGER)
					.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
					.addScalar("consumoEsgoto", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.addScalar("imovelPerfil", Hibernate.INTEGER)
					.addScalar("icAcrescimos", Hibernate.INTEGER)					
					.setInteger("idCliente", idCliente)
					.setInteger("situacaoNormal",
							new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada",
							new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida",
							new Integer(contaSituacaoIncluida))
					.setInteger("situacaoParcelada",
							new Integer(contaSituacaoParcelada))
					.setInteger("inicialReferencia",
							new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia",
							new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
					.setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem o Valor
	 * Total dos Pagamentos da Conta Author: Rafael Santos Data: 05/01/2006
	 * 
	 * @param idConta
	 *            Id Conta
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarValorTotalPagamentoMenorDataPagamento(
			String idConta) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT SUM(p.valorPagamento),MIN(p.dataPagamento) "
					+ "FROM Pagamento p " + "WHERE p.contaGeral.id = :id "
					+ "GROUP BY p.contaGeral.id";

			retorno = session.createQuery(consulta)
					.setInteger("id", new Integer(idConta).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem o Valor
	 * Total dos Pagamentos da Guia de Pagamento Author: Rafael Santos,Rafael
	 * Santos Data: 07/01/2006,21/03/2006
	 * 
	 * @param idGuiaPagamento
	 *            Id Guia Pagamento
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarValorTotalGuiaPagamentoMenorDataGuiaPagamento(
			String idGuiaPagamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select sum(p.valorPagamento), min(p.dataPagamento) "
					+ "from Pagamento p "
					+ "inner join p.guiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :id "
					+ "group by guiaPagamento.id";

			retorno = session.createQuery(consulta)
					.setInteger("id", new Integer(idGuiaPagamento)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @param situacaoNormal
	 *            situacao de debito credito
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarImovel(String idImovel,
			String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac,debitoTipo.descricao,debitoTipo.id,debitoTipo.indicadorDividaAtiva  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.imovel imovel "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "where imovel.id = :id "
					+ "and dac.numeroPrestacaoCobradas < "
					+ "(dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id)";

			retorno = session.createQuery(consulta)
					.setInteger("id", new Integer(idImovel))
					.setInteger("normal", new Integer(situacaoNormal)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006 Pesquisa os ID dos imoveis dos cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDImoveisClienteImovel(String codigoCliente,
			Short relacaoTipo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteImovel ci "
					+ "inner join ci.imovel imovel "
					+ "inner join ci.cliente cliente ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join ci.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta
					+ "where ci.dataFimRelacao is null and cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 07/01/2006 Pesquisa os ID dos clientes contas
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return ID dos Imvoeis Cliente Conta
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDImoveisClienteConta(String codigoCliente,
			Short relacaoTipo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteConta cc "
					+ "inner join cc.conta conta "
					+ "inner join cc.cliente cliente "
					+ "inner join conta.imovel imovel ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join cc.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 06/01/2006 Colecção de Debitos a Cobrar de Cliente
	 * 
	 * @param colecaoIdImoveis
	 *            Coleção de ID dos Imoveis
	 * @param situacaoNormal
	 *            Situação Normal
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCliente(Collection idsImoveis,
			String situacaoNormal) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select dac,debitoTipo.descricao,debitoTipo.id, debitoTipo.indicadorDividaAtiva "
					+ "from DebitoACobrar dac "
					+ "inner join dac.imovel imovel "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join dac.debitoTipo debitoTipo "
					+ "where imovel.id IN(:ids) "
					+ "and dac.numeroPrestacaoCobradas < "
					+ "(dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id)";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createQuery(consulta)
							.setInteger("normal",
									new Integer(situacaoNormal).intValue())
							.setParameterList("ids", particoes.get(i)).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createQuery(consulta)
						.setInteger("normal",
								new Integer(situacaoNormal).intValue())
						.setParameterList("ids", idsImoveis).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006 Colecção de Creditos a Realizar de Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param situacaoNormal
	 *            Situação Normal
	 * @return Coleção de Creditos A Realizar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarCliente(Collection idsImoveis,
			String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car, creditoTipo.descricao, creditoTipo.id "
					+ "from CreditoARealizar car "
					+ "inner join car.imovel imovel "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join car.creditoTipo creditoTipo "
					+ "where imovel.id IN(:ids) "
					+ "and (car.numeroPrestacaoRealizada < car.numeroPrestacaoCredito or "
					+ "car.valorResidualMesAnterior > 0) "
					+ " and car.debitoCreditoSituacaoAtual = :normal ";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createQuery(consulta)
							.setInteger("normal",
									new Integer(situacaoNormal).intValue())
							.setParameterList("ids", particoes.get(i)).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createQuery(consulta)
						.setInteger("normal",
								new Integer(situacaoNormal).intValue())
						.setParameterList("ids", idsImoveis).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @return Coleção de Creditos A Realizar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarImovel(String idImovel,
			String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car,creditoTipo.descricao, creditoTipo.id "
					+ "from CreditoARealizar car "
					+ "inner join car.imovel imovel "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join car.creditoTipo creditoTipo "
					+ "where imovel.id = :id "
					+ "and (car.numeroPrestacaoRealizada < car.numeroPrestacaoCredito or "
					+ "car.valorResidualMesAnterior > 0) "
					+ " and car.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("id", new Integer(idImovel).intValue())
					.setInteger("normal",
							new Integer(situacaoNormal).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente
	 * 
	 * Author: Rafael Santos,Rafael Santos, Ivan Sérgio Data: 07/01/2006,
	 * 21/03/2006, 07/01/2009 Alteracao: 07/01/2009 - CRC932: No HQL do primeiro
	 * IF os dois ultimos campos estvam com o alias escrito errado. No ultimo
	 * campo faltava um espaco.
	 * 
	 * Colecção de Guias de Pagamento do Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @param situacaoNormal
	 *            Situação Normal
	 * @param clienteRelacaoTipo
	 *            Relação Cliente Tipo
	 * @return Coleção de Guias de Pagamento do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoCliente(Integer idCliente,
			int indicadorPagamento, String situacaoNormal,
			Short clienteRelacaoTipo, Date dataVencimentoInicial,
			Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM cadastro.cliente_guia_pagamento clieGuia "
					+ "INNER JOIN faturamento.guia_pagamento guia on guia.gpag_id = clieGuia.gpag_id "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE clieGuia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			if (clienteRelacaoTipo != null) {
				consulta += " and clieGuia.crtp_id = "
						+ clienteRelacaoTipo.toString();
			}

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			consulta += "UNION ";

			consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal  ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			retorno = session.createSQLQuery(consulta)
					.addScalar("idGuia", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("descricaoDebitoTipo", Hibernate.STRING)
					.addScalar("dataEmissao", Hibernate.DATE)
					.addScalar("idDebitoTipo", Hibernate.INTEGER)
					.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
					.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.setInteger("idCliente", idCliente)
					.setInteger("situacaoNormal", new Integer(situacaoNormal))
					.setDate("inicialVencimento", dataVencimentoInicial)
					.setDate("finalVencimento", dataVencimentoFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0216] Calcular Acréscimo por Impontualidade Santos Data:
	 * 09/01/2006 Dados do Indices Acrescimo Impontualidade
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano Mês de Referencia de Débito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarIndiceAcrescimoImpontualidade(
			int anoMesReferenciaDebito) throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia =  :anoMesReferencia";

			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferencia",
							new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Pesquisa o acréscimo da maneira correta
	 * 
	 * Data: 07/09/2009 Author: Rafael Corrêa
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano Mês de Referencia de Débito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIgualIndiceAcrescimoImpontualidade(
			int anoMesReferenciaDebito) throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select max(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2 where iai2.anoMesReferencia <= :anoMesReferencia)";

			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferencia",
							new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Faz parte de [UC0216] Calcular Acréscimo por Impontualidade Santos Data:
	 * 09/01/2006 Pesquisa os dados do Indices Acrescimo Impontualidade menor ao
	 * ano mes referencia
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano Mês de Referencia de Débito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIndiceAcrescimoImpontualidade(
			int anoMesReferenciaDebito) throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select max(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2 where iai2.anoMesReferencia < :anoMesReferencia)";

			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferencia",
							new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 07/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situação Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Coleção de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoImovel(Integer idImovel,
			int indicadorPagamento, String situacaoNormal,
			Date dataVencimentoInicial, Date dataVencimentoFinal)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.imov_id = :idImovel "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal  ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			consulta += " order by guia.gpag_dtvencimento asc ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idGuia", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("descricaoDebitoTipo", Hibernate.STRING)
					.addScalar("dataEmissao", Hibernate.DATE)
					.addScalar("idDebitoTipo", Hibernate.INTEGER)
					.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
					.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal", new Integer(situacaoNormal))
					.setDate("inicialVencimento", dataVencimentoInicial)
					.setDate("finalVencimento", dataVencimentoFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0200] Inserir Débito Automático [FS0004] Verificar Data de Opção
	 * posterior já informada
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDataOpcao(String matriculaImovel, Date dataOpcao,
			String identificadorCliente, String codigoAgencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id "
					+ "from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia "
					+ "where imovel.id = :matricula AND "
					// Alterado Bruno Barros
					// + "((agencia.codigoAgencia = :codigoAgencia AND "
					// +
					// "deb.identificacaoClienteBanco = :identificadorCliente) OR "
					+ "(deb.dataExclusao is null "
					+ "and deb.dataOpcaoDebitoContaCorrente >= :data)";

			retorno = session
					.createQuery(consultaDataOpcao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0201] Excluir Débito Automático [FS0004] Verificar Data de Opção
	 * posterior já informada
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDataOpcaoExclusao(String matriculaImovel,
			Date dataOpcao, String identificadorCliente)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id " + "from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia "
					+ "where imovel.id = :matricula AND "
					+ "deb.dataExclusao is null "
					+ "and deb.dataOpcaoDebitoContaCorrente > :data";

			retorno = session
					.createQuery(consultaDataOpcao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0200] Inserir Débito Automático Verificar se o Imóvel já é Débito
	 * Automático
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDebitoAutomatico(String matriculaImovel)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String verificaDebitoAutomatico;

		try {
			// Verifica se já tem débito automático
			verificaDebitoAutomatico = "select agencia.id "
					+ "from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia "
					+ "where imovel.id = :matricula "
					+ "and deb.dataExclusao is null ";

			retorno = session
					.createQuery(verificaDebitoAutomatico)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0200] Inserir Débito Automático Atualiza a data da exclusão com a data
	 * corrente em Débio Automático
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarDataExclusao(String matriculaImovel)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em débito automático a Data Exclusão com a data corrente
			atualizaDataExclusao = "update gcom.arrecadacao.debitoautomatico.DebitoAutomatico "
					+ "set deba_dtexclusao = :data,deba_tmultimaalteracao = :ultimaAlteracao where imov_id = :matricula";

			session.createQuery(atualizaDataExclusao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", new Date())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0200] Inserir Débito Automático
	 * 
	 * @author Roberta Costa
	 * @created 04/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @param codigoBanco
	 *            Código do Banco
	 * @param codigoAgencia
	 *            Código da Agência
	 * @param identificacaoCliente
	 *            Identificação do Cliente no Banco
	 * @param dataOpcao
	 *            Data da Opção
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void inserirDebitoAutomatico(DebitoAutomatico debitoAutomatico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			// Inclui o débito automárico

			session.save(debitoAutomatico);
			session.flush();
			session.clear();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0200] Inserir Débito Automático Atualiza o indicador de débio
	 * automático em Imóvel
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarIndicadorDebitoAutomatico(String matriculaImovel,
			Integer indicadorDebito) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaIndicadorDebitoAutomatico;

		try {
			// Atualiza em débito automático a Data Exclusão com a data corrente
			atualizaIndicadorDebitoAutomatico = "update gcom.cadastro.imovel.Imovel "
					+ "set imov_icdebitoconta = :indicador,imov_tmultimaalteracao = :ultimaAlteracao where imov_id = :matricula";

			session.createQuery(atualizaIndicadorDebitoAutomatico)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setInteger("indicador", indicadorDebito)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0201] Remover Débito Automático Verificar se o Imóvel já é Débito
	 * Automático para o mesmo Banco e Agencia
	 * 
	 * @author Roberta Costa
	 * @created 09/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDebitoAutomaticoBancoAgencia(String codigoBanco,
			String codigoAgencia) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String verificaDebitoAutomatico;

		try {
			// Verifica se já tem débito automático
			verificaDebitoAutomatico = "select agencia.id "
					+ "from Agencia agencia "
					+ "inner join agencia.banco banco "
					+ "where banco.id = :codigoBanco "
					+ "and agencia.codigoAgencia = :agencia ";

			retorno = session
					.createQuery(verificaDebitoAutomatico)
					.setInteger("codigoBanco",
							new Integer(codigoBanco).intValue())
					.setString("agencia", codigoAgencia).setMaxResults(1)
					.uniqueResult();

			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeCronograma
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	/*
	 * public Collection<CobrancaAcaoAtividadeCronograma>
	 * pesquisarCobrancaAcaoAtividadeCronograma() throws
	 * ErroRepositorioException{
	 * 
	 * //cria a variável que vai armazenar a coleção pesquisada
	 * Collection<CobrancaAcaoAtividadeCronograma> retorno = null;
	 * 
	 * //cria uma sessão com o hibernate Session session =
	 * HibernateUtil.getSession();
	 * 
	 * //cria a variável que vai conter o hql String consulta;
	 * 
	 * try { //constroi o hql consulta = "select caac " + "from
	 * CobrancaAcaoAtividadeCronograma caac " + "where (caac.comando is not
	 * null) and " + "((caac.realizacao is null) or (caac.realizacao <
	 * caac.comando))";
	 * 
	 * //executa o hql retorno = session.createQuery(consulta).list();
	 * 
	 * //erro no hibernate } catch (HibernateException e) { // levanta a exceção
	 * para a próxima camada throw new ErroRepositorioException(e, "Erro no
	 * Hibernate"); } finally { // fecha a sessão
	 * HibernateUtil.closeSession(session); }
	 * 
	 * //retorna a coleção do resultado da pesquisa return retorno; }
	 */

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeComand
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	/*
	 * public Collection<CobrancaAcaoAtividadeComand>
	 * pesquisarCobrancaAcaoAtividadeComand() throws ErroRepositorioException{
	 * 
	 * //cria a variável que vai armazenar a coleção pesquisada
	 * Collection<CobrancaAcaoAtividadeComand> retorno = null;
	 * 
	 * //cria uma sessão com o hibernate Session session =
	 * HibernateUtil.getSession();
	 * 
	 * //cria a variável que vai conter o hql String consulta;
	 * 
	 * try { //constroi o hql consulta = "select cacm " + "from
	 * CobrancaAcaoAtividadeComand cacm " + "where (cacm.comando is not null)
	 * and " + "((cacm.realizacao is null) or (cacm.realizacao <
	 * cacm.comando))";
	 * 
	 * //executa o hql retorno = session.createQuery(consulta).list();
	 * 
	 * //erro no hibernate } catch (HibernateException e) { // levanta a exceção
	 * para a próxima camada throw new ErroRepositorioException(e, "Erro no
	 * Hibernate"); } finally { // fecha a sessão
	 * HibernateUtil.closeSession(session); }
	 * 
	 * //retorna a coleção do resultado da pesquisa return retorno; }
	 */

	/**
	 * Consultar Dados do Cliente Imovel Vinculado Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param inscricaoImovel
	 *            Inscrição do Imovel
	 * @return Dados do Imovel Vinculado
	 * @throws ControladorException
	 */
	public Object[] consultarDadosClienteImovelUsuario(Imovel imovel)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select cliente.id,cliente.nome "
					+ "from ClienteImovel clienteImovel "
					+ "inner join clienteImovel.cliente cliente "
					+ "inner join clienteImovel.imovel imovel "
					+ "inner join clienteImovel.clienteRelacaoTipo clienteRelacaoTipo "
					+ "where imovel.id = :id and clienteRelacaoTipo.id = :usuario "
					+ "and clienteImovel.clienteImovelFimRelacaoMotivo is null";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("id", imovel.getId().intValue())
					.setInteger("usuario", ClienteRelacaoTipo.USUARIO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Consultar Matriculas dos Imoveis Vinculados do Imovel condominio Auhtor:
	 * Rafael Santos Data: 23/01/2006 [UC0179] Consultar Historico Medição
	 * Indiviualizada
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarConsumoHistoricoImoveisVinculados(
			ConsumoHistorico consumoHistorico) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.id " + "from ConsumoHistorico consumo "
					+ "inner join consumo.imovel imovel "
					+ "where consumo.consumoImovelCondominio = :id";

			retorno = session.createQuery(consulta)
					.setInteger("id", consumoHistorico.getId().intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Consultar Consumo Tipo do Consumo Historico Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return Dados do Consumo Tipo
	 * @throws ControladorException
	 */
	public Object[] consultarDadosConsumoTipoConsumoHistorico(
			ConsumoHistorico consumoHistorico) throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select consumo.descricaoAbreviada,consumo.id "
					+ "from ConsumoTipo consumo " + "where consumo.id = :id";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger(
							"id",
							consumoHistorico.getConsumoTipo().getId()
									.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consultar Consumo Historico da Medicao Individualizada Auhtor: Rafael
	 * Santos Data: 23/01/2006 [UC0179] Consultar Historico Medição
	 * Indiviualizada
	 * 
	 * @param imovel
	 *            Imovel
	 * @param ligcaoTipo
	 *            Tipo de Ligacação
	 * @param anoMesFaturamento
	 *            Ano Mes Faturamento
	 * @return
	 * @throws ControladorException
	 */
	public Object[] obterConsumoHistoricoMedicaoIndividualizada(Imovel imovel,
			LigacaoTipo ligacaoTipo, int anoMesFaturamento)
			throws ErroRepositorioException {
		Object[] retornoDados = null;
		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select ch.id,ch.consumoRateio, "
					+ "ch.numeroConsumoFaturadoMes,ch.consumoTipo "
					+ "from ConsumoHistorico ch where  "
					+ "ch.imovel.id = :id  "
					+ "and ch.referenciaFaturamento = :anoMes "
					+ "and ch.ligacaoTipo.id = :ligacao";

			retorno = session.createQuery(consulta)
					.setInteger("id", imovel.getId().intValue())
					.setInteger("anoMes", anoMesFaturamento)
					.setInteger("ligacao", ligacaoTipo.getId())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoDados = (Object[]) retorno;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retornoDados;

	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em conta
	 * 
	 * @author Fernanda Karla
	 * @created 14/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idConta
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoConta(String codigoConta, int situacaoAtual,
			int anoMesReferenciaContabil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoConta;

		try {
			// Atualiza em conta o DebitoCreditoSituacao
			atualizaSituacaoConta = "update gcom.faturamento.conta.Conta "
					+ "set dcst_idatual = :situacaoAtual, dcst_idanterior = null, "
					+ "cnta_tmultimaalteracao = :ultimaAlteracao, cnta_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where cnta_id = :codigoConta";

			session.createQuery(atualizaSituacaoConta)
					.setInteger("codigoConta",
							new Integer(codigoConta).intValue())
					.setInteger("situacaoAtual",
							new Integer(situacaoAtual).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em guia pagamento
	 * 
	 * @author Fernanda Karla
	 * @created 15/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idGuiaPagamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoGuiaPagamento(String codigoGuiaPagamento,
			int situacaoAtualGuia, int anoMesReferenciaContabil)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoGuiaPagamento;

		try {
			// Atualiza em guiapagamento o DebitoCreditoSituacao
			atualizaSituacaoGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set dcst_idatual = :situacaoAtualGuia, dcst_idanterior = null, "
					+ "gpag_tmultimaalteracao = :ultimaAlteracao, gpag_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where gpag_id = :codigoGuiaPagamento";

			session.createQuery(atualizaSituacaoGuiaPagamento)
					.setInteger("codigoGuiaPagamento",
							new Integer(codigoGuiaPagamento).intValue())
					.setInteger("situacaoAtualGuia",
							new Integer(situacaoAtualGuia).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idParcelamento
	 *            motivo parcelamentoSituacao
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarParcelamento(Integer codigoParcelamento,
			Integer parcelamentoSituacao, String motivo, Integer usuarioId)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaParcelamento;

		try {
			// Atualiza em guiapagamento o DebitoCreditoSituacao
			atualizaParcelamento = "update gcom.cobranca.parcelamento.Parcelamento "
					+ "set "
					+ "pcst_id = :parcelamentoSituacao, "
					+ "pmdz_id = :motivo, "
					+ "parc_tmultimaalteracao = :ultimaAlteracao, "
					+ "usur_iddesfaz = :usuarioId  "
					+ "where parc_id = :codigoParcelamento";

			session.createQuery(atualizaParcelamento)
					.setInteger("codigoParcelamento",
							new Integer(codigoParcelamento).intValue())
					.setInteger("parcelamentoSituacao",
							new Integer(parcelamentoSituacao).intValue())
					.setInteger("motivo", new Integer(motivo).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("usuarioId", usuarioId.intValue())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em debito a cobrar
	 * 
	 * @author Fernanda Karla
	 * @created 16/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            iddebitoacobrar
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoDebitoACobrar(String codigoDebitoACobrar,
			int situacaoAtualDebito, int anoMesReferenciaContabil)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoDebitoACobrar;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			atualizaSituacaoDebitoACobrar = "update gcom.faturamento.debito.DebitoACobrar "
					+ "set dcst_idatual = :situacaoAtualDebito, dcst_idanterior = null, "
					+ "dbac_tmultimaalteracao = :ultimaAlteracao, dbac_amreferenciacontabil =:anoMesReferenciaContabil  "
					+ "where dbac_id = :codigoDebitoACobrar";

			session.createQuery(atualizaSituacaoDebitoACobrar)
					.setInteger("codigoDebitoACobrar",
							new Integer(codigoDebitoACobrar).intValue())
					.setInteger("situacaoAtualDebito",
							new Integer(situacaoAtualDebito).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Atualiza o debitocreditosituacao
	 * em credito a realizar
	 * 
	 * @author Fernanda Karla
	 * @created 16/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idCreditoARealizar
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoCreditoARealizar(
			String codigoCreditoARealizar, int situacaoAtualCredito,
			int anoMesReferenciaContabil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoCreditoARealizar;

		try {
			// Atualiza em creditoarealizar o DebitoCreditoSituacao
			atualizaSituacaoCreditoARealizar = "update gcom.faturamento.credito.CreditoARealizar "
					+ "set dcst_idatual = :situacaoAtualCredito, dcst_idanterior = null, "
					+ "crar_tmultimaalteracao = :ultimaAlteracao , crar_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where crar_id = :codigoCreditoARealizar";

			session.createQuery(atualizaSituacaoCreditoARealizar)
					.setInteger("codigoCreditoARealizar",
							new Integer(codigoCreditoARealizar).intValue())
					.setInteger("situacaoAtualCredito",
							new Integer(situacaoAtualCredito).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove débitos a cobrar referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerDebitoACobrarDoParcelamento(Integer codigoImovel,
			Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerDebitoACobrarDoParcelamento;
		String consulta;
		Collection collectionIdDebito = null;

		try {

			consulta = "select dac.id  "
					+ "from DebitoACobrar dac "
					+ "where dac.imovel.id = :codigoImovel and dac.parcelamento.id = :codigoParcelamento";

			collectionIdDebito = session
					.createQuery(consulta)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete DebitoACobrarCategoria debitoACobrarCategoria "
							+ "where debitoACobrarCategoria.debitoACobrar.id = :debito ";

					session.createQuery(consulta)
							.setInteger("debito", new Integer(id).intValue())
							.executeUpdate();
				}
			}

			// deleta cobrança documento item
			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
							+ "where cobrancaDocumentoItem.debitoACobrarGeral.id = :debito ";

					session.createQuery(consulta)
							.setInteger("debito", new Integer(id).intValue())
							.executeUpdate();
				}
			}

			// deleta o debito a cobrar
			removerDebitoACobrarDoParcelamento = "delete DebitoACobrar "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerDebitoACobrarDoParcelamento)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete DebitoACobrarGeral debitoACobrarGeral "
							+ "where debitoACobrarGeral.debitoACobrar.id = :debito ";

					session.createQuery(consulta)
							.setInteger("debito", new Integer(id).intValue())
							.executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove débitos a cobrar categoria
	 * referentes ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerDebitoACobrarCategoriaDoParcelamento(Integer idDebito)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerDebitoACobrarDoParcelamento;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			removerDebitoACobrarDoParcelamento = "delete gcom.faturamento.debito.DebitoACobrarCategoria "
					+ "where dbac_id = :idDebito ";

			session.createQuery(removerDebitoACobrarDoParcelamento)
					.setInteger("idDebito", idDebito.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Seleciona o débito a cobrar para
	 * remover do parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarDoParcelamento(
			Integer codigoImovel, Integer codigoParcelamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<DebitoACobrar> retorno = null;
		String pesquisarDebitoACobrarDoParcelamento;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			pesquisarDebitoACobrarDoParcelamento = "SELECT debitoACobrar FROM DebitoACobrar debitoACobrar "
					+ "INNER JOIN FETCH debitoACobrar.debitoTipo debitoTipo "
					+ "WHERE debitoACobrar.imovel.id = :codigoImovel AND debitoACobrar.parcelamento.id = :codigoParcelamento ";

			retorno = session
					.createQuery(pesquisarDebitoACobrarDoParcelamento)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove credito a realizar
	 * referentes ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerCreditoARealizarDoParcelamento(Integer codigoImovel,
			Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerCreditoARealizarDoParcelamento;
		String consulta;
		Collection collectionIdCredito = null;

		try {

			consulta = "select car.id  "
					+ "from CreditoARealizar car "
					+ "where car.imovel.id = :codigoImovel and car.parcelamento.id = :codigoParcelamento";

			collectionIdCredito = session
					.createQuery(consulta)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

			if (collectionIdCredito != null && !collectionIdCredito.isEmpty()) {

				Iterator icolecaoCreditos = collectionIdCredito.iterator();

				while (icolecaoCreditos.hasNext()) {

					String id = ((Integer) icolecaoCreditos.next()).toString();
					consulta = "delete CreditoARealizarCategoria creditoARealizarCategoria "
							+ "where creditoARealizarCategoria.creditoARealizar.id = :credito ";

					session.createQuery(consulta)
							.setInteger("credito", new Integer(id).intValue())
							.executeUpdate();
				}
			}

			// deleta o debito a cobrar
			removerCreditoARealizarDoParcelamento = "delete CreditoARealizar "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerCreditoARealizarDoParcelamento)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdCredito != null && !collectionIdCredito.isEmpty()) {

				Iterator icolecaoCreditos = collectionIdCredito.iterator();

				while (icolecaoCreditos.hasNext()) {

					String id = ((Integer) icolecaoCreditos.next()).toString();
					consulta = "delete CreditoARealizarGeral creditoARealizarGeral "
							+ "where creditoARealizarGeral.creditoARealizar.id = :credito ";

					session.createQuery(consulta)
							.setInteger("credito", new Integer(id).intValue())
							.executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove guia pagamento referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerGuiaPagamentoDoParcelamento(Integer codigoParcelamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerGuiaPagamentoDoParcelamento;
		String removerGuiaPagamentoCategoria;
		String removerClienteGuiaPagamento;
		String removerGuiaPagamentoItemCategoria;
		String removerGuiaPagamentoItem;
		String consulta;
		Collection collectionIdGuia = null;
		Collection collectionIdGuiaItem = null;

		try {

			consulta = "select gui.id  " + "from GuiaPagamento gui "
					+ "where gui.parcelamento.id = :codigoParcelamento";

			collectionIdGuia = session
					.createQuery(consulta)
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					removerGuiaPagamentoCategoria = "delete GuiaPagamentoCategoria guiaPagamentoCategoria "
							+ "where guiaPagamentoCategoria.guiaPagamento.id = :guia ";

					session.createQuery(removerGuiaPagamentoCategoria)
							.setInteger("guia", new Integer(id).intValue())
							.executeUpdate();

					removerClienteGuiaPagamento = "delete ClienteGuiaPagamento clienteGuiaPagamento "
							+ "where clienteGuiaPagamento.guiaPagamento.id = :guia ";

					session.createQuery(removerClienteGuiaPagamento)
							.setInteger("guia", new Integer(id).intValue())
							.executeUpdate();

					consulta = "select gpi.id  "
							+ "from GuiaPagamentoItem gpi "
							+ "where gpi.guiaPagamentoGeral.id = :guia";

					collectionIdGuiaItem = session.createQuery(consulta)
							.setInteger("guia", new Integer(id)).list();

					Iterator iteratorItem = collectionIdGuiaItem.iterator();

					while (iteratorItem.hasNext()) {

						Integer idItem = (Integer) iteratorItem.next();

						// deleta as categorias dos itens
						removerGuiaPagamentoItemCategoria = "delete GuiaPagamentoItemCategoria guiaPagamentoItemCategoria "
								+ "where guiaPagamentoItemCategoria.guiaPagamentoItem.id = :item ";

						session.createQuery(removerGuiaPagamentoItemCategoria)
								.setInteger("item", idItem).executeUpdate();

						// deleta os itens
						removerGuiaPagamentoItem = "delete GuiaPagamentoItem  guiaPagamentoItem "
								+ "where guiaPagamentoItem.id = :item ";

						session.createQuery(removerGuiaPagamentoItem)
								.setInteger("item", idItem).executeUpdate();
					}

				}
			}

			// deleta cobrança documento item
			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
							+ "where cobrancaDocumentoItem.guiaPagamentoGeral.id = :guia ";

					session.createQuery(consulta)
							.setInteger("guia", new Integer(id).intValue())
							.executeUpdate();
				}

			}

			// deleta o debito a cobrar
			removerGuiaPagamentoDoParcelamento = "delete GuiaPagamento "
					+ "where parc_id = :codigoParcelamento ";

			session.createQuery(removerGuiaPagamentoDoParcelamento)
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					consulta = "delete GuiaPagamentoGeral guiaPagamentoGeral "
							+ "where guiaPagamentoGeral.guiaPagamento.id = :guia ";

					session.createQuery(consulta)
							.setInteger("guia", new Integer(id).intValue())
							.executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove guia pagamento referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerGuiaPagamentoCobrancaDoParcelamento(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerGuiaPagamentoDoParcelamento;

		try {
			// remove em credito a realizar os parcelamentos
			removerGuiaPagamentoDoParcelamento = "delete gcom.arrecadacao.pagamento.GuiaPagamentoCategoria "
					+ "where gpag_id = :idGuiaPagamento ";

			session.createQuery(removerGuiaPagamentoDoParcelamento)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeCronograma
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarCobrancaAcaoAtividadeCronograma()
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<CobrancaAcaoAtividadeCronograma> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select caac "
					+ "from CobrancaAcaoAtividadeCronograma caac "
					+ " left join fetch caac.cobrancaAcaoCronograma cac"
					+ " left join fetch caac.cobrancaAtividade"
					+ " left join fetch cac.cobrancaAcao"
					+ " left join fetch cac.cobrancaGrupoCronogramaMes"
					+ " left join fetch cac.cobrancaGrupoCronogramaMes cgcm"
					+ " left join fetch cgcm.cobrancaGrupo"
					+ "where (caac.comando is not null) and "
					+ "((caac.realizacao is null) or (caac.realizacao < caac.comando))";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).list()));

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0246] Executar Atividade de Ação de Cobrança Pesquisa uma coleção de
	 * CobrancaAcaoAtividadeComando
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<CobrancaAcaoAtividadeComando> pesquisarCobrancaAcaoAtividadeComando()
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<CobrancaAcaoAtividadeComando> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cacm "
					+ "from CobrancaAcaoAtividadeComando cacm "
					+ " left join fetch cacm.cobrancaAcao ca"
					+ " left join fetch cacm.cobrancaAtividade cat"
					+ " left join fetch cacm.usuario usuario"
					+ "where (cacm.comando is not null) and "
					+ "((cacm.realizacao is null) or (cacm.realizacao < cacm.comando))";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).list()));

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @created 16/02/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel,
			int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,"
					+ "cd.valorTaxa,loca.id, documentoTipo.id,cdst.id "
					+ "FROM CobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.cobrancaDebitoSituacao cdst "
					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "imovel.id = :idImovel";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idImovel", idImovel.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0005] - Processar
	 * Recebimento de Acréscimos por Inpontualidade Autor: Sávio Luiz
	 * Data:06/11/2006
	 */
	public Collection pesquisarCobrancaDocumentoItemComConta(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta " + "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "WHERE conta.id is not null AND "
					+ "cd.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0005] - Processar
	 * Recebimento de Acréscimos por Inpontualidade Autor: Sávio Luiz
	 * Data:06/11/2006
	 */
	public Collection pesquisarCobrancaDocumentoItemComGuiaPagamento(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT guiaPagamento.id "
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "WHERE guiaPagamento.id is not null AND "
					+ "cd.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz, Ivan Sergio
	 * @created 16/02/2006 01/10/2010 - CRC5063 - Adicionado o id do Item para
	 *          auxiliar a CRC;
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel,
			int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id, " // 15
					+ "debitoACobrar.numeroPrestacaoDebito, " // 16
					+ "debitoACobrar.numeroPrestacaoCobradas, " // 17
					+ "cdi.numeroParcelasAntecipadas, " // 18
					+ "cdi.id " // 19
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.imovel imov "
					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "imovel.id = :idImovel "
					+ "ORDER BY documentoTipo.id desc ";

			retorno = session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Inseri a cobrança situação historico na base passando a coleção de
	 * cobrança situação historico
	 * 
	 * [UC0177] Informar Situacao Especial de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @date 20/03/2006
	 * 
	 * @param collectionCobrancaSituacaoHistorico
	 * @return
	 */
	public void inserirCobrancaSituacaoHistorico(
			Collection collectionCobrancaSituacaoHistorico)
			throws ErroRepositorioException {
		// StatelessSession session = HibernateUtil.getStatelessSession();
		// Iterator iteratorFSH =
		// collectionCobrancaSituacaoHistorico.iterator();
		// try {
		// // int i = 1;
		// while (iteratorFSH.hasNext()) {
		// CobrancaSituacaoHistorico cobrancaSituacaoHistorico =
		// (CobrancaSituacaoHistorico) iteratorFSH
		// .next();
		// session.insert(cobrancaSituacaoHistorico);
		// /*
		// * if (i % 50 == 0) { // 20, same as the JDBC batch size //
		// * flush a batch of inserts and release memory: session.flush();
		// * session.clear(); } i++;
		// */
		// }
		// // session.flush();
		// // session.clear();
		// } catch (HibernateException e) {
		// e.printStackTrace();
		// throw new ErroRepositorioException(e, "Erro no Hibernate");
		// } finally {
		//
		// // session.clear();
		// HibernateUtil.closeSession(session);
		// // session.close();
		// }
		//

		Session session = HibernateUtil.getSession();
		Iterator iteratorFSH = collectionCobrancaSituacaoHistorico.iterator();
		try {
			// int i = 1;
			while (iteratorFSH.hasNext()) {
				CobrancaSituacaoHistorico cobrancaSituacaoHistorico = (CobrancaSituacaoHistorico) iteratorFSH
						.next();
				session.save(cobrancaSituacaoHistorico);
				/*
				 * if (i % 50 == 0) { // 20, same as the JDBC batch size //
				 * flush a batch of inserts and release memory: session.flush();
				 * session.clear(); } i++;
				 */
			}
			session.flush();
			// session.clear();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			// session.clear();
			HibernateUtil.closeSession(session);
			// session.close();
		}

	}

	/**
	 * Atualiza o ano mes de cobranca situação historico
	 * 
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 17/03/2006
	 * 
	 * @param situacaoEspecialFaturamentoHelper
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesCobrancaSituacaoHistorico(
			SituacaoEspecialCobrancaHelper situacaoEspecialCobrancaHelper,
			Integer anoMesReferencia, Collection colecaoImoveis,
			Integer idCobrancaSituacaoConsumo) throws ErroRepositorioException {

		String consulta = "";

		Session session = HibernateUtil.getSession();
		try {

			consulta = "update gcom.cobranca.CobrancaSituacaoHistorico set "
					+ "cbsc_idretirada = :idCobrancaSituacaoConsumo, "
					+ "cbsh_amcobrancaretirada = :anoMes,"
					+ "usur_idretira = null,"
					+ "cbsh_tmultimaalteracao = :ultimaAlteracao "
					+ "where imov_id in ( :imoveis )"
					+ " and cbsh_amcobrancaretirada is null";

			session.createQuery(consulta)
					.setParameterList("imoveis", colecaoImoveis)
					.setInteger("anoMes", anoMesReferencia)
					.setInteger("idCobrancaSituacaoConsumo",
							idCobrancaSituacaoConsumo)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 30/03/2006 Pesquisa os ID das Contas dos cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDContasClienteConta(String codigoCliente,
			Short relacaoTipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta.id from ClienteConta clienteConta "
					+ "inner join clienteConta.cliente cliente "
					+ "inner join clienteConta.conta conta ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito atualizar na tabela imovel o
	 * parcelamento e reparcelamento
	 * 
	 * @author Fernanda Paiva
	 * @date 29/04/2006
	 * 
	 * @param imovel
	 * @param numeroParcelamento
	 * @param numeroReparcelamento
	 * @param numeroReparcelamentoConsecutivo
	 * @throws ErroRepositorioException
	 */
	public void atualizarDadosParcelamentoImovel(Integer codigoImovel,
			Short numeroParcelamento, Short numeroReparcelamento,
			Short numeroReparcelamentoConsecutivo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.cadastro.imovel.Imovel "
					+ "set imov_nnparcelamento = :numeroParcelamento, "
					+ "imov_nnreparcelamento = :numeroReparcelamento, "
					+ "imov_nnreparcmtconsec = :numeroReparcelamentoConsecutivo, "
					+ "imov_tmultimaalteracao = :ultimaAlteracao "
					+ "where imov_id = :codigoImovel";

			session.createQuery(atualizarImovel)
					.setInteger("codigoImovel",
							new Integer(codigoImovel).intValue())
					.setInteger("numeroParcelamento",
							new Short(numeroParcelamento).intValue())
					.setInteger("numeroReparcelamento",
							new Short(numeroReparcelamento).intValue())
					.setInteger(
							"numeroReparcelamentoConsecutivo",
							new Short(numeroReparcelamentoConsecutivo)
									.intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem os parcelamentos de débitos efetuados no mês de faturamento
	 * corrente e que estejam com situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSituacaoNormalNoMes(
			String parcelamentoSituacao, Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct parc.id, parc.parcelamento, imov.id  "
					+ "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "WHERE parc.anoMesReferenciaFaturamento = :anoMesReferenciaArrecadacao "
					+ "AND parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND parc.cobrancaForma = :cobrancaEmConta "
					+ "AND (parc.valorEntrada IS NOT NULL AND parc.valorEntrada > 0) "
					+ "AND dbac.numeroPrestacaoCobradas = 0 "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("parcelamentoSituacao",
							new Integer(parcelamentoSituacao))
					.setInteger("cobrancaEmConta",
							CobrancaForma.COBRANCA_EM_CONTA)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem as guias de pagamentos dos parcelamentos de débitos efetuados no
	 * mês de faturamento corrente e que estejam com situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoDoParcelamento(String parcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT gpag.id, gpag.dataVencimento  "
					+ "FROM GuiaPagamento gpag "
					+ "WHERE gpag.parcelamento = :parcelamento ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", new Integer(parcelamento))
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Raphael
	 * Rossiter Data: 28/12/2006
	 * 
	 * Obtem as contas dos parcelamentos de débitos efetuados no mês de
	 * faturamento corrente e que estejam com situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaDoParcelamento(Integer parcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT cnta.id " + "FROM Conta cnta "
					+ "WHERE cnta.parcelamento.id = :parcelamento ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", parcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem os pagamentos para a guia de pagamentos dos parcelamentos de
	 * débitos efetuados no mês de faturamento corrente e que estejam com
	 * situação normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoParaGuiaPagamentoDoParcelamento(
			String igGuiaPagamento, Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// alterado por Vivianne Sousa - 03/09/2009 - Adriano Britto
			// alguns pagamentos não estavam guardando o id da guia,
			// para esses casos recupera o pagamento do imovel correspondente a
			// entrada de parcelamento
			consulta = " select pgmt_id as idPagamento "
					+ " from arrecadacao.pagamento "
					+ " where  gpag_id = :idGuiaPagamento "
					+ " or (imov_id = :idImovel and dbtp_id = :entradaParcelamento )";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.setInteger("idGuiaPagamento", new Integer(igGuiaPagamento))
					.setInteger("entradaParcelamento",
							DebitoTipo.ENTRADA_PARCELAMENTO)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada Não Paga Author: Raphael
	 * Rossiter Data: 28/12/2006
	 * 
	 * Obtem os pagamentos para a conta dos parcelamentos de débitos efetuados
	 * no mês de faturamento corrente e que estejam com situação normal
	 * 
	 * @param conta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoParaContaDoParcelamento(String idConta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT pgmt.id  " + "FROM Pagamento pgmt "
					+ "WHERE pgmt.contaGeral = :conta ";

			retorno = session.createQuery(consulta)
					.setInteger("conta", new Integer(idConta)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0317] Manter Critério de Cobrança
	 * 
	 * Este caso de uso remove as linhas da cobrança critério passando a colecao
	 * de cobrança criterio
	 * 
	 * [SB0002] Excluir Critério de Cobrança
	 * 
	 * @author Sávio luiz
	 * @created 11/05/2006
	 * 
	 * @throws ControladorException
	 *             Controlador Exception
	 */
	public void removerCobrancaCriterioLinha(String[] idscobrancaCriterio)
			throws ErroRepositorioException {

		String remocao = null;

		/*
		 * Collection colecaoCobrancaCriterio = new ArrayList(); for(int
		 * i=0;i<idscobrancaCriterio.length;i++ ){ CobrancaCriterio
		 * cobrancaCriterio = new CobrancaCriterio(); cobrancaCriterio.setId(new
		 * Integer(idscobrancaCriterio[i]));
		 * colecaoCobrancaCriterio.add(cobrancaCriterio); }
		 */

		Session session = HibernateUtil.getSession();

		try {

			remocao = "delete gcom.cobranca.CobrancaCriterioLinha "
					+ "where cbct_id IN(:idscobrancaCriterio)";

			session.createQuery(remocao)
					.setParameterList("idscobrancaCriterio",
							idscobrancaCriterio).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public Collection gerarRelacaoDebitos(String idImovelCondominio,
			String idImovelPrincipal, String idNomeConta,
			String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua,
			String consumoMinimoFinalAgua, String idSituacaoLigacaoEsgoto,
			String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa,
			String ordenacao, int quantidadeImovelInicio,
			String indicadorCpfCnpj, String cpfCnpj)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct "
					+ "gerenciaRegional.id,"
					+ "gerenciaRegional.nomeAbreviado,"
					+ "localidade.id,"
					+ "localidade.descricao,"
					+ "imovel.id,"
					+ "imovel.quantidadeEconomias,"
					+ "setorComercial.codigo, "
					+ "quadra.numeroQuadra,"
					+ "imovel.lote,"
					+ "imovel.subLote,"
					+ "ligacaoAguaSituacao.descricao,"
					+ "ligacaoEsgotoSituacao.descricao,"
					+ "ligacaoEsgoto.percentual,"
					+ "ligacaoAgua.dataCorte, "
					+ "gerenciaRegional.nome, "
					+ "clienteUsuario.nome, "
					+ "clienteResposanvel.nome, "
					+ "rota.codigo, "
					+ "imovel.numeroSequencialRota, "
					+ "(select  coalesce((sum (co.valorAgua + co.valorEsgoto + co.debitos - co.valorCreditos - coalesce(co.valorImposto,0))),0) "
					+ "from Conta co "
					+ "where imovel.id = co.imovel.id "
					+ "and co.debitoCreditoSituacaoAtual.id in (0, 1, 2) "
					+ "and co.id not in (select coalesce(pg.id,0) from Pagamento pg where pg.imovel.id = co.imovel.id)) "
					// "consumosHistorico.consumoMedio " +

					+ " from ImovelSubcategoria imovelSubcategoria ";
			if (idCobrancaSituacaoTipo != null
					&& !idCobrancaSituacaoTipo.equals("")
					&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " , ImovelCobrancaSituacao imovelCobrancaSituacao ";
			}

			consulta = consulta
					+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
					+ " inner join imovel.localidade localidade   "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " inner join imovel.setorComercial setorComercial   "
					+ " inner join imovel.quadra quadra "
					+ " inner join quadra.rota rota "
					+ " left  join  imovelSubcategoria.comp_id.subcategoria subCategoria "
					+ " left join subCategoria.categoria categoria "
					+ " left  join imovel.logradouroBairro logradouroBairro  "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " left  join bairro.municipio municipio   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.cep cep   "
					+ " left  join logradouroCep.logradouro logradouro   "
					+ " left  join imovel.imovelCondominio imovelCondominio   "
					+ " left  join imovel.imovelPrincipal imovelPrincipal   "
					// + " left join imovel.nomeConta nomeConta "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua  "
					+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  "
					+ " left  join imovel.imovelPerfil imovelPerfil  "
					+ " left  join imovel.pocoTipo pocoTipo   "
					+ " left  join imovel.faturamentoTipo faturamentoTipo "
					+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
					+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ " left  join imovel.eloAnormalidade eloAnormalidade   "
					+ " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
					+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
					+ " left  join imovel.consumoTarifa consumoTarifa   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
					+ " left join imovel.medicaoHistoricos medicaoHistorico   "
					+ " left join imovel.clienteImoveis clienteImoveis "
					+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
					+ " left join clienteImoveis.cliente cliente "
					+ " left join cliente.clienteTipo clienteTipo "
					// +
					// " left join imovel.clienteImoveis clienteImoveisUsuario "
					+

					" left outer join imovel.clienteImoveis clienteImoveisUsuario with (clienteImoveisUsuario.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ ") and clienteImoveisUsuario.dataFimRelacao is null "
					+ " left outer join clienteImoveisUsuario.cliente clienteUsuario "
					+

					" left outer join imovel.clienteImoveis clienteImoveisReposanvel with (clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ ") and clienteImoveisReposanvel.dataFimRelacao is null "
					+ " left outer join clienteImoveisReposanvel.cliente clienteResposanvel ";

			// intervalo Media Minima Imovel Inicial e Final
			if ((intervaloMediaMinimaImovelInicial != null
					&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloMediaMinimaImovelFinal != null
							&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " left join imovel.consumosHistoricos consumosHistorico ";
			}

			consulta = consulta
					+ montarCondicaoWhereFiltrarImovelOutrosCriterio(
							idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
							consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto,
							intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal,
							intervaloMediaMinimaImovelInicial,
							intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal,
							idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
							idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal,
							idCadastroOcorrencia, idConsumoTarifa,
							idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial,
							setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro,
							municipio, idTipoMedicao, indicadorMedicao,
							idSubCategoria, idCategoria,
							quantidadeEconomiasInicial,
							quantidadeEconomiasFinal, diaVencimento, idCliente,
							idClienteTipo, idClienteRelacaoTipo,
							numeroPontosInicial, numeroPontosFinal,
							numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa, indicadorCpfCnpj, cpfCnpj);

			/*
			 * # COLOCANDO O VALOR NAS CONDIÇÕES#
			 */

			/*
			 * consulta = consulta +
			 * " consumosHistorico.referenciaFaturamento = " + "(select
			 * max(consumoHistorico.referenciaFaturamento) from ConsumoHistorico
			 * consumoHistorico " + " left join consumoHistorico.imovel
			 * imovelConsumoHistorico " + "where imovelConsumoHistorico.id =
			 * imovel.id) and ";
			 */

			if (ordenacao != null
					&& !ordenacao.trim().equals("")
					&& !ordenacao.trim().equals(
							"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				if (ordenacao.trim().equals("rota")) {
					consulta = consulta
							+ " order by gerenciaRegional.id, localidade.id, setorComercial.codigo, rota.codigo, imovel.numeroSequencialRota";
				}
			} else {
				consulta = consulta
						+ " order by col_0_0_, col_2_0_, col_19_0_ desc";
			}

			Query query = session.createQuery(consulta);

			informarDadosQueryFiltrarImovelOutrosCriterio(query,
					idImovelCondominio, idImovelPrincipal, idNomeConta,
					idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
					consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
					consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
					intervaloValorPercentualEsgotoInicial,
					intervaloValorPercentualEsgotoFinal,
					intervaloMediaMinimaImovelInicial,
					intervaloMediaMinimaImovelFinal,
					intervaloMediaMinimaHidrometroInicial,
					intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
					idPocoTipo, idFaturamentoSituacaoTipo,
					idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
					idEloAnormalidade, areaConstruidaInicial,
					areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa,
					idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal,
					setorComercialInicial, setorComercialFinal, quadraInicial,
					quadraFinal, loteOrigem, loteDestno, cep, logradouro,
					bairro, municipio, idTipoMedicao, indicadorMedicao,
					idSubCategoria, idCategoria, quantidadeEconomiasInicial,
					quantidadeEconomiasFinal, diaVencimento, idCliente,
					idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial,
					numeroPontosFinal, numeroMoradoresInicial,
					numeroMoradoresFinal, idAreaConstruidaFaixa,
					indicadorCpfCnpj, cpfCnpj);

			/*
			 * if(qtdImoveis != null && !qtdImoveis.equals("")){ Integer
			 * qtdImoveisInformada = new Integer (qtdImoveis) * 2; retorno =
			 * query.setMaxResults(qtdImoveisInformada).list(); }else
			 * if(qtdMaiores != null && !qtdMaiores.equals("")){ Integer
			 * qtdMaioresInformada = new Integer (qtdMaiores) * 2; retorno =
			 * query.setMaxResults(qtdMaioresInformada).list(); }else{
			 */
			retorno = query.setFirstResult(quantidadeImovelInicio)
					.setMaxResults(500).list();
			// }

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Gerar Relação de Débitos
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/2006
	 * 
	 */
	public Integer obterQuantidadaeRelacaoImoveisDebitos(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(distinct imovel.id) "
					+ " from ImovelSubcategoria imovelSubcategoria, ImovelCobrancaSituacao imovelCobrancaSituacao "
					+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
					+ " left  join  imovelSubcategoria.comp_id.subcategoria subcategoria "
					+ " left join subcategoria.categoria categoria   "
					+ " inner join imovel.localidade localidade   "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " inner join imovel.setorComercial setorComercial   "
					+ " left  join imovel.logradouroBairro logradouroBairro  "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " left  join bairro.municipio municipio   "
					+ " left  join imovel.logradouroBairro logradouroBairro "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " inner join imovel.quadra quadra   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.cep cep   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.logradouro logradouro   "
					+ " left  join imovel.imovelCondominio imovelCondominio   "
					+ " left  join imovel.imovelPrincipal imovelPrincipal   "
					// + " left join imovel.nomeConta nomeConta "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua  "
					+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  "
					+ " left  join imovel.imovelPerfil imovelPerfil  "
					+ " left  join imovel.pocoTipo pocoTipo   "
					+ " left  join imovel.faturamentoTipo faturamentoTipo "
					+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
					+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ " left  join imovel.eloAnormalidade eloAnormalidade   "
					+ " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
					+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
					+ " left  join imovel.consumoTarifa consumoTarifa   "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left join imovel.consumosHistoricos consumosHistorico   "
					+ " left join imovel.medicaoHistoricos medicaoHistorico   "
					+ " left join imovel.clienteImoveis clienteImoveis "
					+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
					+ " left join clienteImoveis.cliente cliente "
					+ " left join cliente.clienteTipo clienteTipo "
					+ " left join imovel.consumosHistoricos consumosHistorico ";

			consulta = consulta
					+ montarCondicaoWhereFiltrarImovelOutrosCriterioContarQuantidade(
							idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
							consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto,
							intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal,
							intervaloMediaMinimaImovelInicial,
							intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal,
							idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
							idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal,
							idCadastroOcorrencia, idConsumoTarifa,
							idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial,
							setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro,
							municipio, idTipoMedicao, indicadorMedicao,
							idSubCategoria, idCategoria,
							quantidadeEconomiasInicial,
							quantidadeEconomiasFinal, diaVencimento, idCliente,
							idClienteTipo, idClienteRelacaoTipo,
							numeroPontosInicial, numeroPontosFinal,
							numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa);

			/*
			 * # COLOCANDO O VALOR NAS CONDIÇÕES#
			 */

			Query query = session.createQuery(consulta);

			informarDadosQueryFiltrarImovelOutrosCriterio(query,
					idImovelCondominio, idImovelPrincipal, idNomeConta,
					idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
					consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
					consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
					intervaloValorPercentualEsgotoInicial,
					intervaloValorPercentualEsgotoFinal,
					intervaloMediaMinimaImovelInicial,
					intervaloMediaMinimaImovelFinal,
					intervaloMediaMinimaHidrometroInicial,
					intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
					idPocoTipo, idFaturamentoSituacaoTipo,
					idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
					idEloAnormalidade, areaConstruidaInicial,
					areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa,
					idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal,
					setorComercialInicial, setorComercialFinal, quadraInicial,
					quadraFinal, loteOrigem, loteDestno, cep, logradouro,
					bairro, municipio, idTipoMedicao, indicadorMedicao,
					idSubCategoria, idCategoria, quantidadeEconomiasInicial,
					quantidadeEconomiasFinal, diaVencimento, idCliente,
					idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial,
					numeroPontosFinal, numeroMoradoresInicial,
					numeroMoradoresFinal, idAreaConstruidaFaixa, null, null);

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Monta a condição do where
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @param cpfCnpj
	 * @param indicadorCpfCnpj
	 * @date 12/06/2006
	 * 
	 */
	public String montarCondicaoWhereFiltrarImovelOutrosCriterio(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa,
			String indicadorCpfCnpj, String cpfCnpj) {

		String consulta = "";
		/*
		 * ## CONDIÇÕES ##
		 */
		consulta = consulta + " where 1=1 ";

		// cliente
		if (idCliente != null
				&& !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and cliente.id = :idCliente  ";
		}

		// cliente tipo
		if (idClienteTipo != null
				&& !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and clienteTipo.id = :idClienteTipo ";
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null
				&& !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and clienteRelacaoTipo.id = :idClienteRelacaoTipo ";
		}

		if (indicadorCpfCnpj != null && indicadorCpfCnpj.equals("2")) {
			consulta = consulta
					+ " and cliente.cpf is null and cliente.cnpj is null ";

		} else if (indicadorCpfCnpj != null && indicadorCpfCnpj.equals("1")) {
			consulta = consulta
					+ " and cliente.cpf is not null or cliente.cnpj is not null ";
		}

		if (cpfCnpj != null && !cpfCnpj.equals("")) {
			consulta = consulta
					+ " and (cliente.cpf = :cpfCnpj or cliente.cnpj = :cpfCnpj) ";

			if (idClienteRelacaoTipo != null
					&& idClienteRelacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and clienteRelacaoTipo.id = "
						+ ClienteRelacaoTipo.USUARIO + " ";
			}

		}

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and gerenciaRegional.id = :idGerenciaRegional ";
		}
		// localidade inicial e final
		if ((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))) {
			consulta = consulta
					+ " and localidade.id >= :idLocalidadeInicial and localidade.id <= :idLocalidadeFinal ";
		}
		// setor comercial inicial e final
		if ((setorComercialInicial != null
				&& !setorComercialInicial.equals("") && !setorComercialInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))) {
			consulta = consulta
					+ " and setorComercial.codigo >= :setorComercialInicial and setorComercial.codigo <= :setorComercialFinal ";
		}
		// quadra
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and quadra.numeroQuadra >= :quadraInicial and quadra.numeroQuadra <= :quadraFinal ";
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovel.lote >= :loteOrigem  and  imovel.lote <= :loteDestino ";
		}

		// cep
		if (cep != null
				&& !cep.equals("")
				&& !cep.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and cep.codigo = :cep  ";
		}
		// logradouro
		if (logradouro != null
				&& !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and logradouro.id = :logradouro  ";
		}
		// bairro
		if (bairro != null
				&& !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and bairro.codigo = :bairro  ";
		}
		// municipio
		if (municipio != null
				&& !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and municipio.id = :municipio  ";
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null
				&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalAgua != null
						&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and ligacaoAgua.numeroConsumoMinimoAgua >= :consumoMinimoInicialAgua and ligacaoAgua.numeroConsumoMinimoAgua <= :consumoMinimoFinalAgua  ";
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null
				&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalEsgoto != null
						&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and ligacaoEsgoto.consumoMinimo >= :consumoMinimoInicialEsgoto and ligacaoEsgoto.consumoMinimo <= :consumoMinimoFinalEsgoto ";
		}

		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null
				&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloValorPercentualEsgotoFinal != null
						&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {

			consulta = consulta
					+ " and ligacaoEsgoto.percentual >= :intervaloValorPercentualEsgotoInicial and ligacaoEsgoto.percentual <= :intervaloValorPercentualEsgotoFinal  ";
		}
		// indicador medição
		if (indicadorMedicao != null && indicadorMedicao.equals("comMedicao")) {
			// tipo medicao
			if (idTipoMedicao != null
					&& idTipoMedicao
							.equals(MedicaoTipo.LIGACAO_AGUA.toString())) {
				consulta = consulta
						+ " and hidrometroInstalacaoHistorico.id is not null ";
			} else if (idTipoMedicao != null
					&& idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
				consulta = consulta
						+ " and hidrometroInstalacaoHistoricoImovel.id is not null ";
			} else {
				consulta = consulta
						+ " and (hidrometroInstalacaoHistorico.id is not null or ";
				consulta = consulta
						+ "hidrometroInstalacaoHistoricoImovel.id is not null)  ";
			}
		} else if (indicadorMedicao != null
				&& indicadorMedicao.equals("semMedicao")) {
			consulta = consulta
					+ " and (hidrometroInstalacaoHistorico.id is null and ";
			consulta = consulta
					+ "hidrometroInstalacaoHistoricoImovel.id is null) ";
		}
		// imovel condominio
		if (idImovelCondominio != null
				&& !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and imovelCondominio.id = :idImovelCondominio  ";
		}
		// imovel principal
		if (idImovelPrincipal != null
				&& !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and imovelPrincipal.id = :idImovelPrincipal  ";
		}
		// nome conta

		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }

		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }

		// situação da ligação de agua
		if (idSituacaoLigacaoAgua != null
				&& !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and ligacaoAguaSituacao.id = :idSituacaoLigacaoAgua  ";
		}
		// situação ligação de esgoto
		if (idSituacaoLigacaoEsgoto != null
				&& !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and ligacaoEsgotoSituacao.id = :idSituacaoLigacaoEsgoto  ";
		}
		// imovel Perfil
		if (idImovelPerfil != null
				&& !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and imovelPerfil.id = :idImovelPerfil  ";
		}
		// poço tipo
		if (idPocoTipo != null
				&& !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and pocoTipo.id = :idPocoTipo ";
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null
				&& !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and faturamentoTipo.id = idFaturamentoSituacaoTipo ";
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null
				&& !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					// +
					// " and cobrancaSituacaoTipo.id = :idCobrancaSituacaoTipo ";
					+ " and imovelCobrancaSituacao.imovel.id = imovel.id and imovelCobrancaSituacao.cobrancaSituacao.id = :idCobrancaSituacaoTipo "
					+ " and imovelCobrancaSituacao.anoMesReferenciaFinal is null ";
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null
				&& !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and faturamentoSituacaoTipo.id = :idSituacaoEspecialCobranca ";
		}

		// elo anormalidade
		if (idEloAnormalidade != null
				&& !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and eloAnormalidade.id = :idEloAnormalidade ";
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null
				&& !idCadastroOcorrencia.equals("")
				&& !idCadastroOcorrencia.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and cadastroOcorrencia.id = :idCadastroOcorrencia ";
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (areaConstruidaFinal != null
						&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovel.areaConstruida >= :areaConstruidaInicial and imovel.areaConstruida <= :areaConstruidaFinal  ";
		}
		// consumo tarifa
		if (idConsumoTarifa != null
				&& !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and consumoTarifa.id = :idConsumoTarifa ";
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null
				&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaImovelFinal != null
						&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and consumosHistorico.consumoMedio >= :intervaloMediaMinimaImovelInicial and consumosHistorico.consumoMedio <= :intervaloMediaMinimaImovelFinal ";
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null
				&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null
						&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and medicaoHistorico.consumoMedioHidrometro >= :intervaloMediaMinimaHidrometroInicial and medicaoHistorico.consumoMedioHidrometro <= :intervaloMediaMinimaHidrometroFinal  ";
		}
		// categoria
		if (idCategoria != null
				&& !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and categoria.id = :idCategoria  ";
		}
		// sub categoria
		if (idSubCategoria != null
				&& !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and subCategoria.id = :idSubCategoria  ";
		}
		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null
				&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quantidadeEconomiasFinal != null
						&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovelSubcategoria.quantidadeEconomias >= :quantidadeEconomiasInicial and imovelSubcategoria.quantidadeEconomias <= :quantidadeEconomiasFinal ";
		}

		// dia Vencimento
		if (diaVencimento != null
				&& !diaVencimento.equals("")
				&& !diaVencimento.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			if (diaVencimento.equals("1")) {// sim
				consulta = consulta
						+ " and imovel.diaVencimento  is not null  ";
			}
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imove.numeroPontosUtilizacao >= :numeroPontosInicial and imovel.numeroPontosUtilizacao <= :numeroPontosFinal ";
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null
				&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroMoradoresFinal != null
						&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovel.numeroMorador >= :numeroMoradoresInicial and imovel.numeroMorador <= :numeroMoradoresFinal ";
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null
				&& !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and areaConstruidaFaixa.id = :idAreaConstruidaFaixa ";
		}

		return consulta;
	}

	/**
	 * 
	 * Seta os valores na condição do where
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @param cpfCnpj
	 * @param indicadorCpfCnpj
	 * @date 12/06/2006
	 * 
	 */
	public void informarDadosQueryFiltrarImovelOutrosCriterio(Query query,
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa,
			String indicadorCpfCnpj, String cpfCnpj) {

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idGerenciaRegional", new Integer(
					idGerenciaRegional).intValue());
		}
		// localidade inicial e final
		if ((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))) {
			query.setInteger("idLocalidadeInicial", new Integer(
					idLocalidadeInicial).intValue());
			query.setInteger("idLocalidadeFinal",
					new Integer(idLocalidadeFinal).intValue());
		}
		// setor comercial inicial e final
		if ((setorComercialInicial != null
				&& !setorComercialInicial.equals("") && !setorComercialInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))) {
			query.setInteger("setorComercialInicial", new Integer(
					setorComercialInicial).intValue());
			query.setInteger("setorComercialFinal", new Integer(
					setorComercialFinal).intValue());
		}
		// quadra inicial e final
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("quadraInicial",
					new Integer(quadraInicial).intValue());
			query.setInteger("quadraFinal", new Integer(quadraFinal).intValue());
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("loteOrigem", new Integer(loteOrigem).intValue());
			query.setInteger("loteDestino", new Integer(loteDestno).intValue());
		}
		// cep
		if (cep != null
				&& !cep.equals("")
				&& !cep.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("cep", new Integer(cep).intValue());
		}
		// logradouro
		if (logradouro != null
				&& !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("logradouro", new Integer(logradouro).intValue());
		}
		// bairro
		if (bairro != null
				&& !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("bairro", new Integer(bairro).intValue());
		}
		// municipio
		if (municipio != null
				&& !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("municipio", new Integer(municipio).intValue());
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null
				&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalAgua != null
						&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("consumoMinimoInicialAgua", new Integer(
					consumoMinimoInicialAgua).intValue());
			query.setInteger("consumoMinimoFinalAgua", new Integer(
					consumoMinimoFinalAgua).intValue());
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null
				&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalEsgoto != null
						&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("consumoMinimoInicialEsgoto", new Integer(
					consumoMinimoInicialEsgoto).intValue());
			query.setInteger("consumoMinimoFinalEsgoto", new Integer(
					consumoMinimoFinalEsgoto).intValue());
		}
		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null
				&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloValorPercentualEsgotoFinal != null
						&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloValorPercentualEsgotoInicial",
					new BigDecimal(intervaloValorPercentualEsgotoInicial)
							.intValue());
			query.setInteger("intervaloValorPercentualEsgotoFinal",
					new BigDecimal(intervaloValorPercentualEsgotoFinal)
							.intValue());
		}
		// imovel condominio
		if (idImovelCondominio != null
				&& !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelCondominio", new Integer(
					idImovelCondominio).intValue());
		}
		// imovel principal
		if (idImovelPrincipal != null
				&& !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelPrincipal",
					new Integer(idImovelPrincipal).intValue());
		}

		// nome conta
		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// query
		// .setInteger("idNomeConta", new Integer(idNomeConta)
		// .intValue());
		// }
		// Situacao Ligacao Agua
		if (idSituacaoLigacaoAgua != null
				&& !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoLigacaoAgua", new Integer(
					idSituacaoLigacaoAgua).intValue());
		}

		// situação ligação de esgoto
		if (idSituacaoLigacaoEsgoto != null
				&& !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoLigacaoEsgoto", new Integer(
					idSituacaoLigacaoEsgoto).intValue());
		}
		// imovel Perfil
		if (idImovelPerfil != null
				&& !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelPerfil",
					new Integer(idImovelPerfil).intValue());
		}
		// poço tipo
		if (idPocoTipo != null
				&& !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idPocoTipo", new Integer(idPocoTipo).intValue());
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null
				&& !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idFaturamentoSituacaoTipo", new Integer(
					idFaturamentoSituacaoTipo).intValue());
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null
				&& !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCobrancaSituacaoTipo", new Integer(
					idCobrancaSituacaoTipo).intValue());
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null
				&& !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoEspecialCobranca", new Integer(
					idSituacaoEspecialCobranca).intValue());
		}
		// elo anormalidade
		if (idEloAnormalidade != null
				&& !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idEloAnormalidade",
					new Integer(idEloAnormalidade).intValue());
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null
				&& !idCadastroOcorrencia.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCadastroOcorrencia", new Integer(
					idCadastroOcorrencia).intValue());
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (areaConstruidaFinal != null
						&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setBigDecimal("areaConstruidaInicial",
					Util.formatarMoedaRealparaBigDecimal(areaConstruidaInicial));
			query.setBigDecimal("areaConstruidaFinal",
					Util.formatarMoedaRealparaBigDecimal(areaConstruidaFinal));
		}
		// consumo tarifa
		if (idConsumoTarifa != null
				&& !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idConsumoTarifa",
					new Integer(idConsumoTarifa).intValue());
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null
				&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaImovelFinal != null
						&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloMediaMinimaImovelInicial", new Integer(
					intervaloMediaMinimaImovelInicial).intValue());
			query.setInteger("intervaloMediaMinimaImovelFinal", new Integer(
					intervaloMediaMinimaImovelFinal).intValue());
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null
				&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null
						&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloMediaMinimaHidrometroInicial",
					new Integer(intervaloMediaMinimaHidrometroInicial)
							.intValue());
			query.setInteger("intervaloMediaMinimaHidrometroFinal",
					new Integer(intervaloMediaMinimaHidrometroFinal).intValue());
		}

		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null
				&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quantidadeEconomiasFinal != null
						&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("quantidadeEconomiasInicial", new Short(
					quantidadeEconomiasInicial).shortValue());
			query.setShort("quantidadeEconomiasFinal", new Short(
					quantidadeEconomiasFinal).shortValue());
		}

		// categoria
		if (idCategoria != null
				&& !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCategoria", new Integer(idCategoria).intValue());
		}

		// sub categoria
		if (idSubCategoria != null
				&& !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSubCategoria",
					new Integer(idSubCategoria).intValue());
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("numeroPontosInicial",
					new Short(numeroPontosInicial).shortValue());
			query.setShort("numeroPontosFinal",
					new Short(numeroPontosFinal).shortValue());
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null
				&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroMoradoresFinal != null
						&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("numeroMoradoresInicial", new Short(
					numeroMoradoresInicial).shortValue());
			query.setShort("numeroMoradoresFinal", new Short(
					numeroMoradoresFinal).shortValue());
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null
				&& !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idAreaConstruidaFaixa", new Integer(
					idAreaConstruidaFaixa).intValue());
		}

		// cliente
		if (idCliente != null
				&& !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCliente", new Integer(idCliente).intValue());
		}

		// cliente tipo
		if (idClienteTipo != null
				&& !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idClienteTipo",
					new Integer(idClienteTipo).intValue());
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null
				&& !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idClienteRelacaoTipo", new Integer(
					idClienteRelacaoTipo).intValue());
		}

		if (cpfCnpj != null && !cpfCnpj.equals("")) {
			query.setString("cpfCnpj", cpfCnpj);
		}
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Raphael Rossiter
	 * @data 26/05/2006
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitir(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.empresa empr "
					+ "LEFT JOIN fetch cbdo.localidade loca "
					+ "LEFT JOIN fetch cbdo.imovel imov "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro "
					+ "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun "
					+ "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep "
					+ "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo "
					+ "LEFT JOIN fetch log.logradouroTitulo "
					+ "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia "
					+ "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo "
					+ "LEFT JOIN fetch cbdo.imovelPerfil "
					+ "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional "
					+ "LEFT JOIN fetch imov.ligacaoAgua.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN fetch hih.hidrometro "
					+ "LEFT JOIN fetch hih.hidrometroLocalInstalacao "
					+ "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}

			consulta = consulta
					+ " AND cbdo.emissao >= :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ "imov.lote, imov.subLote, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(
					session.createQuery(consulta)
							.setInteger("idCorteAdministrativoOUFisico",
									idCobrancaAcao)
							.setTimestamp("dataEmissao", dataEmissao)
							.setFirstResult(quantidadeCobrancaDocumentoInicio)
							.setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Rafael Corrêa
	 * @data 02/09/2009
	 * 
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaRelatorio(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento cbdo "
					+ "INNER JOIN FETCH cbdo.imovel imov "
					+ "INNER JOIN FETCH imov.quadra qdra "
					+ "INNER JOIN FETCH imov.localidade loca "
					+ "INNER JOIN FETCH loca.localidade locaElo "
					+ "INNER JOIN FETCH qdra.rota rota "
					+ "INNER JOIN FETCH rota.cobrancaGrupo "
					+ "INNER JOIN FETCH rota.faturamentoGrupo "
					+ "INNER JOIN FETCH cbdo.ligacaoAguaSituacao "
					+ "INNER JOIN FETCH cbdo.ligacaoEsgotoSituacao "
					+ "INNER JOIN FETCH cbdo.cobrancaAcao "
					+ " LEFT JOIN FETCH imov.ligacaoAgua ligacaoAgua "
					+ " LEFT JOIN FETCH ligacaoAgua.hidrometroInstalacaoHistorico hidrHistorico "
					+ " LEFT JOIN FETCH hidrHistorico.hidrometro hidrometro "
					+ "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			} else if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}

			// RM 930 - Todos os relatórios de campo da CAERN são classificados
			// por localidade, setor e rota
			String empresa = RepositorioUtilHBM.getInstancia()
					.pesquisarParametrosDoSistema().getNomeAbreviadoEmpresa();

			if (empresa.equals("CAERN")) {
				consulta = consulta
						+ " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, rota.codigo, "
						+ "imov.numeroSequencialRota, cbdo.id";
			} else {
				consulta = consulta
						+ " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
						+ "imov.lote, imov.subLote, cbdo.id";
			}

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), rota (ROTA_ID), sequencial da rota
	 * (IMOV_NNSEQUENCIALROTA)e cobranca documento (CBDO_ID)
	 * 
	 * @author Raphael Rossiter
	 * @data 27/06/2007
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitirPorRota(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.empresa empr "
					+ "LEFT JOIN fetch cbdo.localidade loca "
					+ "LEFT JOIN fetch cbdo.imovel imov "
					+ "LEFT JOIN fetch imov.perimetroInicial periInicial "
					+ "LEFT JOIN fetch periInicial.logradouroTipo "
					+ "LEFT JOIN fetch periInicial.logradouroTitulo "
					+ "LEFT JOIN fetch imov.perimetroFinal periFinal "
					+ "LEFT JOIN fetch periFinal.logradouroTipo "
					+ "LEFT JOIN fetch periFinal.logradouroTitulo "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro "
					+ "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun "
					+ "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep "
					+ "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo "
					+ "LEFT JOIN fetch log.logradouroTitulo "
					+ "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia "
					+ "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo "
					+ "LEFT JOIN fetch cbdo.imovelPerfil "
					+ "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional " + "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, rot.codigo, "
					+ "imov.numeroSequencialRota, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(
					session.createQuery(consulta)
							.setInteger("idCorteAdministrativoOUFisico",
									idCobrancaAcao)
							.setTimestamp("dataEmissao", dataEmissao)
							.setFirstResult(quantidadeCobrancaDocumentoInicio)
							.setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a conta e
	 * ordenar por ano/mês de referência da conta
	 * 
	 * @author Raphael Rossiter
	 * @data 26/05/2006
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteConta(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.contaGeral cntaGeral "
					+ "LEFT JOIN fetch cntaGeral.conta  cnta "
					+ "LEFT JOIN fetch cnta.debitoCreditoSituacaoAtual "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "cnta.id IS NOT NULL ORDER BY cdit.contaGeral.conta.referencia";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] Emitir Aviso de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a guia
	 * pagamento
	 * 
	 * @author Sávio Luiz
	 * @data 09/04/2007
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<Object[]> selecionarDadosCobrancaDocumentoItemReferenteGuiaPagamento(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit.valorItemCobrado,cdit.valorAcrescimos "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN cdit.guiaPagamentoGeral guia "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "guia.id IS NOT NULL ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o count do resultado da pesquisa de Cobranca Cronograma
	 * 
	 * pesquisarCobrancaCronogramaCount
	 * 
	 * @author Flávio Cordeiro
	 * @date 14/06/2006
	 * 
	 * @return Integer retorno
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarCobrancaCronogramaCount(Filtro filtro)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		// String consulta = null;

		try {
			filtro.limparCamposOrderBy();
			// filtro.adicionarCaminhoParaCarregamentoEntidade("cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes");
			retorno = (Integer) GeradorHQLCondicional
					.gerarCondicionalQuery(
							filtro,
							"objeto",
							"select count(distinct objeto.cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id) "
									+ "	from gcom.cobranca.CobrancaAcaoAtividadeCronograma objeto ",
							session).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void removerCobrancaCronograma(Integer idGrupoCronogramaMes)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String remover = null;
		try {
			remover = "delete CobrancaAcaoAtividadeCronograma objeto"
					+ "	where objeto.cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id ="
					+ idGrupoCronogramaMes;

			session.createQuery(remover).executeUpdate();

			remover = "delete CobrancaAcaoCronograma objeto "
					+ "	where objeto.cobrancaGrupoCronogramaMes.id = "
					+ idGrupoCronogramaMes;

			session.createQuery(remover).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * Consultar Relação de Debitos do Imovel Consulta o Consumo Medio do Imovel
	 * 
	 * [UC0227] - Gerar Relção de Débitos
	 * 
	 * @author Rafael Santos
	 * @date 15/06/2006
	 * 
	 * @param imovelId
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarConsumoMedioConsumoHistoricoImovel(Integer imovelId)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select consumoHistorico.consumoMedio "
					+ "from ConsumoHistorico consumoHistorico "
					+ "inner join consumoHistorico.imovel imovel "
					+ "inner join consumoHistorico.ligacaoTipo   ligacaoTipo "
					+ "where imovel.id = :imovelId "
					+ "and ligacaoTipo.id = :ligacaoTipo and consumoHistorico.referenciaFaturamento = ( "
					+ "select max(consumoHistorico2.referenciaFaturamento) "
					+ "from ConsumoHistorico consumoHistorico2 "
					+ "inner join consumoHistorico2.imovel imovel2 "
					+ "inner join consumoHistorico2.ligacaoTipo ligacaoTipo2 "
					+ "where imovel2.id = :imovelId and ligacaoTipo2.id = :ligacaoTipo) ";

			Object resultado = session
					.createQuery(consulta)
					.setInteger("imovelId", imovelId.intValue())
					.setInteger("ligacaoTipo",
							LigacaoTipo.LIGACAO_AGUA.intValue()).uniqueResult();

			if (resultado != null) {
				retorno = (Integer) resultado;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Monta a condição do where
	 * 
	 * [UC0227] Gerar Relação de Débitos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/2006
	 * 
	 */
	public String montarCondicaoWhereFiltrarImovelOutrosCriterioContarQuantidade(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa) {

		String consulta = "";
		consulta = consulta
				+ montarCondicaoWhereFiltrarImovelOutrosCriterio(
						idImovelCondominio, idImovelPrincipal, idNomeConta,
						idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
						consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
						consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
						intervaloValorPercentualEsgotoInicial,
						intervaloValorPercentualEsgotoFinal,
						intervaloMediaMinimaImovelInicial,
						intervaloMediaMinimaImovelFinal,
						intervaloMediaMinimaHidrometroInicial,
						intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
						idPocoTipo, idFaturamentoSituacaoTipo,
						idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
						idEloAnormalidade, areaConstruidaInicial,
						areaConstruidaFinal, idCadastroOcorrencia,
						idConsumoTarifa, idGerenciaRegional,
						idLocalidadeInicial, idLocalidadeFinal,
						setorComercialInicial, setorComercialFinal,
						quadraInicial, quadraFinal, loteOrigem, loteDestno,
						cep, logradouro, bairro, municipio, idTipoMedicao,
						indicadorMedicao, idSubCategoria, idCategoria,
						quantidadeEconomiasInicial, quantidadeEconomiasFinal,
						diaVencimento, idCliente, idClienteTipo,
						idClienteRelacaoTipo, numeroPontosInicial,
						numeroPontosFinal, numeroMoradoresInicial,
						numeroMoradoresFinal, idAreaConstruidaFaixa, null, null);

		consulta = consulta.substring(0, consulta.length() - 5);

		consulta = consulta + " ";

		return consulta;
	}

	/**
	 * Gerar Relatório de Critério de Cobrança
	 * 
	 * Pesquisa as linhas de critério de cobrança através do id do critério de
	 * cobrança
	 * 
	 * @author Rafael Corrêa
	 * @data 09/08/2006
	 */
	public Collection pesquisarCobrancaCriterioLinha(Integer idCriterioCobranca)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT " + "imovelPerfil.descricao, "
					+ "categoria.descricao, " + "ccl.valorMinimoDebito, "
					+ "ccl.valorMaximoDebito, "
					+ "ccl.quantidadeMinimaContas, "
					+ "ccl.quantidadeMaximaContas, "
					+ "ccl.valorMinimoContaMes, "
					+ "ccl.valorMinimoDebitoDebitoAutomatico, "
					+ "ccl.quantidadeMinimaContasDebitoAutomatico "
					+ "FROM CobrancaCriterioLinha as ccl "
					+ "inner join ccl.imovelPerfil imovelPerfil "
					+ "inner join ccl.categoria categoria "
					+ "WHERE ccl.cobrancaCriterio.id = :idCriterioCobranca "
					+ "order by imovelPerfil.id, categoria.id";

			retorno = session.createQuery(consulta)
					.setInteger("idCriterioCobranca", idCriterioCobranca)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Perfil de Parcelamento
	 * 
	 * Pesquisa os Parcelamentos Desconto Antiguidade através do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @data 22/08/2006
	 */
	public Collection pesquisarParcelamentoDescontoAntiguidade(
			Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT antiguidade.id, "
					+ "antiguidade.quantidadeMinimaMesesDebito, "
					+ "antiguidade.percentualDescontoSemRestabelecimento, "
					+ "antiguidade.percentualDescontoComRestabelecimento, "
					+ "antiguidade.percentualDescontoAtivo "
					+ "FROM ParcelamentoDescontoAntiguidade as antiguidade "
					+ "INNER JOIN antiguidade.parcelamentoPerfil perfil "
					+ "WHERE perfil.id = :idParcelamentoPerfil "
					+ "ORDER BY antiguidade.quantidadeMinimaMesesDebito";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamentoPerfil", idParcelamentoPerfil)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Perfil de Parcelamento
	 * 
	 * Pesquisa os Parcelamentos Desconto Inatividade através do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @data 22/08/2006
	 */
	public Collection pesquisarParcelamentoDescontoInatividade(
			Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT inatividade.id, "
					+ "inatividade.quantidadeMaximaMesesInatividade, "
					+ "inatividade.percentualDescontoSemRestabelecimento, "
					+ "inatividade.percentualDescontoComRestabelecimento "
					+ "FROM ParcelamentoDescontoInatividade as inatividade "
					+ "INNER JOIN inatividade.parcelamentoPerfil perfil "
					+ "WHERE perfil.id = :idParcelamentoPerfil "
					+ " ORDER BY inatividade.quantidadeMaximaMesesInatividade";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamentoPerfil", idParcelamentoPerfil)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Perfil de Parcelamento
	 * 
	 * Pesquisa os Reparcelamentos Consecutivos através do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @data 22/08/2006
	 */
	public Collection pesquisarReparcelamentoConsecutivo(
			Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT reparcelamento.id, "
					+ "reparcelamento.quantidadeMaximaReparcelamento, "
					+ "prestacao.id, prestacao.quantidadeMaximaPrestacao, "
					+ "prestacao.taxaJuros, prestacao.percentualMinimoEntrada "
					+ "FROM ParcelamentoQuantidadePrestacao as prestacao "
					+ "INNER JOIN prestacao.parcelamentoQuantidadeReparcelamento reparcelamento "
					+ "INNER JOIN reparcelamento.parcelamentoPerfil perfil "
					+ "WHERE perfil.id = :idParcelamentoPerfil "
					+ "ORDER BY reparcelamento.quantidadeMaximaReparcelamento, "
					+ "prestacao.quantidadeMaximaPrestacao";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamentoPerfil", idParcelamentoPerfil)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite iniciar processos batch de faturamento ou
	 * cobrança previdamento comandados e processos mensais ou eventuais
	 * 
	 * [UC0001] - Iniciar Processo
	 * 
	 * Este subfluxo inicia os processo batch de cobrança do sistema
	 * 
	 * [SB0002] - Iniciar Process de Cobrança Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarCobrancaAcaoAtividadeCronogramaComandadosNaoRealizados()
			throws ErroRepositorioException {

		Collection<CobrancaAcaoAtividadeCronograma> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "FROM CobrancaAcaoAtividadeCronograma as cob "
					+ " left join fetch cob.cobrancaAcaoCronograma cobAcaoCron "
					+ " left join fetch cobAcaoCron.cobrancaGrupoCronogramaMes cobGrupoCronoMes"
					+ " left join fetch cobAcaoCron.cobrancaAcao cobAcao"
					+ " left join fetch cob.cobrancaAtividade cobAtiv"
					+ " left join fetch cobGrupoCronoMes.cobrancaGrupo cobGrup"
					+ " WHERE cob.comando is not null and (cobAtiv.id = :cobrancaAtividadeEmitir or cobAtiv.id = :cobrancaAtividadeSimular or cobAtiv.id = :cobrancaAtividadeEncerrarOS) and (cob.realizacao is null and cob.dataPrevista <=  :dataAtual) "
					+ " order by cobGrupoCronoMes.anoMesReferencia, cobGrupoCronoMes.cobrancaGrupo.descricao, cobAcao.ordemRealizacao"; // or
			// cob.realizacao
			// <
			// cob.comando
			// cobAtiv.id = :cobrancaAtividade and
			// 'A
			// pedido
			// de
			// Ana
			// Breda'

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("cobrancaAtividadeEmitir",
							CobrancaAtividade.EMITIR)
					.setInteger("cobrancaAtividadeSimular",
							CobrancaAtividade.SIMULAR)
					.setInteger("cobrancaAtividadeEncerrarOS",
							CobrancaAtividade.ENCERRAR_OS)
					.setTimestamp("dataAtual", new Date()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite iniciar processos batch de faturamento ou
	 * cobrança previdamento comandados e processos mensais ou eventuais
	 * 
	 * [UC0001] - Iniciar Processo
	 * 
	 * Este subfluxo inicia os processo batch de cobrança do sistema
	 * 
	 * [SB0002] - Iniciar Process de Cobrança Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeComando> pesquisarCobrancaAcaoAtividadeCronogramaEventuaisComandadosNaoRealizados()
			throws ErroRepositorioException {

		Collection<CobrancaAcaoAtividadeComando> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "FROM CobrancaAcaoAtividadeComando as cob "
					+ "left join fetch cob.cobrancaAtividade cobAtiv "

					+ "left join fetch cob.cobrancaAcao cobAcao "
					+ "left join fetch cob.usuario "
					+ "WHERE cob.comando is not null and (cobAtiv.id = :cobrancaAtividadeEmitir or cobAtiv.id = :cobrancaAtividadeSimular or cobAtiv.id = :cobrancaAtividadeEncerrarOS) and (cob.realizacao is null ) "
					+ " ORDER BY cob.comando";
			// + " order by cob.anoMesReferenciaContaInicial,
			// cob.cobrancaGrupo.descricao, cobAcao.ordemRealizacao"; // or;*/
			// //
			// or
			// cob.realizacao
			// <
			// cob.comando

			retorno = session
					.createQuery(consulta)
					.setInteger("cobrancaAtividadeEmitir",
							CobrancaAtividade.EMITIR)
					.setInteger("cobrancaAtividadeSimular",
							CobrancaAtividade.SIMULAR)
					.setInteger("cobrancaAtividadeEncerrarOS",
							CobrancaAtividade.ENCERRAR_OS).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0476] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Ana Maria
	 * @data 07/09/2006
	 * 
	 * @param Collection
	 *            <CobrancaDocumento>
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<EmitirDocumentoCobrancaHelper> pesquisarCobrancaDocumentoOrdemCorte(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new "
					+ EmitirDocumentoCobrancaHelper.class.getName()
					+ " (cbdo.id, loca.id, loca.descricao, "
					+ " cbdo.codigoSetorComercial,cbdo.numeroQuadra,"
					+ " imov.lote, imov.subLote,"
					+ " imov.id, cbac.numeroDiasValidade,"
					+ " orse.id,"
					+ " iper.descricao, cbdo.emissao,"
					+ " rota.cobrancaGrupo.id, cbdo.valorDocumento,"
					+ " empr.id, empr.descricao,"
					+ " greg.nomeAbreviado, greg.nome,"
					+ " last.id, lest.id,"
					+ " greg.id, imov.ultimaAlteracao,"
					+ " last.descricao, lest.descricao,"
					+ " ltan.id, ltan.descricao, cbdo.dataEmissaoPredecessor,"
					+ " cbdo.numeroSequenciaDocumento, cbac.numeroDiasVencimento,"
					+ " rota.codigo, imov.numeroSequencialRota)"
					+ " from OrdemServico orse "
					+ " left join orse.cobrancaDocumento as cbdo "
					+ " left join cbdo.empresa as empr"
					+ " left join cbdo.localidade as loca"
					+ " left join cbdo.imovel as imov"
					+ " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest"
					+ " left join imov.leituraAnormalidade ltan"
					+ " left join cbdo.cobrancaAcao as cbac"
					+ " left join cbdo.imovelPerfil as iper"
					+ " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota"
					+ " left join loca.gerenciaRegional greg" + " where ";
			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					// + " AND cbdo.emissao = :dataEmissao "
					+ " AND cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ " order by empr.id,greg.id ,loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ " imov.lote, imov.subLote,cbdo.id";

			retorno = session.createQuery(consulta)
					.setInteger("idAvisoCorte", idCobrancaAcao)
					// .setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio)
					.setMaxResults(1000).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0476] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), rota (ROTA_ID), sequencial da rota
	 * (IMOV_NNSEQUENCIALROTA)e cobranca documento (CBDO_ID)
	 * 
	 * @author Raphael Rossiter
	 * @data 07/08/2007
	 * 
	 * @return Collection<EmitirDocumentoCobrancaHelper>
	 */
	public Collection<EmitirDocumentoCobrancaHelper> pesquisarCobrancaDocumentoOrdemCortePorRota(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new "
					+ EmitirDocumentoCobrancaHelper.class.getName()
					+ " (cbdo.id, loca.id, loca.descricao, "
					+ " cbdo.codigoSetorComercial,cbdo.numeroQuadra,"
					+ " imov.lote, imov.subLote,"
					+ " imov.id, cbac.numeroDiasValidade,"
					+ " orse.id,"
					+ " iper.descricao, cbdo.emissao,"
					+ " rota.cobrancaGrupo.id, cbdo.valorDocumento,"
					+ " empr.id, empr.descricao,"
					+ " greg.nomeAbreviado, greg.nome,"
					+ " last.id, lest.id,"
					+ " greg.id, imov.ultimaAlteracao,"
					+ " last.descricao, lest.descricao,"
					+ " ltan.id, ltan.descricao, rota.codigo, imov.numeroSequencialRota)"
					+ " from OrdemServico orse "
					+ " left join orse.cobrancaDocumento as cbdo "
					+ " left join cbdo.empresa as empr"
					+ " left join cbdo.localidade as loca"
					+ " left join cbdo.imovel as imov"
					+ " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest"
					+ " left join imov.leituraAnormalidade ltan"
					+ " left join cbdo.cobrancaAcao as cbac"
					+ " left join cbdo.imovelPerfil as iper"
					+ " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota"
					+ " left join loca.gerenciaRegional greg" + " where ";
			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ "cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, rota.codigo, "
					+ "imov.numeroSequencialRota, cbdo.id";

			retorno = session.createQuery(consulta)
					.setInteger("idAvisoCorte", idCobrancaAcao)
					.setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio)
					.setMaxResults(1000).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0582] Emitir Boletim de Cadastro
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Rafael Corrêa
	 * @data 16/05/2007
	 * 
	 * @param Collection
	 *            <CobrancaDocumento>
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<EmitirDocumentoCobrancaBoletimCadastroHelper> pesquisarCobrancaDocumentoBoletimCadastro(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new "
					+ EmitirDocumentoCobrancaBoletimCadastroHelper.class
							.getName()
					+ " (cbdo.id, loca.id, " // 0, 1
					+ " cbdo.codigoSetorComercial, cbdo.numeroQuadra," // 2, 3
					+ " imov.lote, imov.subLote," // 4, 5
					+ " imov.id, rota.cobrancaGrupo.id, " // 6, 7
					+ " last.id, lest.id," // 8, 9
					+ " imov.numeroMorador, imov.areaConstruida, logr.id, " // 10,11,12
					+ " cep.codigo, bairro.codigo, imov.enderecoReferencia.id, imov.numeroImovel, " // 13,14
																									// ,15,16
					+ " imov.complementoEndereco, imov.reservatorioVolumeFaixaInferior.id, " // 17,18
					+ " imov.reservatorioVolumeFaixaSuperior.id, imov.piscinaVolumeFaixa.id, " // 19,20
					+ " imov.indicadorJardim, imov.pavimentoRua.id, imov.pavimentoCalcada.id, " // 21,22,23
					+ " imov.numeroPontosUtilizacao, imov.imovelPerfil.id, imov.despejo.id, " // 24,25,26
					+ " imov.pocoTipo.id, imov.fonteAbastecimento.id, imov.numeroIptu, imov.numeroCelpe,"// 27,28,29,30
					+ " rota.codigo,imov.numeroSequencialRota)" // 31,32
					+ " from OrdemServico orse "
					+ " inner join orse.cobrancaDocumento as cbdo "
					+ " inner join cbdo.localidade as loca"
					+ " inner join cbdo.imovel as imov"
					+ " inner join imov.quadra qdrImovel "
					+ " inner join qdrImovel.rota rota "
					+ " inner join rota.empresaCobranca empreCobranca "
					+ " inner join cbdo.imovelPerfil as iper"
					+ " inner join loca.gerenciaRegional greg"
					+ " left join cbdo.empresa as empr"
					+ " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest"
					+ " left join imov.leituraAnormalidade ltan"
					+ " left join imov.logradouroCep as logrCep"
					+ " left join logrCep.logradouro as logr"
					+ " left join logrCep.cep as cep"
					+ " left join imov.logradouroBairro as logrBairro"
					+ " left join logrBairro.bairro as bairro"
					+ " left join cbdo.cobrancaAcao as cbac"
					+ " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota" + " where ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {

				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma
						+ " AND empreCobranca.indicadorEmpresaPrincipal <> "
						+ Empresa.INDICADOR_EMPRESA_PRINCIPAL + " AND ";
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta
						+ " cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando + " AND ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ " order by empr.id,greg.id ,loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ " imov.lote, imov.subLote,cbdo.id";

			retorno = session.createQuery(consulta)
					.setInteger("idAvisoCorte", idCobrancaAcao)
					.setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio)
					.setMaxResults(500).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta os
	 * documentos de cobrança do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarImovelDocumentosCobranca(Integer idImovel,
			Integer numeroPagina) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT distinct cobrancaAcao.descricaoCobrancaAcao, "
					+ // 0
					"cobrancaDocumento.emissao, "
					+ // 1
					"documentoEmissaoForma.descricaoDocumentoEmissaoForma, "
					+ // 2
					"documentoTipo.descricaoDocumentoTipo, "
					+ // 3
					"cobrancaDocumento.valorDocumento, "
					+ // 4
					"cobrancaDocumento.id, "
					+ // 5
					"cobrancaDocumento.usuario.nomeUsuario, "
					+ // 6
					"cobrancaDocumento.indicadorClienteImovel, "
					+ // 7
					"documentoTipo.id, "
					+ // 8
					"documentoEmissaoForma.id, "
					+ // 9
					"cobAcao.descricaoCobrancaAcao, "
					+ // 10
					"acaoCobranca.descricaoCobrancaAcao "
					+ // 11
					"FROM CobrancaDocumento as cobrancaDocumento "
					+ "left JOIN cobrancaDocumento.cobrancaAcao cobrancaAcao "
					+ "left JOIN cobrancaDocumento.documentoEmissaoForma documentoEmissaoForma "
					+ "left JOIN cobrancaDocumento.documentoTipo documentoTipo "
					+ "left JOIN cobrancaDocumento.usuario usuario "
					+ "left JOIN cobrancaDocumento.cobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando "
					+ "left JOIN cobrancaAcaoAtividadeComando.cobrancaAcao cobAcao "
					+ "left JOIN cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobrancaAcaoAtividadeCronograma "
					+ "left JOIN cobrancaAcaoAtividadeCronograma.cobrancaAcaoCronograma cobrancaAcaoCronograma "
					+ "left JOIN cobrancaAcaoCronograma.cobrancaAcao acaoCobranca "
					+ "where cobrancaDocumento.imovel.id = :idImovel ";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta a
	 * quantidade de documentos de cobrança do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQuantidadeImovelDocumentosCobranca(Integer idImovel)
			throws ErroRepositorioException {
		Integer retorno = null;
		Object resultadoConsulta = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT count(distinct cobrancaDocumento.id) "
					+ // 0
					"FROM CobrancaDocumento as cobrancaDocumento "
					+ "where cobrancaDocumento.imovel.id = :idImovel and cobrancaDocumento.imovel.indicadorExclusao != 1 ";

			resultadoConsulta = session.createQuery(consulta)
					.setInteger("idImovel", idImovel.intValue()).uniqueResult();

			if (resultadoConsulta != null) {
				retorno = (Integer) resultadoConsulta;
			} else {
				retorno = new Integer(0);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta a
	 * quantidade de documentos de itens de cobrança do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQuantidadeImovelDocumentosItemCobranca(
			Integer idCobrancaDocumento) throws ErroRepositorioException {
		Integer retorno = null;
		Object resultadoConsulta = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT count(distinct cobrancaDocumentoItem.id) "
					+ // 0
					"FROM CobrancaDocumentoItem as cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.cobrancaDocumento.id = :idCobrancaDocumento";

			resultadoConsulta = session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							idCobrancaDocumento.intValue()).uniqueResult();

			if (resultadoConsulta != null) {
				retorno = (Integer) resultadoConsulta;
			} else {
				retorno = new Integer(0);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados do parcelamento necessários para o relatório através do
	 * id do parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @date 25/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentoRelatorio(Integer idParcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select imov.id, "
					+ // 0
					"imov.logradouroBairro.bairro.municipio.nome, "
					+ // 1
					"parc.parcelamento,"
					+ // 2
					" parc.valorConta, "
					+ // 3
					"parc.valorServicosACobrar, "
					+ // 4
					"parc.valorAtualizacaoMonetaria, "
					+ // 5
					"parc.valorJurosMora, "
					+ // 6
					"parc.valorMulta, "
					+ // 7
					"parc.valorGuiaPapagamento, "
					+ // 8
					"parc.valorParcelamentosACobrar, "
					+ // 9
					"parc.valorDescontoAcrescimos, "
					+ // 10
					"parc.valorDescontoAntiguidade, "
					+ // 11
					"parc.valorDescontoInatividade, "
					+ // 12
					"parc.valorCreditoARealizar, "
					+ // 13
					"parc.valorDebitoAtualizado, "
					+ // 14
					"parc.valorEntrada, "
					+ // 15
					"parc.numeroPrestacoes, "
					+ // 16
					"parc.valorPrestacao, "
					+ // 17
					"parc.indicadorRestabelecimento, "
					+ // 18
					"parc.funcionario.id, "
					+ // 19
					"clie.nome, "
					+ // 20
					"clie.cpf, "
					+ // 21
					"clie.cnpj, "
					+ // 22
					"parc.taxaJuros, "
					+ // 23
					"parc.valorDescontoSancao, "
					+ // 24
					"parc.valorDescontoTarifaSocial, "
					+ // 25
					"func.id, "
					+ // 26
					"cliDir.nome, "
					+ // 27
					"cliDir.cpf, "
					+ // 28
					"prof.descricao, "
					+ // 29
					"ct.indicadorPessoaFisicaJuridica, "
					+ // 30
					"devedor.nome, "
					+ // 31
					"devedor.cnpj, "
					+ // 32
					"devedor.id, "
					+ // 33
					"usur.nomeUsuario, "
					+ // 34
					"parc.anoMesReferenciaFaturamento, "
					+ // 35
					"imov.logradouroBairro.bairro.nome, "
					+ // 36
					"imov.quadra.rota.codigo, "
					+ // 37
					"localidade.descricao, "
					+ // 38
					"setor.codigo, "
					+ // 39
					"parc.valorDescontoDebitoTotal, "
					+ // 40
					"parc.valorDescontoTipoDebito, "
					+ // 41
					"parc.valorDescontoMulta, "
					+ // 42
					"parc.valorDescontoJuros, "
					+ // 43
					"parc.valorDescontoAtualizacaoMonetaria, "
					+ // 44
					"clie.id, "
					+ // 45
					"cf.indicadorGuiaCarneParcelamento " // 46
					+ "from Parcelamento parc "
					+ "inner join parc.cobrancaForma cf "
					+ "left join parc.cliente clie "
					+ "left join clie.profissao prof "
					+ "left join parc.usuario usur "
					+ "left join usur.funcionario func "
					+ "inner join parc.imovel imov "
					+ "inner join imov.localidade localidade "
					+ "inner join imov.setorComercial setor "
					+ "left join imov.clienteImoveis ci with ( ci.clienteRelacaoTipo.id = 2 and ci.dataFimRelacao is null ) "
					+ "left join ci.cliente devedor " + "left join ci.cliente "
					+ "left join devedor.clienteTipo ct,"
					+ "SistemaParametro sp "
					+ "left join sp.clienteDiretorComercialCompesa cliDir "
					+ "where parc.id = :idParcelamento";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento.intValue())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa os itens do parcelamento necessários para o relatório através do
	 * id do parcelamento
	 * 
	 * @author Rafael Corrêa
	 * @date 25/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentoItemPorIdParcelamentoRelatorio(
			Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "select "
					+
					// 0
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.referencia"
					+ " else"
					+ "   ch.anoMesReferenciaConta"
					+ " end,"
					+
					// 1
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorAgua"
					+ " else"
					+ "   ch.valorAgua"
					+ " end,"
					+
					// 2
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorEsgoto"
					+ " else"
					+ "   ch.valorEsgoto"
					+ " end,"
					+
					// 3
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorCreditos"
					+ " else"
					+ "   ch.valorCreditos"
					+ " end,"
					+
					// 4
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.debitos"
					+ " else"
					+ "   ch.valorDebitos"
					+ " end,"
					+ "gpag.id, " // 5
					+ "dtgpag.descricao, gpag.valorDebito, " // 6,7
					+ "dtdbac.id, dtdbac.descricao, " // 8,9
					+ "dbac.numeroPrestacaoDebito, dbac.numeroPrestacaoCobradas, " // 10,11
					+ "dbac.valorDebito, ctcrar.id, " // 12,13
					+ "ctcrar.descricao, crar.numeroPrestacaoCredito, " // 14,15
					+ "crar.numeroPrestacaoRealizada, crar.valorCredito, " // 16,17
					+ "dbac.numeroParcelaBonus , crar.numeroParcelaBonus " // 18,19
					+ "from ParcelamentoItem parcItem "
					+ "inner join parcItem.parcelamento parc "
					+ "left join parcItem.contaGeral cg "
					+ "left join cg.contaHistorico ch "
					+ "left join cg.conta conta "
					+ "left join parcItem.guiaPagamentoGeral gpg "
					+ "left join gpg.guiaPagamento gpag "
					+ "left join gpag.debitoTipo dtgpag "
					+ "left join parcItem.debitoACobrarGeral dacg "
					+ "left join dacg.debitoACobrar dbac "
					+ "left join dbac.debitoTipo dtdbac "
					+ "left join parcItem.creditoARealizarGeral carg "
					+ "left join carg.creditoARealizar crar "
					+ "left join crar.creditoTipo ctcrar "
					+ "where parc.id = :idParcelamento "
					+ "group by cg.indicadorHistorico, conta.referencia, conta.valorAgua, "
					+ "conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, gpag.id, "
					+ "ch.anoMesReferenciaConta, ch.valorAgua, "
					+ "ch.valorEsgoto, ch.valorDebitos, "
					+ "ch.valorCreditos, "
					+ "dtgpag.descricao, gpag.valorDebito, "
					+ "dtdbac.id, dtdbac.descricao, "
					+ "dbac.numeroPrestacaoDebito, dbac.numeroPrestacaoCobradas, "
					+ "dbac.valorDebito, ctcrar.id, "
					+ "ctcrar.descricao, crar.numeroPrestacaoCredito, "
					+ "crar.numeroPrestacaoRealizada, crar.valorCredito, "
					+ "dbac.numeroParcelaBonus , crar.numeroParcelaBonus "
					+ "order by conta.referencia, dtdbac.id, gpag.id, "
					+ " ctcrar.id";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento.intValue())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Obtem os percentuais de desconto por tempo de inatividade
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 2/10/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoDescontoInatividade obterPercentualDescontoInatividade(
			Integer idPerfilParc, int qtdeMeses)
			throws ErroRepositorioException {

		ParcelamentoDescontoInatividade retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pdin "
					+ "FROM ParcelamentoDescontoInatividade pdin "
					+ "WHERE pdin.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND pdin.quantidadeMaximaMesesInatividade IN ("
					+ "SELECT max(p.quantidadeMaximaMesesInatividade)"
					+ "FROM ParcelamentoDescontoInatividade p "
					+ "WHERE p.quantidadeMaximaMesesInatividade <= :qtdeMeses)";

			retorno = (ParcelamentoDescontoInatividade) session
					.createQuery(consulta)
					.setInteger("idPerfilParc", idPerfilParc.intValue())
					.setInteger("qtdeMeses", qtdeMeses).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consultar Serviços/Atualizações do documento de cobraça
	 * 
	 * 
	 * [UC0349] - Emitir Documento de cobrança - Ordem de Fiscalização
	 * 
	 * @author Ana Maria
	 * @date 18/10/2006
	 * 
	 * @param idDocumentoCobranca
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarServioAtualizacao(Integer idDocumentoCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try {
			consulta = " select sum(cdit.valorItemCobrado) "
					+ " from CobrancaDocumentoItem cdit "
					+ " inner join cdit.cobrancaDocumento cbdo "
					+ " left join cdit.guiaPagamentoGeral.guiaPagamento gpag "
					+ " left join cdit.debitoACobrarGeral.debitoACobrar dbac "
					+ " where cbdo.id = :idDocumentoCobranca and (gpag.id is not null or dbac.id is not null) ";

			Object resultado = session
					.createQuery(consulta)
					.setInteger("idDocumentoCobranca",
							idDocumentoCobranca.intValue()).uniqueResult();

			if (resultado != null) {
				retorno = (BigDecimal) resultado;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @created 23/10/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void associarContaParcelamento(Conta conta)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			// Atualiza PARC_ID da tabela CONTA com o id do parcelamento
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "parc_id = :idParcelamento,"
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE cnta_id = :idConta ";

			session.createQuery(update)
					.setInteger("idParcelamento",
							conta.getParcelamento().getId())
					.setTimestamp("dataUltimaAlteracao",
							conta.getUltimaAlteracao())
					.setInteger("idConta", conta.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna os CBCM_ID da tabela COBRANCA_GRUPO_CRONOGRAMA_MES
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaGrupoCronogramaMes()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaGrupoCronogramaMes.id,cobrancaGrupoCronogramaMes.anoMesReferencia,cobrancaGrupoCronogramaMes.cobrancaGrupo.id from CobrancaGrupoCronogramaMes cobrancaGrupoCronogramaMes"
					// +
					// " where cobrancaGrupoCronogramaMes.cobrancaGrupo.id in (31) "
					+ " where cobrancaGrupoCronogramaMes.anoMesReferencia >= 200710 ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna os CBCR_ID da tabela COBRANCA_ACAO_CRONOGRAMA com CBCM_ID da
	 * tabela COBRANCA_GRUPO_CRONOGRAMA_MES
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaAcaoCronograma(
			int idCobrancaGrupoCronogramaMes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAcaoCronograma.id,cobrancaAcaoCronograma.cobrancaAcao.id from CobrancaAcaoCronograma cobrancaAcaoCronograma "
					+ "where cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id = :idCobrancaGrupoCronogramaMes";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaGrupoCronogramaMes",
							idCobrancaGrupoCronogramaMes).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna CAAC_TMREALIZACAO do COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDataRelizacaoCobrancaAtividadeAcaoConograma(
			int idCobrancaAcaoCronograma, int idCobrancaAtividade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAtividadeAcaoCronograma.id, "
					+ "cobrancaAtividadeAcaoCronograma.realizacao, "
					+ "cobrancaAtividadeAcaoCronograma.dataPrevista,"
					+ "cobrancaAtividadeAcaoCronograma.comando from CobrancaAcaoAtividadeCronograma cobrancaAtividadeAcaoCronograma "
					+ "where cobrancaAtividadeAcaoCronograma.cobrancaAcaoCronograma.id = :idCobrancaAcaoCronograma and "
					+ "cobrancaAtividadeAcaoCronograma.cobrancaAtividade.id = :idCobrancaAtividade ";
			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma)
					.setInteger("idCobrancaAtividade", idCobrancaAtividade)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Retorna os DOTP_ID da tabela COBRANCA_ACAO com CBAC_ID de
	 * COBRANCA_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaAcao(int idCobrancaAcao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAcao.documentoTipo.id,cobrancaAcao.servicoTipo.id,"
					+ "cobrancaAcao.indicadorDebitoInterfereAcao from CobrancaAcao cobrancaAcao "
					+ "where cobrancaAcao.id = :idCobrancaAcao";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaAcao", idCobrancaAcao).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos Cobrança
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,28/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<DadosPesquisaCobrancaDocumentoHelper> pesquisarCobrancaDocumento(
			int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id,"
					+ "cobrancaDocumento.emissao, "
					+ "cobrancaDocumento.imovel.id, "
					+ "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobCrit.percentualQuantidadeMinimoPagoParceladoCancelado, "
					+ "cobCrit.valorLimitePrioridade)  "
					+ "from CobrancaDocumento cobrancaDocumento "
					+ "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "where cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id = :idCobrancaAtividadeAcaoCronograma "
					+ "order by cobrancaDocumento.id";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAtividadeAcaoCronograma",
							idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0002] - Determinar Situação da Ação de Cobrança
	 * 
	 * Retorna os ORSE_ID da tabela ORDEM_SERVICO com CBDO_ID da tabela
	 * COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos,Sávio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 04/06/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarOrdemServico(int idDocumentoCobranca)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		// int valorIdCronogramaOuComando = -1;
		// String campoCronogramaOuComando = "";
		//
		// if (idCobrancaAtividadeAcaoCronogramaEmitir !=
		// ConstantesSistema.NUMERO_NAO_INFORMADO){
		// campoCronogramaOuComando = "caac_id";
		// valorIdCronogramaOuComando = idCobrancaAtividadeAcaoCronogramaEmitir;
		// } else {
		// campoCronogramaOuComando = "cacm_id";
		// valorIdCronogramaOuComando = idCobrancaAtividadeAcaoComandoEmitir;
		// }

		try {

			consulta = "select orse.orse_id as idOS,"
					+ " orse.orse_cdsituacao as codigoOS,"
					+ " orse.orse_dtfiscalizacaosituacao as dataFiscalizacao,"
					+ " orse.orse_tmencerramento as dataEncerramento,"
					+ " cob.cbdo_id as idCobDocumento,"
					+ " cob.cbdo_vldocumento as valorDocumento,"
					+ " cob.cbct_id as idCriterioCobranca, "
					+ " orse.fzst_id as idFiscalizacaoSit,"
					+ " atMotEnc.amen_icexecucao as indicadorExecucao,"
					+ " imov.imov_id as idImovel,"
					+ " imov.loca_id as idLocalidade, "
					+ " cob.cast_id as idSituacaoAcao, "
					+ " cob.cbdo_dtsituacaoacao as dataSituacaoAcao "
					+ ", atMotEnc.amen_id as idMotivoEncerramento, "
					+ " cob.cbdo_tmemissao as dataEmissao "
					+ "from atendimentopublico.ordem_servico orse "
					+ "inner join cobranca.cobranca_documento cob on cob.cbdo_id = orse.cbdo_id "
					+ "left join cadastro.imovel imov "
					+ "      on imov.imov_id = orse.imov_id "
					+ "left join  atendimentopublico.atend_motivo_encmt atMotEnc "
					+ "      on atMotEnc.amen_id = orse.amen_id "
					+ " where cob.cbdo_id = :idDocumento ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("codigoOS", Hibernate.SHORT)
					.addScalar("dataFiscalizacao", Hibernate.DATE)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("idCobDocumento", Hibernate.INTEGER)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("idCriterioCobranca", Hibernate.INTEGER)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indicadorExecucao", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSituacaoAcao", Hibernate.INTEGER)
					.addScalar("dataSituacaoAcao", Hibernate.DATE)
					.addScalar("idMotivoEncerramento", Hibernate.INTEGER)
					.addScalar("dataEmissao", Hibernate.DATE)
					.setInteger("idDocumento", idDocumentoCobranca).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0007] - Determinar Situação da Ordem de Serviço
	 * 
	 * Retorna os AMEN_ICEXECUCAO da tabela ATENDIMENTO_MOTIVO_ENCERRAMENTO com
	 * AMEN_ID da tabela ORDEM_SERVIÇO
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAtendimentoMotivoEncerramento(
			int idAtendimentoMotivoEncerramento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select atendimentoMotivoEncerramento.indicadorExecucao from AtendimentoMotivoEncerramento atendimentoMotivoEncerramento "
					+ "where atendimentoMotivoEncerramento.id = :idAtendimentoMotivoEncerramento";

			retorno = session
					.createQuery(consulta)
					.setInteger("idAtendimentoMotivoEncerramento",
							idAtendimentoMotivoEncerramento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os CNTA_ID,GPAG_ID,DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM com
	 * CBDO_ID da tabela COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(int idCobrancaDocumento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaDocumentoItem.contaGeral.id, "
					+ "cobrancaDocumentoItem.guiaPagamentoGeral.id, "
					+ "cobrancaDocumentoItem.debitoACobrarGeral.id, "
					+ "cobrancaDocumentoItem.id,"
					+ "cobrancaDocumentoItem.valorItemCobrado "
					+ "from CobrancaDocumentoItem cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.cobrancaDocumento.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os CNTG_ID da tabela COBRANCA_GERAL com CNTA_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaGeral(int idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select contaGeral.id "
					+ "from ContaGeral contaGeral "
					+ "where contaGeral.conta.id = :idConta and contaGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setInteger("valorIndicador", 1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,CNHI_DTCANCELAMENTO da tabela CONTA_HISTORICO com
	 * CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaHistorico(int idContaHistorico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select contaHistorico.debitoCreditoSituacaoAtual.id,"
					+ "contaHistorico.dataCancelamento "
					+ "from ContaHistorico contaHistorico "
					+ "where contaHistorico.id = :idContaHistorico";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idContaHistorico", idContaHistorico)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,CNTA_DTCANCELAMENTO da tabela CONTA com CNTA_ID
	 * da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,01/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarConta(int idConta) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select conta.debitoCreditoSituacaoAtual.id,"
					+ "conta.dataCancelamento " + "from Conta conta "
					+ "where conta.id = :idConta";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com CNTA_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoConta(int idConta,
			int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento "
					+ " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.contaGeral.id = :idConta and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			// consulta = "select tabelaParcelamento.parcelamento "
			// + "from Parcelamento tabelaParcelamento "
			// + " inner join tabelaParcelamento."
			// + "where tabelaParcelamento.id =(select
			// parcelamentoItem.parcelamento.id from ParcelamentoItem "
			// + "parcelamentoItem where parcelamentoItem.contaGeral.id =
			// :idConta) and "
			// + "tabelaParcelamento.parcelamentoSituacao =
			// :idParcelamentoSituacao ";

			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setInteger("idParcelamentoSituacao",
							idParcelamentoSituacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os GPGE_ID da tabela GUIA_PAGAMENTO_GERAL com GPAG_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoGeral(int idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamentoGeral.id "
					+ "from GuiaPagamentoGeral guiaPagamentoGeral "
					+ "where guiaPagamentoGeral.guiaPagamento.id = :idGuiaPagamento and guiaPagamentoGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setInteger("valorIndicador", 1).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,GPGE_DTCANCELAMENTO da tabela
	 * GUIA_PAGAMENTO_HISTORICO com GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarGuiaPagamentoHistorico(int idGuiaPagamentoHistorico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamentoHistorico.debitoCreditoSituacaoByDcstIdatual.id,"
					+ "guiaPagamentoHistorico.ultimaAlteracao "
					+ "from GuiaPagamentoHistorico guiaPagamentoHistorico "
					+ "where guiaPagamentoHistorico.id = :idGuiaPagamentoHistorico";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("idGuiaPagamentoHistorico",
							idGuiaPagamentoHistorico).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,GPAG_DTCANCELAMENTO da tabela GUIA_PAGAMENTO com
	 * GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarGuiaPagamento(int idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamento.debitoCreditoSituacaoAtual.id,"
					+ "guiaPagamento.ultimaAlteracao "
					+ "from GuiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :idGuiaPagamento";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com GPAG_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,29/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoGuiaPagamento(int idGuiaPagamento,
			int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento "
					+ " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.guiaPagamentoGeral.id = :idGuiaPagamento and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setInteger("idParcelamentoSituacao",
							idParcelamentoSituacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DAGE_ID da tabela DEBITO_A_COBRAR_GERAL com DBAC_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarGeral(int idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrarGeral.id "
					+ "from DebitoACobrarGeral debitoACobrarGeral "
					+ "where debitoACobrarGeral.id = :idDebitoACobrar "
					+ "and debitoACobrarGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setInteger("valorIndicador", ConstantesSistema.SIM).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,DAGE_DTCANCELAMENTO da tabela
	 * DEBITO_A_COBRAR_HISTORICO com DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrarHistorico(int idDebitoACobrarHistorico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrarHistorico.debitoCreditoSituacaoAtual.id,"
					+ "debitoACobrarHistorico.ultimaAlteracao "
					+ "from DebitoACobrarHistorico debitoACobrarHistorico "
					+ "where debitoACobrarHistorico.id = :idDebitoACobrarHistorico";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("idDebitoACobrarHistorico",
							idDebitoACobrarHistorico).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os DCST_IDATUAL,GPAG_DTCANCELAMENTO da tabela DEBITO_A_COBRAR com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrar(int idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrar.debitoCreditoSituacaoAtual.id,"
					+ "debitoACobrar.ultimaAlteracao "
					+ "from DebitoACobrar debitoACobrar "
					+ "where debitoACobrar.id = :idDebitoACobrar";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com DBAC_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,Sávio Luiz
	 * @date 17/10/2006,29/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoDebitoACobrar(int idDebitoACobrar,
			int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento "
					+ " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.creditoARealizarGeral.id = :idDebitoACobrar and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			// consulta = "select tabelaParcelamento.parcelamento "
			// + "from Parcelamento tabelaParcelamento "
			// + "where tabelaParcelamento.id =(select
			// parcelamentoItem.parcelamento.id from ParcelamentoItem
			// parcelamentoItem "
			// + "where parcelamentoItem.debitoACobrar.id = :idDebitoACobrar)
			// and "
			// + "tabelaParcelamento.parcelamentoSituacao =
			// :idParcelamentoSituacao ";

			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setInteger("idParcelamentoSituacao",
							idParcelamentoSituacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosContaHistorico(int idContaHistorico)
			throws ErroRepositorioException {

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) "
					+ "from PagamentoHistorico pagamentoHistorico "
					+ "inner join pagamentoHistorico.contaGeral contaGeral "
					+ "inner join contaGeral.contaHistorico contaHistorico "
					+ "where contaHistorico.id = :idContaHistorico";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idContaHistorico", idContaHistorico)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO com CNTA_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosConta(int idConta)
			throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) "
					+ "from Pagamento pagamento "
					+ "where pagamento.contaGeral.id = :idConta";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idConta", idConta).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosGuiaPagamentoHistorico(
			int idGuiaPagamentoHistorico) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) "
					+ "from PagamentoHistorico pagamentoHistorico "
					+ "where pagamentoHistorico.guiaPagamento.id = :idGuiaPagamentoHistorico";

			Object retornoObj = session
					.createQuery(consulta)
					.setInteger("idGuiaPagamentoHistorico",
							idGuiaPagamentoHistorico).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO com GPAG_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosGuiaPagamento(int idGuiaPagamento)
			throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) "
					+ "from Pagamento pagamento "
					+ "where pagamento.guiaPagamento.id = :idGuiaPagamento";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosDebitoACobrarHistorico(
			int idDebitoACobrarHistorico) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) "
					+ "from PagamentoHistorico pagamentoHistorico "
					+ "where pagamentoHistorico.debitoACobrarGeral.id = :idDebitoACobrarHistorico";

			Object retornoObj = session
					.createQuery(consulta)
					.setInteger("idDebitoACobrarHistorico",
							idDebitoACobrarHistorico).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0003] - Determinar Situação do Débito do Item do Documento de Cobrança
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosDebitoACobrar(int idDebitoACobrar)
			throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) "
					+ "from Pagamento pagamento "
					+ "where pagamento.debitoACobrar.id = :idDebitoACobrar";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0005] - Determinar Situação Predominante do Débito do Documento de
	 * Cobrança
	 * 
	 * Retorna o CBCT_PCVLMINIMOPGPARCCANC, CBCBT_PCQTMINIMOPGPARCCANC da tabela
	 * COBRANCA_CRITERIO com CBCT_ID da tabela COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaCriterio(int idCobrancaCriterio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select cobrancaCriterio.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobrancaCriterio.percentualQuantidadeMinimoPagoParceladoCancelado, "
					+ "cobrancaCriterio.valorLimitePrioridade "
					+ "from CobrancaCriterio cobrancaCriterio "
					+ "where cobrancaCriterio.id = :idCobrancaCriterio";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0004] - Atualizar item do documento de cobrança
	 * 
	 * Atualizar os COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaDocumentoItem(
			Collection colecaoCobrancaDocumentoItem)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		// posições do array com os dados que serão atualizados na cobrança
		// documento item
		final byte POSICAO_ID_COBRANCA_DOCUMENTO = 0;
		final byte POSICAO_ID_COBRANCA_DOCUMENTO_ITEM = 1;
		final byte POSICAO_ID_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM = 2;
		final byte POSICAO_DATA_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM = 3;

		try {

			Iterator iteratorColecaoCobrancaDocumentoItem = colecaoCobrancaDocumentoItem
					.iterator();

			while (iteratorColecaoCobrancaDocumentoItem.hasNext()) {

				Object[] cobrancaDocumentoItemParaAtualizar = (Object[]) iteratorColecaoCobrancaDocumentoItem
						.next();

				atualizar = "update gcom.cobranca.CobrancaDocumentoItem "
						+ " set cdst_id = :idSituacaoDebitoItem, cdit_dtsituacaodebito = :dataSituacaoDebito,cdit_tmultimaalteracao = :ultimaAlteracao "
						+ " where cbdo_id = :idCobrancaDocumento and cdit_id = :idCobrancaDocumentoItem ";

				session.createQuery(atualizar)
						.setInteger(
								"idSituacaoDebitoItem",
								(Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM])
						.setDate(
								"dataSituacaoDebito",
								(Date) cobrancaDocumentoItemParaAtualizar[POSICAO_DATA_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM])
						.setInteger(
								"idCobrancaDocumento",
								(Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_COBRANCA_DOCUMENTO])
						.setInteger(
								"idCobrancaDocumentoItem",
								(Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_COBRANCA_DOCUMENTO_ITEM])
						.setTimestamp("ultimaAlteracao", new Date())
						.executeUpdate();
			}
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0004] - Processar Documento de Cobrança
	 * 
	 * Atualizar os COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	// Override - Metodo sobrescrito na classe RepositorioCobrancaPostgresHBM
	public void atualizarCobrancaDocumento(Collection colecaoCobrancaDocumento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Connection con = null;
		Statement stmt = null;

		try {

			con = session.connection();
			stmt = con.createStatement();

			Iterator iteratorColecaoCobrancaDocumento = colecaoCobrancaDocumento
					.iterator();

			int TAM_BLOCO_ATUALIZACAO = 50;
			int i = 0;

			StringBuffer atualizar = new StringBuffer();

			while (iteratorColecaoCobrancaDocumento.hasNext()) {

				DadosPesquisaCobrancaDocumentoHelper cobrancaDocumentoParaAtualizar = (DadosPesquisaCobrancaDocumentoHelper) iteratorColecaoCobrancaDocumento
						.next();

				atualizar.append("update cobranca.cobranca_documento set ");
				if (cobrancaDocumentoParaAtualizar.getIdSituacaoAcao() != null) {
					atualizar.append("cast_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdSituacaoAcao() + ",");
				}
				if (cobrancaDocumentoParaAtualizar.getDataSituacaoAcao() != null) {
					atualizar
							.append(" cbdo_dtsituacaoacao = to_date('"
									+ Util.formatarDataComTracoAAAAMMDD(cobrancaDocumentoParaAtualizar
											.getDataSituacaoAcao())
									+ "','YYYY-MM-DD') , ");
				}
				if (cobrancaDocumentoParaAtualizar.getDataSituacaoDebito() != null) {
					atualizar
							.append(" cbdo_dtsituacaodebito = to_date('"
									+ Util.formatarDataComTracoAAAAMMDD(cobrancaDocumentoParaAtualizar
											.getDataSituacaoDebito())
									+ "','YYYY-MM-DD'), ");
				} else {
					atualizar.append(" cbdo_dtsituacaodebito = null, ");
				}
				if (cobrancaDocumentoParaAtualizar.getIdCategoria() != null) {
					atualizar.append(" catg_id = "
							+ cobrancaDocumentoParaAtualizar.getIdCategoria()
							+ ", ");
				}
				if (cobrancaDocumentoParaAtualizar.getIcAcimaLimite() != null) {
					atualizar.append(" cbdo_icacimalimite = "
							+ cobrancaDocumentoParaAtualizar.getIcAcimaLimite()
							+ ", ");
				}
				if (cobrancaDocumentoParaAtualizar.getIdSituacaoDebito() != null) {
					atualizar.append(" cdst_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdSituacaoDebito() + ", ");
				}
				// else {
				// atualizar.append(" cdst_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdFiscalizacao() != null) {
					atualizar.append(" fzst_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdFiscalizacao() + ", ");
				}
				// else {
				// atualizar.append(" fzst_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdEsferaPoder() != null) {
					atualizar.append(" epod_id = "
							+ cobrancaDocumentoParaAtualizar.getIdEsferaPoder()
							+ ", ");
				}
				// else {
				// atualizar.append(" epod_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIcAntesDepois() != null) {
					atualizar.append(" cbdo_icantesapos = "
							+ cobrancaDocumentoParaAtualizar.getIcAntesDepois()
							+ ", ");
				}
				// else {
				// atualizar.append(" cbdo_icantesapos = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdMotivoEncerramento() != null) {
					atualizar.append(" amen_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdMotivoEncerramento() + ", ");
				}

				atualizar.append(" cbdo_tmultimaalteracao = "
						+ Util.obterSQLDataAtual() + " ");
				atualizar.append(" where cbdo_id = "
						+ cobrancaDocumentoParaAtualizar.getIdDocumento() + "");

				stmt.addBatch(atualizar.toString());
				atualizar = new StringBuffer("");

				if ((i > 0 && i % TAM_BLOCO_ATUALIZACAO == 0)
						|| i == (colecaoCobrancaDocumento.size() - 1)) {
					// System.out.println("SQL: " + atualizar.toString());
					// stmt.executeUpdate(atualizar.toString());
					stmt.executeBatch();
					atualizar = new StringBuffer();
					session.flush();
				}
				i++;

			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
			try {
				if (con != null)
					con.close();
				if (stmt != null)
					stmt.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos de Cobrança
	 * 
	 * Retorna os dados do Imovel
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImovel(int idImovel)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct imovel.ligacaoAguaSituacao.id, "
					+ "imovel.ligacaoEsgotoSituacao.id, "
					+ "imovel.localidade.id, "
					+ "imovel.quadra.id, "
					+ "imovel.quadra.numeroQuadra, "
					+ "imovel.setorComercial.id, "
					+ "imovel.setorComercial.codigo, "
					+ "imovel.localidade.gerenciaRegional.id, "
					+ "imovel.quadra.rota.id,  "
					+ "imovel.imovelPerfil.id, "
					+ "esferaPoder.id "
					+ "from Imovel imovel  "
					+ "left outer join imovel.clienteImoveis clienteImoveisReposanvel with (clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " ) "
					+ "and clienteImoveisReposanvel.dataFimRelacao is null  "
					+ "left outer join clienteImoveisReposanvel.cliente clienteResposanvel "
					+ "left outer join clienteResposanvel.clienteTipo clienteTipo "
					+ "left outer join clienteTipo.esferaPoder esferaPoder "
					+ "where imovel.id = :idImovel";
			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos de Cobrança
	 * 
	 * Retorna os dados do Imovel
	 * 
	 * @author Sávio Luiz
	 * @date 11/06/2007
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosImovelPorOS(int idOrdemServico)
			throws ErroRepositorioException {
		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ordemServ.imovel.id, "
					+ "ordemServ.imovel.localidade.id "
					+ "from OrdemServico ordemServ "
					+ "where ordemServ.id = :idOrdemServico";
			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idOrdemServico", idOrdemServico)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documento de Cobrança
	 * 
	 * Atualizar os COBRANCA_ACAO_ATIVIDADE_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 25/10/2006
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoAtividadeCronograma(
			int idCobrancaAcaoAtividadeCrongrama)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		try {
			atualizar = "update gcom.cobranca.CobrancaAcaoAtividadeCronograma "
					+ " set caac_tmrealizacao = :dataRealizacao,caac_tmultimaalteracao = :dataAtual "
					+ " where caac_id = :idCobrancaAcaoAtividadeCronograma";

			session.createQuery(atualizar)
					.setInteger("idCobrancaAcaoAtividadeCronograma",
							idCobrancaAcaoAtividadeCrongrama)
					.setDate("dataRealizacao", new Date())
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0006] - Processar Ação com Ordens de Serviço
	 * 
	 * Retorna os ORSE_ID da tabela ORDEM_SERVICO com SVTP_ID da tabela
	 * COBRANCA_ACAO e ORSE_TMGERACAO entre CAAC_DTPREVISTA do Emitir e do
	 * Encerrar
	 * 
	 * @author Rafael Santos
	 * @date 25/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarOrdemServicos(int idServicoTipo,
			Date dataPrevistaAtividadeEncerrar,
			Date dataPrevistaAtividadeEmitir, int indice)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select ordemServico.id,"
					+ "ordemServico.situacao,"
					+ "ordemServico.fiscalizacaoSituacao.id,"
					+ "ordemServico.dataFiscalizacaoSituacao,"
					+ "ordemServico.dataEncerramento,"
					+ "atendimentoMotivoEncerramento.id,  "
					+ "imov.id, loc.id from OrdemServico ordemServico "
					+ "inner join ordemServico.atendimentoMotivoEncerramento atendimentoMotivoEncerramento "
					+ "left join ordemServico.imovel imov "
					+ "left join imov.localidade loc "
					+ "where ordemServico.servicoTipo.id = :idServicoTipo and "
					+ " ordemServico.dataGeracao >= :dataPrevistaAtividadeEmitir and"
					+ " ordemServico.dataGeracao <= :dataPrevistaAtividadeEncerrar ";

			retorno = session
					.createQuery(consulta)
					.setInteger("idServicoTipo", idServicoTipo)
					.setDate("dataPrevistaAtividadeEmitir",
							dataPrevistaAtividadeEmitir)
					.setDate("dataPrevistaAtividadeEncerrar",
							dataPrevistaAtividadeEncerrar)
					.setFirstResult(indice).setMaxResults(500).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna o objeto ParcelamentoFaixaValor com o valor do debito(valorFaixa)
	 * com desconto maior q o da faixa e menor que próxima faixa
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 31/10/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoFaixaValor obterParcelamentoFaixaValor(
			Integer idParcelamentoQtdePrestacao, BigDecimal valorFaixa)
			throws ErroRepositorioException {

		ParcelamentoFaixaValor retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pfvl "
					+ "FROM ParcelamentoFaixaValor pfvl "
					+ "WHERE pfvl.parcelamentoQuantidadePrestacao.id = :idParcelamentoQtdePrestacao "
					+ "AND pfvl.valorFaixa IN (" + "SELECT max(p.valorFaixa) "
					+ "FROM ParcelamentoFaixaValor p "
					+ "WHERE p.valorFaixa <= :valorFaixa)";

			retorno = (ParcelamentoFaixaValor) session
					.createQuery(consulta)
					.setInteger("idParcelamentoQtdePrestacao",
							idParcelamentoQtdePrestacao.intValue())
					.setBigDecimal("valorFaixa", valorFaixa).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0178] Processar Pagamentos com código de Barras Auhtor: Sácio Luiz
	 * Data: 06/11/2006
	 * 
	 */
	public void atualizarGuiaPagamento(Collection idsGuiaPagamento,
			Date dataVencimento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarGuiaPagamento;
		try {
			atualizarGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set gpag_dtvencimento = :dataVencimento,gpag_iccobrancamulta = :idCobrancaMulta, "
					+ " gpag_tmultimaalteracao = :dataAtual where gpag_id in (:idsGuiaPagamento)";

			session.createQuery(atualizarGuiaPagamento)
					.setParameterList("idsGuiaPagamento", idsGuiaPagamento)
					.setDate("dataVencimento", dataVencimento)
					.setShort("idCobrancaMulta", ConstantesSistema.SIM)
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			System.out.println("Erro");

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * O sistema exclui o resumo das ações de cobrança correspondente ao
	 * cronograma de ação de cobrança que esta sendo processado
	 * 
	 * @author Rafael Santos
	 * @date 08/11/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void deletarResumoCobrancaAcao(int idCobrancaAcaoCronograma)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "delete ResumoCobrancaAcao resumoCobrancaAcao "
					+ "where resumoCobrancaAcao.cobrancaAcaoCronograma.id = :idCobrancaAcaoCronograma ";

			session.createQuery(consulta)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * retorna uma colecao de ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 08/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaMaiorDataVigenciaInicio()
			throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from ResolucaoDiretoria rd "
					+ "where rd.indicadorUtilizacaoLivre = :indicadorUtilizacaoLivre "
					+ "and (rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual) "
					+ "order by rd.dataVigenciaInicio ";

			retorno = (Collection) session
					.createQuery(consulta)
					.setDate("dataAtual", new Date())
					.setShort("indicadorUtilizacaoLivre", ConstantesSistema.SIM)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtem a condição referente à qtde de reparcelamentos consecutivos já
	 * realizadas para o perfil do parcelamento para o imóvel
	 * 
	 * a partir da tabela PARCELAMENTO_QUANTIDADE_REPARCELAMENTO com
	 * PCPF_ID=PCPF_ID da tabela PARCELAMENTO_PERFIL e
	 * PQTR_QTMAXIMAREPARCELAMENTO igual ou menor que
	 * IMOV_NNREPARCELAMENTOCONSECUTVOS, caso mais de uma ocorrencia seja
	 * selecionada, escolher a que tiver o maior valor de
	 * PQTR_QTMAXIMAREPARCELAMENTO
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 28/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoQuantidadeReparcelamento obterQtdeReparcelamentoPerfil(
			Integer idPerfilParc, Short numeroReparcelamentoConsecutivos)
			throws ErroRepositorioException {

		ParcelamentoQuantidadeReparcelamento retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parcelamentoQtdeReparcel "
					+ "FROM ParcelamentoQuantidadeReparcelamento parcelamentoQtdeReparcel "
					+ "WHERE parcelamentoQtdeReparcel.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND parcelamentoQtdeReparcel.quantidadeMaximaReparcelamento IN ("
					+ "SELECT max(p.quantidadeMaximaReparcelamento)"
					+ "FROM ParcelamentoQuantidadeReparcelamento p "
					+ "WHERE p.quantidadeMaximaReparcelamento <= :numeroReparcelamentoConsecutivos "
					+ "and p.parcelamentoPerfil.id = :idPerfilParc)";

			retorno = (ParcelamentoQuantidadeReparcelamento) session
					.createQuery(consulta)
					.setInteger("idPerfilParc", idPerfilParc.intValue())
					.setShort("numeroReparcelamentoConsecutivos",
							numeroReparcelamentoConsecutivos).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento Débitos Remove ClienteGuiaPagamento
	 * referentes ao parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @created 28/11/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerClienteGuiaPagamentoDoParcelamento(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerClienteGuiaPagamentoDoParcelamento;

		try {
			// remove em credito a realizar os parcelamentos
			removerClienteGuiaPagamentoDoParcelamento = "delete gcom.cadastro.cliente.ClienteGuiaPagamento "
					+ "where gpag_id = :idGuiaPagamento ";

			session.createQuery(removerClienteGuiaPagamentoDoParcelamento)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa o critério de cobrança linha definido para a rota
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Leonardo Vieira
	 * @created 12/12/2006
	 * 
	 * @param idRota
	 * @param idCobrancaAcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public CobrancaCriterio pesquisarCriterioCobrancaRota(Integer idRota,
			Integer idCobrancaAcao) throws ErroRepositorioException {

		CobrancaCriterio retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cc from RotaAcaoCriterio rac "
					+ "inner join rac.cobrancaAcao ca "
					+ "inner join rac.cobrancaCriterio cc "
					+ "where rac.comp_id.rotaId = :idRota and ca.id = :idCobrancaAcao";

			retorno = (CobrancaCriterio) session.createQuery(consulta)
					.setInteger("idRota", idRota)
					.setInteger("idCobrancaAcao", idCobrancaAcao)
					.setMaxResults(1).uniqueResult();

			retorno.setCriteriosSituacaoCobranca(new HashSet(this
					.pesquisarCobrancaCriterioSituacaoCobranca(retorno.getId())));
			retorno.setCriteriosSituacaoLigacaoAgua(new HashSet(this
					.pesquisarCobrancaCriterioSituacaoLigacaoAgua(retorno
							.getId())));
			retorno.setCriteriosSituacaoLigacaoEsgoto(new HashSet(this
					.pesquisarCobrancaCriterioSituacaoLigacaoEsgoto(retorno
							.getId())));
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de cobrança linha definido para o critério de
	 * cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Leonardo Vieira
	 * @created 12/12/2006
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaCriterioLinha> pesquisarCobrancaCriterioLinhaCriterio(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select ccl  from CobrancaCriterioLinha ccl "
					+ "inner join ccl.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de situacao de cobrança definido para o critério de
	 * cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoCobranca> pesquisarCobrancaCriterioSituacaoCobranca(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csc from CriterioSituacaoCobranca csc "
					+ "inner join csc.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de situacao de ligacao de agua definido para o
	 * critério de cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoLigacaoAgua> pesquisarCobrancaCriterioSituacaoLigacaoAgua(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csla from CriterioSituacaoLigacaoAgua csla "
					+ "inner join csla.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o critério de situacao de ligacao de esgoto definido para o
	 * critério de cobrança
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0001] Gerar Atividade de
	 * Ação de Cobrança para os Imóveis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoLigacaoEsgoto> pesquisarCobrancaCriterioSituacaoLigacaoEsgoto(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csle from CriterioSituacaoLigacaoEsgoto csle "
					+ "inner join csle.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaCriterio pesquisarCobrancaCriterioIdCriterio(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		CobrancaCriterio retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cc from cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (CobrancaCriterio) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o documento de cobranca da acao precedente (2.3.1)
	 * 
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança o Imóvel
	 * 
	 * @author Francisco do Nascimento
	 * @date 22/12/2008
	 * 
	 * @param idImovel
	 * @param idServicoTipo
	 * @param indicadorExecucao
	 * @param dataEncerramento
	 * @return Id do documento de cobrança
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDocumentoCobrancaAcaoPrecedente(
			Integer idDocumentoCobrancaAcaoPrecedente,
			Date dataMinimaEmissaoRealizacaoAcaoPrecente)
			throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {

			/*
			 * RM 3452 Alterado por Raphael Rossiter em 03/07/2012 a pedido de
			 * Rosana Carvalho.
			 */
			consulta = "select orse.cbdo_id AS idDocCob "
					+ " from atendimentopublico.ordem_servico orse "
					+ " inner join atendimentopublico.atend_motivo_encmt amen on amen.amen_id = orse.amen_id "
					+ " where orse.cbdo_id = :idDocumentoCobrancaAcaoPrecedente and amen.amen_icexecucao = :indicadorExecucao and "
					+ " orse.orse_tmgeracao is not null and orse.orse_tmgeracao <= :dataMinimaEmissaoRealizacaoAcaoPrecente ";

			retorno = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("idDocCob", Hibernate.INTEGER)
					.setInteger("idDocumentoCobrancaAcaoPrecedente",
							idDocumentoCobrancaAcaoPrecedente)
					.setShort(
							"indicadorExecucao",
							AtendimentoMotivoEncerramento.INDICADOR_EXECUCAO_SIM)
					.setTimestamp("dataMinimaEmissaoRealizacaoAcaoPrecente",
							dataMinimaEmissaoRealizacaoAcaoPrecente)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection<Integer> pesquisarDocumentoCobrancaRelativoAcaoPrecedente(
			Integer idImovel, Integer idDocumentoTipo, Date dataEmissao,
			Date dataEmissaoValidade) throws ErroRepositorioException {

		Collection<Integer> retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cbdo.cbdo_id as idCobrancaDocumento  from cobranca.cobranca_documento cbdo "
					+ "inner join cobranca.documento_tipo dotp on dotp.dotp_id = cbdo.dotp_id "
					+ "left join faturamento.documento_nao_entregue done on done.cbdo_id = cbdo.cbdo_id "
					+ "where cbdo.imov_id = :idImovel and dotp.dotp_id = :idDocumentoTipo "
					+ "and (done.dotp_id is null or done.dotp_id <> dotp.dotp_id) "
					+ "and cbdo.cbdo_tmemissao <= :dataEmissao AND cbdo.cbdo_tmemissao >= :dataEmissaoValidade " ;
					
					if (idDocumentoTipo != null && !idDocumentoTipo.equals(DocumentoTipo.AVISO_CORTE)) {
						
						consulta = consulta + " and (cbdo.cast_id is null OR cbdo.cast_id <> " + CobrancaAcaoSituacao.CANCELADA_PRAZO + ") ";
					}
					
					consulta = consulta + " ORDER BY cbdo.cbdo_id DESC ";

			retorno = (Collection<Integer>) session.createSQLQuery(consulta).addScalar(
					"idCobrancaDocumento", Hibernate.INTEGER).setInteger(
					"idImovel", idImovel).setInteger("idDocumentoTipo",
					idDocumentoTipo).setDate("dataEmissao", dataEmissao)
					.setDate("dataEmissaoValidade", dataEmissaoValidade)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	public Object[] pesquisarIdDocumentoCobranca(Integer idImovel,
			Integer idDocumentoTipo, Date dataEmissao)
			throws ErroRepositorioException {

		Object[] retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cd.cbdo_id as idCobrancaDocumento, cd.cast_id as idCobrancaAcaoSituacao from cobranca.cobranca_documento cd "
					+ "where cd.imov_id = :idImovel and cd.dotp_id = :idDocumentoTipo "
					+ "and cd.cbdo_tmemissao > :dataEmissao";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("idCobrancaAcaoSituacao", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setDate("dataEmissao", dataEmissao).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	public Collection pesquisarImovelCobrancaSituacao(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select ics.cobrancaSituacao.id from ImovelCobrancaSituacao ics "
					+ "inner join ics.imovel im "
					+ "where im.id = :idImovel and ics.dataRetiradaCobranca is null ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	public DebitoTipo pesquisarDebitoTipo(Integer idDebitoTipo)
			throws ErroRepositorioException {

		DebitoTipo retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select debitoTipo from DebitoTipo debitoTipo "
					+ "where debitoTipo.id = :idDebitoTipo";

			retorno = (DebitoTipo) session.createQuery(consulta)
					.setInteger("idDebitoTipo", idDebitoTipo).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	public CobrancaAcaoAtividadeCronograma pesquisarCobrancaAcaoAtividadeCronograma(
			Integer idCronogramaAtividadeAcaoCobranca)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeCronograma retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeCronograma caac "
					+ "where caac.id = :idCronogramaAtividadeAcaoCobranca";

			retorno = (CobrancaAcaoAtividadeCronograma) session
					.createQuery(consulta)
					.setInteger("idCronogramaAtividadeAcaoCobranca",
							idCronogramaAtividadeAcaoCobranca).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaAcaoAtividadeComando pesquisarCobrancaAcaoAtividadeComando(
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeComando retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeComando caac "
					+ "where caac.id = :idCobrancaAcaoAtividadeComando";

			retorno = (CobrancaAcaoAtividadeComando) session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeComando",
							idCobrancaAcaoAtividadeComando).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public Collection pesquisarCobrancaDocumentoItemContaGuiaPagamentoDebitoACobrar(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cdi from CobrancaDocumentoItem cdi "
					+ "inner join cdi.cobrancaDocumento cd "
					+ "left join fetch cdi.contaGeral ctg "
					+ "left join fetch ctg.conta ct "
					+ "left join fetch cdi.guiaPagamentoGeral gpg "
					+ "left join fetch gpg.guiaPagamento gp "
					+ "left join fetch cdi.debitoACobrarGeral dacg "
					+ "left join fetch dacg.debitoACobrar dac "
					+ "where cd.id = :idCobrancaDocumento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaDocumento pesquisarCobrancaDocumento(Integer idImovel,
			Integer idDocumentoTipo) throws ErroRepositorioException {

		CobrancaDocumento retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cd from CobrancaDocumento cd "
					+ "where cd.imovel.id = :idImovel "
					+ "and cd.documentoTipo.id = :idDocumentoTipo "
					+ "order by cd.emissao desc";

			retorno = (CobrancaDocumento) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaAcaoAtividadeCronograma pesquisarCobrancaAcaoAtividadeCronogramaId(
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeCronograma retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeCronograma caac "
					+ "inner join fetch caac.cobrancaAcaoCronograma cac "
					+ "inner join fetch cac.cobrancaAcao ca "
					+ "left join fetch ca.cobrancaAcaoPredecessora coAcPred "
					+ "left join fetch coAcPred.servicoTipo servicoTipo "
					+ "left join fetch ca.ligacaoAguaSituacao "
					+ "left join fetch ca.ligacaoEsgotoSituacao "
					+ "left join fetch ca.documentoTipo "
					+ "left join fetch caac.cobrancaAtividade cat "
					+ "left join fetch cat.processo "
					+ "left join fetch cac.cobrancaGrupoCronogramaMes cgcm "
					+ "left join fetch cgcm.cobrancaGrupo "
					+ "left join fetch ca.servicoTipo "
					+ "left join fetch ca.cobrancaAcaoPredecessoraAlternativa coAcPredAlter "
					+ "left join fetch coAcPredAlter.documentoTipo documentoTipoAlter "
					+ "where caac.id = :idCobrancaAcaoAtividadeCronograma ";

			retorno = (CobrancaAcaoAtividadeCronograma) session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeCronograma",
							idCobrancaAcaoAtividadeCronograma).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verifica de conta tem debito cobrado (CNTA_ID ocorre na tabela
	 * DEBITO_COBRADO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Conta verificarContaDebitoCobrado(Integer idConta)
			throws ErroRepositorioException {

		Conta retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select distinct conta " + "from DebitoCobrado db "
					+ "where db.conta.id = :idConta ";

			retorno = (Conta) session.createQuery(consulta)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * obtem o consumo médio do imovel CSHI_NNCONSUMOCONSUMOMEDIO da tabla
	 * CONSUMO_HISTORICO com IMOV_ID = IMOV_ID da tabela CONTA e o maior mês/ano
	 * de consumo(CSHI_AMFATURAMENTO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterConsumoMedioImovel(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select consumoHistorico.consumoMedio "
					+ "from ConsumoHistorico consumoHistorico "
					+ "where consumoHistorico.imovel.id = :idImovel "
					+ "order by consumoHistorico.referenciaFaturamento desc";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * (DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta a ser
	 * parcelada ocorrendo na tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterIdDebitoTipoDeFiscalizacaoSituacaoServicoACobrar(
			Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select fiscalizacao.debitoTipo.id "
					+ "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in "
					+ "(select debitoCobrado.debitoTipo "
					+ "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * DBCB_NNPRESTACAO da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta
	 * e DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID ocorrendo na
	 * tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR
	 * 
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterNumeroPrestacaoDebitoCobrado(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select debitoCobrado.numeroPrestacao "
					+ "from DebitoCobrado debitoCobrado  "
					+ "where debitoCobrado.conta.id = :idConta " + "and  "
					+ "(select distinct(fiscalizacao.debitoTipo.id) "
					+ "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in "
					+ "(select debitoCobrado.debitoTipo "
					+ "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)) is not null";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Metodo criado para pesquisar os parcelamentos q tenham juros e nao tenha
	 * criado o debito dos juros DBTP_ID = 44
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/02/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSemDebitos()
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String sql = "select distinct(parc.parc_id) as idParcelamento,"
				+ " parc.parc_nnprestacoes as numeroPrestacao,"
				+ " parc.parc_txjuros as taxaJuros,"
				+ " imovel.loca_id as idLocalidade,"
				+ " quadra.qdra_id as idQuadra,"
				+ " quadra.qdra_nnquadra as numeroQuadra,"
				+ " setorComercial.stcm_id as idSetor,"
				+ " setorComercial.stcm_cdsetorcomercial as codigoSetor,"
				+ " imovel.imov_nnlote as lote,"
				+ " imovel.imov_nnsublote as subLote,"
				+ " parc.parc_vljurosparcelamento as valorJurosParcelamento,"
				+ " imovel.imov_id as idImovel"
				+ " from cobranca.parcelamento parc"
				+ " left join faturamento.debito_a_cobrar debitoCobrar on debitoCobrar.parc_id = parc.parc_id"
				+ " inner join cadastro.imovel imovel on imovel.imov_id = parc.imov_id"
				+ " inner join cadastro.setor_comercial setorComercial on setorComercial.stcm_id = imovel.stcm_id"
				+ " inner join cadastro.quadra quadra on imovel.qdra_id = quadra.qdra_id"
				+ " where (parc.parc_tmparcelamento between :inicio and :fim)"
				+ " and parc.parc_vljurosparcelamento <> 0.00"
				+ " and parc.parc_id "
				+ " not in "
				+ " (select parc.parc_id"
				+ " from cobranca.parcelamento parc"
				+ " left join faturamento.debito_a_cobrar debitoCobrar on debitoCobrar.parc_id = parc.parc_id"
				+ " where (parc.parc_tmparcelamento between :inicio and :fim)"
				+ " and parc.parc_vljurosparcelamento <> 0.00"
				+ " and debitoCobrar.dbtp_id = 44)";

		try {
			retorno = session
					.createSQLQuery(sql)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					// 0
					.addScalar("numeroPrestacao", Hibernate.SHORT)
					// 1
					.addScalar("taxaJuros", Hibernate.BIG_DECIMAL)
					// 2
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 3
					.addScalar("idQuadra", Hibernate.INTEGER)
					// 4
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					// 5
					.addScalar("idSetor", Hibernate.INTEGER)
					// 6
					.addScalar("codigoSetor", Hibernate.INTEGER)
					// 7
					.addScalar("lote", Hibernate.SHORT)
					// 8
					.addScalar("subLote", Hibernate.SHORT)
					// 9
					.addScalar("valorJurosParcelamento", Hibernate.BIG_DECIMAL)
					// 10
					.addScalar("idImovel", Hibernate.INTEGER)
					// 11
					.setDate("inicio",
							Util.converteStringParaDate("22/02/2007"))
					.setDate("fim", Util.converteStringParaDate("24/02/2007"))
					.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a colecao de ação de cobrança passando o id da acao precedente
	 * 
	 * 
	 * 
	 * @author Sávio Luiz
	 * @created 27/02/2007
	 * 
	 * @param idCobracaoAcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesqsuisarAcaoCobrancaPelaPrecedente(
			Integer idCobracaoAcao) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select docTipo.id,cobAcao.numeroDiasValidade "
					+ "from CobrancaAcao cobAcao  "
					+ "inner join cobAcao.documentoTipo docTipo "
					+ "left join cobAcao.cobrancaAcaoPredecessora cobAcaoPrede "
					+ "where cobAcaoPrede.id = :idCobracaoAcao ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobracaoAcao", idCobracaoAcao).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Obtém a menor data de pagamento para as guias de pagamento
	 * 
	 * [UC0302] Gerar Débitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 19/03/2007
	 * 
	 * @param idGuiaPagamento
	 * @param idImovel
	 * @param idDebitoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentoGuiaPagamento(
			Integer idGuiaPagamento, Integer idImovel, Integer idDebitoTipo)
			throws ErroRepositorioException {

		Date retorno = null;
		Date data1 = null;
		Date data2 = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.guiaPagamento gpag "
					+ "INNER JOIN gpag.imovel imov "
					+ "WHERE gpag.id = :idGuiaPagamento ";

			data1 = (Date) session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.uniqueResult();

			consulta = "SELECT MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.guiaPagamento gpag "
					+ "INNER JOIN gpag.imovel imov "
					+ "WHERE pgmt.imovel.id= :idImovel and pgmt.debitoTipo.id = :idDebitoTipo";

			data2 = (Date) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDebitoTipo", idDebitoTipo).uniqueResult();

			if (data2 == null) {
				retorno = data1;
			} else {
				if (data1 == null) {
					retorno = data2;
				} else {
					if (data1.before(data2)) {
						retorno = data1;
					} else {
						retorno = data2;
					}
				}
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * obtem o numero de Consumo Faturado Mes CSHI_NNCONSUMOFATURADOMES da
	 * tabela CONSUMO_HISTORICO com IMOV_ID = IMOV_ID da tabela CONTA e o maior
	 * mês/ano de consumo(CSHI_AMFATURAMENTO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 19/03/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterNumeroConsumoFaturadoMes(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select consumoHistorico.numeroConsumoFaturadoMes "
					+ "from ConsumoHistorico consumoHistorico "
					+ "where consumoHistorico.imovel.id = :idImovel "
					+ "order by consumoHistorico.referenciaFaturamento desc";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) conta(s) parceladas já estão no histórico [UC0252]
	 * Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarContaHistoricoParcelamento(Integer idImovel,
			Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from "
					+ "ParcelamentoItem parcItem "
					+ "inner join parcItem.contaGeral cntaGeral "
					+ "left join cntaGeral.contaHistorico cntaHist "
					+ "where cntaHist.imovel.id = :idImovel and "
					+ "parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) debito(s) a cobrar parcelados já estão no histórico
	 * [UC0252] Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarDebitoACobrarHistoricoParcelamento(
			Integer idImovel, Integer idParcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from "
					+ "ParcelamentoItem parcItem "
					+ "inner join parcItem.debitoACobrarGeral dbacGeral "
					+ "left join dbacGeral.debitoACobrarHistorico dbacHist "
					+ "where dbacHist.imovel.id = :idImovel "
					+ "and parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) credito(s) a realizar utilizados no parcelados já estão
	 * no histórico [UC0252] Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarCreditoARealizarHistoricoParcelamento(
			Integer idImovel, Integer idParcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from "
					+ "ParcelamentoItem parcItem "
					+ "inner join parcItem.creditoARealizarGeral cdarGeral "
					+ "left join cdarGeral.creditoARealizarHistorico cdarHist "
					+ "where cdarHist.imovel.id = :idImovel "
					+ "and parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * retorna referenciaContabil da conta cancelada por retificação [UC0252]
	 * Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 13/04/2007
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCanceladaRetificacao(Integer idImovel,
			int anoMesReferencia) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select conta.referenciaContabil "
					+ "from Conta conta "
					+ "where conta.imovel = :idImovel and "
					+ "conta.referencia = :anoMesReferencia and "
					+ "conta.debitoCreditoSituacaoAtual.id = :debitoCreditoSituacaoAtual ";

			retorno = session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("debitoCreditoSituacaoAtual",
							DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna o objeto ParcelamentoFaixaValor com o valor do debito(valorFaixa)
	 * com desconto maior q o da faixa e menor que próxima faixa
	 * 
	 * [UC0575] - Emitir Parcelamento em Atraso
	 * 
	 * @author Sávio Luiz
	 * @date 14/04/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosParcelamentoComMaiorTimestemp(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parc.parcelamento, "// 0
					+ "parc.valorConta, "// 1
					+ "parc.valorServicosACobrar, "// 2
					+ "parc.valorAtualizacaoMonetaria, "// 3
					+ "parc.valorJurosMora, "// 4
					+ "parc.valorMulta, "// 5
					+ "parc.valorDescontoAcrescimos, "// 6
					+ "parc.valorDescontoAntiguidade, "// 7
					+ "parc.valorDescontoInatividade, "// 8
					+ "parc.valorEntrada, "// 9
					+ "parc.numeroPrestacoes, "// 10
					+ "parc.valorPrestacao, "// 11
					+ "parc.valorJurosParcelamento, "// 12
					+ "parc.id "// 13
					+ "FROM Parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "INNER JOIN parc.parcelamentoSituacao parcSit "
					+ "WHERE imov.id = :idImovel AND parcSit.id = :parcNormal "
					+ "ORDER BY parc.parcelamento desc ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("parcNormal", ParcelamentoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Ana Maria
	 * @created 13/04/2007
	 * 
	 * @param idCliente
	 * @param numeroSequencialDocumento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarCobrancaDocumentoItemCliente(Integer idCliente,
			int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "// 12
					+ "imov.id, "// 13
					+ "imovGuia.id, "// 14
					+ "imovDebito.id, "// 15
					+ "localidadeConta.id, "// 16
					+ "localidadeGuiaPagamento.id, "// 17
					+ "localidadeDebitoACobrar.id, "// 18
					+ "imovelHistorico.id, "// 19
					+ "localidadeContaHistorico.id, "// 20
					+ "imovGuiaHistorico.id, "// 21
					+ "localidadeGuiaPagamentoHistorico.id, "// 22
					+ "imovDebitoHistorico.id, "// 23
					+ "localidadeDebitoACobrarHistorico.id, "// 24
					+ "cd.id, "// 25
					+ "documentoTipo.id, "// 26
					+ "debitoACobrar.numeroPrestacaoDebito, " // 27
					+ "debitoACobrar.numeroPrestacaoCobradas, " // 28
					+ "cage.id, " // 29
					+ "localidade.id, " // 30
					+ "imovel.id "// 31

					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.cliente clie "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN conta.imovel imov "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN guiaPagamento.imovel imovGuia "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN guiaPagamentoHistorico.imovel imovGuiaHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN debitoACobrar.imovel imovDebito "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN debitoACobrarHistorico.imovel imovDebitoHistorico "
					+ "LEFT JOIN conta.localidade localidadeConta "
					+ "LEFT JOIN contaHistorico.localidade localidadeContaHistorico "
					+ "LEFT JOIN guiaPagamento.localidade localidadeGuiaPagamento "
					+ "LEFT JOIN guiaPagamentoHistorico.localidade localidadeGuiaPagamentoHistorico "
					+ "LEFT JOIN debitoACobrar.localidade localidadeDebitoACobrar "
					+ "LEFT JOIN debitoACobrarHistorico.localidade localidadeDebitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade localidade "
					+ "LEFT JOIN cd.imovel imovel "

					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "clie.id = :idCliente";

			retorno = session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idCliente", idCliente.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta o id e a situação da ordem de serviço associada ao documento de
	 * cobrança passado como parâmetro
	 * 
	 * @author Sávio Luiz
	 * @created 13/04/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarDadosOrdemServicoDocumentoCobranca(
			Integer idDocumentoCobranca) throws ErroRepositorioException {

		Object[] retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select os.id,os.situacao from OrdemServico os "
					+ "inner join os.cobrancaDocumento cobrancaDoc "
					+ "where cobrancaDoc.id = :idDocumentoCobranca ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idDocumentoCobranca", idDocumentoCobranca)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsParcelamentosItemDebitoACobrar(
			Collection idsDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select parcelamentoItem.id"
					+ " from ParcelamentoItem parcelamentoItem "
					+ " where parcelamentoItem.debitoACobrarGeral.id in (:idsDebitoACobrar)";

			retorno = session.createQuery(consulta)
					.setParameterList("idsDebitoACobrar", idsDebitoACobrar)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsCobrancaDocumentoItemDebitoACobrar(
			Collection idsDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaDocumentoItem.id"
					+ " from CobrancaDocumentoItem cobrancaDocumentoItem "
					+ " where cobrancaDocumentoItem.debitoACobrarGeral.id in (:idsDebitoACobrar)";

			retorno = session.createQuery(consulta)
					.setParameterList("idsDebitoACobrar", idsDebitoACobrar)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarCobrancaDocumentoItemDebitoACobrar(
			Collection idsDocumentoItemDebitoACobrar)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.id in (:idsDocumentoItemDebitoACobrar) ";

			session.createQuery(consulta)
					.setParameterList("idsDocumentoItemDebitoACobrar",
							idsDocumentoItemDebitoACobrar).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarParcelamentosItemDebitoACobrar(
			Collection idsParcelamentosItemDebitoACobrar)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String atualizarImovel = "update gcom.cobranca.parcelamento.ParcelamentoItem "
					+ "set dbac_id = null where pcit_id in (:idsParcelamentosItemDebitoACobrar)";

			session.createQuery(atualizarImovel)
					.setParameterList("idsParcelamentosItemDebitoACobrar",
							idsParcelamentosItemDebitoACobrar).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author Sávio Luiz,Vivianne Sousa
	 * @date 17/10/2006,30/08/2010
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoAgrupadoPorDataPrevista(
			int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			// CRC4529 - query alterada por Vivianne Sousa - 30/08/2010

			consulta = " select"
					+ " (select osfs.fzst_id"
					+ " from atendimentopublico.ordem_servico_fisc_sit osfs"
					+ " inner join atendimentopublico.ordem_servico orse on osfs.orse_id = orse.orse_id"
					+ " where orse.cbdo_id  = cbdo.cbdo_id and ROWNUM <= 1 "
					+ " order by osfs_dtfiscalizacaosituacao ) as idFiscalizacaoSit,"// 0
					+ " cbdo.cbdo_icantesapos as indAntesApos,"// 1
					+ " cbdo.cbdo_icacimalimite as indAcimaLimite,"// 2
					+ " casit.cast_id as idCobrancaAcaoSit,"// 3
					+ " cdst.cdst_id as idCobrancaDebitoSit,"// 4
					+ " catg.catg_id as idCategoria,"// 5
					+ " epod.epod_id as idEsferaPoder,"// 6
					+ " cbct.cbct_id as idCobrancaCriterio,"// 7
					+ " greg.greg_id as idGerencia,"// 8
					+ " loca.loca_id as idLocalidade,"// 9
					+ " stcm.stcm_id as idSetor,"// 10
					+ " rota.rota_id as idRota,"// 11
					+ " qdra.qdra_id as idQuadra,"// 12
					+ " qdra.qdra_nnquadra as numeroQuadra,"// 13
					+ " stcm.stcm_cdsetorcomercial as codigoSetor,"// 14
					+ " iper.iper_id as idPerfilImovel,"// 15
					+ " coalesce(last.last_id,imov.last_id) as idLigacaoAguaSit,"// 16
					+ " coalesce(lest.lest_id,imov.lest_id) as idLigacaoEsgotoSit,"// 17
					+ " empr.empr_id as idEmpresa,"// 18
					+ " amen.amen_id as idAtendMotivoEnc,"// 19
					+ " loca.uneg_id as idUnidadeNegocio,"// 20
					+ " cbdo.demf_id as idDocEmissaoForma,"// 21
					+ " count(cbdo.cbdo_id) as qtdeCobrancaDocumento,"// 22
					+ " sum(cbdo.cbdo_vldocumento) as valorCobrancaDoc"// 23
					+ " from"
					+ " cobranca.cobranca_documento cbdo"
					+ " left outer join cadastro.esfera_poder epod 				on cbdo.epod_id=epod.epod_id"
					+ " left outer join cobranca.cobranca_acao_situacao casit 			on cbdo.cast_id=casit.cast_id"
					+ " left outer join cobranca.cobranca_debito_situacao cdst 			on cbdo.cdst_id=cdst.cdst_id"
					+ " left outer join cadastro.categoria catg 				on cbdo.catg_id=catg.catg_id"
					+ " left outer join cobranca.cobranca_acao_ativ_crg caac 		on cbdo.caac_id=caac.caac_id"
					+ " left outer join cobranca.cobranca_acao_cronograma cbcr 			on caac.cbcr_id=cbcr.cbcr_id"
					+ " left outer join cobranca.cobranca_acao cbac 				on cbcr.cbac_id=cbac.cbac_id"
					+ " left outer join cobranca.cobranca_grupo_crg_mes cbcm 		on cbcr.cbcm_id=cbcm.cbcm_id"
					+ " left outer join cobranca.cobranca_grupo cbgr 				on cbcm.cbgr_id=cbgr.cbgr_id"
					+ " left outer join cobranca.cobranca_criterio cbct 			on cbdo.cbct_id=cbct.cbct_id"
					+ " left outer join cadastro.imovel imov 					on cbdo.imov_id=imov.imov_id"
					+ " left outer join cadastro.localidade loca 				on imov.loca_id=loca.loca_id"
					+ " left outer join cadastro.gerencia_regional greg 			on loca.greg_id=greg.greg_id"
					+ " left outer join cadastro.setor_comercial stcm 				on imov.stcm_id=stcm.stcm_id"
					+ " left outer join cadastro.quadra qdra 					on imov.qdra_id=qdra.qdra_id"
					+ " left outer join micromedicao.rota rota 					on qdra.rota_id=rota.rota_id"
					+ " left outer join cadastro.imovel_perfil iper 				on imov.iper_id=iper.iper_id"
					+ " left outer join atendimentopublico.ligacao_esgoto_situacao lest  	on cbdo.lest_id=lest.lest_id"
					+ " left outer join atendimentopublico.ligacao_agua_situacao last 		on cbdo.last_id=last.last_id"
					+ " left outer join cadastro.empresa empr 					on cbdo.empr_id=empr.empr_id"
					+ " left outer join atendimentopublico.atend_motivo_encmt amen on cbdo.amen_id=amen.amen_id"
					+ " where"
					+ " caac.caac_id= :idCobrancaAtividadeAcaoCronograma"
					+ " group by"
					+ " idFiscalizacaoSit,cbdo.cbdo_icantesapos ,cbdo.cbdo_icacimalimite ,casit.cast_id ,cdst.cdst_id ,catg.catg_id ,"
					+ " cbcm.cbcm_amreferencia ,cbcr.cbcr_id,caac.caac_dtprevista,cbct.cbct_id ,cbgr.cbgr_id ,greg.greg_id ,"
					+ " loca.loca_id ,stcm.stcm_id ,rota.rota_id ,qdra.qdra_id ,qdra.qdra_nnquadra ,stcm.stcm_cdsetorcomercial,iper.iper_id ,"
					+ " last.last_id ,lest.lest_id ,epod.epod_id ,cbac.cbac_id ,empr.empr_id ,amen.amen_id ,loca.uneg_id ,imov.last_id ,imov.lest_id, cbdo.demf_id"
					+ " order by"
					+ " idFiscalizacaoSit,cbdo.cbdo_icantesapos,cbdo.cbdo_icacimalimite,casit.cast_id,cdst.cdst_id,"
					+ " catg.catg_id,epod.epod_id,greg.greg_id,loca.uneg_id,loca.loca_id,stcm.stcm_id,rota.rota_id,"
					+ " qdra.qdra_id,qdra.qdra_nnquadra,stcm.stcm_cdsetorcomercial,iper.iper_id,last.last_id,lest.lest_id";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT)
					.addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER)
					.addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER)
					.addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("idDocEmissaoForma", Hibernate.INTEGER)
					.addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaAtividadeAcaoCronograma",
							idCobrancaAtividadeAcaoCronograma).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id, coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id),emp.id,moen.id, loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobAcaoAtivCron "
			// +
			// "left join cobAcaoAtivCron.cobrancaAcaoCronograma cobAcaoCronog "
			// + "left join cobAcaoCronog.cobrancaAcao cobAcao "
			// +
			// "left join cobAcaoCronog.cobrancaGrupoCronogramaMes cobGrupCronogramaMes "
			// + "left join cobGrupCronogramaMes.cobrancaGrupo cobGrupo "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join cobrancaDocumento.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivCron.id = :idCobrancaAtividadeAcaoCronograma "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// +
			// "cobAcaoSit.id,cobDebSit.id,categ.id,cobGrupCronogramaMes.anoMesReferencia,cobAcaoCronog.id,"
			// +
			// "cobAcaoAtivCron.dataPrevista,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.unidadeNegocio.id, loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id ";
			//
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoCronograma",
			// idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author Sávio Luiz,Vivianne Sousa, Ivan Sergio
	 * @date 17/10/2006,30/08/2010, 23/12/2010
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoAgrupadoPorDataComando(
			int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// CRC4529 - query alterada por Vivianne Sousa - 30/08/2010

			consulta = " SELECT temp.fzst_id                   AS idfiscalizacaosit,"
					+ " cbdo.cbdo_icantesapos               AS indantesapos,"
					+ " cbdo.cbdo_icacimalimite             AS indacimalimite,"
					+ " casit.cast_id                       AS idcobrancaacaosit,"
					+ " cdst.cdst_id                        AS idcobrancadebitosit,"
					+ " catg.catg_id                        AS idcategoria,"
					+ " epod.epod_id                        AS idesferapoder,"
					+ " cbct.cbct_id                        AS idcobrancacriterio,"
					+ " greg.greg_id                        AS idgerencia,"
					+ " loca.loca_id                        AS idlocalidade,"
					+ " stcm.stcm_id                        AS idsetor,"
					+ " rota.rota_id                        AS idrota,"
					+ " qdra.qdra_id                        AS idquadra,"
					+ " qdra.qdra_nnquadra                  AS numeroquadra,"
					+ " stcm.stcm_cdsetorcomercial          AS codigosetor,"
					+ " iper.iper_id                        AS idperfilimovel,"
					+ " COALESCE(LLAST.last_id,imov.last_id) AS idligacaoaguasit,"
					+ " COALESCE(lest.lest_id,imov.lest_id) AS idligacaoesgotosit,"
					+ " empr.empr_id                        AS idempresa,"
					+ " amen.amen_id                        AS idatendmotivoenc,"
					+ " loca.uneg_id                        AS idunidadenegocio,"
					+ " cbdo.demf_id                        AS iddocemissaoforma,"
					+ " COUNT(cbdo.cbdo_id)                 AS qtdecobrancadocumento,"
					+ " SUM(cbdo.cbdo_vldocumento)          AS valorcobrancadoc,"

					+ " case when (svtp.SVTP_NNCODIGOCONSTANTE = "
					+ ServicoTipo.TIPO_CORTE_LIGACAO_AGUA
					+ " and"
					+ " cbac.cbac_id = "
					+ CobrancaAcao.CORTE_FISICO
					+ " and"
					+ " casit.cast_id = "
					+ CobrancaAcaoSituacao.EXECUTADA
					+ ") then"
					+ " 		cotp.cotp_id"
					+ " end 								   AS idCorteTipo"

					+ " FROM cobranca.cobranca_documento cbdo"
					+ " LEFT OUTER JOIN"
					+ " ("
					+ " SELECT osfs.fzst_id,"
					+ "        osfs.OSFS_DTFISCALIZACAOSITUACAO,"
					+ "        cbdo.cbdo_id "
					+ "   FROM cobranca.cobranca_acao_ativ_crg caac,"
					+ "       cobranca.cobranca_documento cbdo,"
					+ "       atendimentopublico.ordem_servico orse,"
					+ "       atendimentopublico.ordem_servico_fisc_sit osfs"
					+ "  WHERE "
					+ "    caac.caac_id = :idCobrancaAtividadeAcaoCronograma"
					+ "    AND cbdo.caac_id = cbdo.caac_id"
					+ "    AND orse.cbdo_id = cbdo.cbdo_id"
					+ "    AND osfs.orse_id = orse.orse_id"
					+ " ) temp ON temp.cbdo_id = cbdo.cbdo_id"
					+ " LEFT OUTER JOIN cadastro.esfera_poder epod"
					+ " ON cbdo.epod_id=epod.epod_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_situacao casit"
					+ " ON cbdo.cast_id=casit.cast_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_debito_situacao cdst"
					+ " ON cbdo.cdst_id=cdst.cdst_id"
					+ " LEFT OUTER JOIN cadastro.categoria catg"
					+ " ON cbdo.catg_id=catg.catg_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_ativ_crg caac"
					+ " ON cbdo.caac_id=caac.caac_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_cronograma cbcr"
					+ " ON caac.cbcr_id=cbcr.cbcr_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao cbac"
					+ " ON cbcr.cbac_id=cbac.cbac_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_grupo_crg_mes cbcm"
					+ " ON cbcr.cbcm_id=cbcm.cbcm_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_grupo cbgr"
					+ " ON cbcm.cbgr_id=cbgr.cbgr_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_criterio cbct"
					+ " ON cbdo.cbct_id=cbct.cbct_id"
					+ " LEFT OUTER JOIN cadastro.imovel imov"
					+ " ON cbdo.imov_id=imov.imov_id"

					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua lagu"
					+ " ON imov.imov_id = lagu.lagu_id"
					+ " LEFT OUTER JOIN atendimentopublico.corte_tipo cotp"
					+ " ON lagu.cotp_id = cotp.cotp_id"
					+ " LEFT OUTER JOIN atendimentopublico.ordem_servico orse"
					+ " ON cbdo.cbdo_id = orse.cbdo_id"
					+ " LEFT OUTER JOIN atendimentopublico.servico_tipo svtp"
					+ " ON orse.svtp_id = svtp.svtp_id"

					+ " LEFT OUTER JOIN cadastro.localidade loca"
					+ " ON imov.loca_id=loca.loca_id"
					+ " LEFT OUTER JOIN cadastro.gerencia_regional greg"
					+ " ON loca.greg_id=greg.greg_id"
					+ " LEFT OUTER JOIN cadastro.setor_comercial stcm"
					+ " ON imov.stcm_id=stcm.stcm_id"
					+ " LEFT OUTER JOIN cadastro.quadra qdra"
					+ " ON imov.qdra_id=qdra.qdra_id"
					+ " LEFT OUTER JOIN micromedicao.rota rota"
					+ " ON qdra.rota_id=rota.rota_id"
					+ " LEFT OUTER JOIN cadastro.imovel_perfil iper"
					+ " ON imov.iper_id=iper.iper_id"
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_esgoto_situacao lest"
					+ " ON cbdo.lest_id=lest.lest_id"
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua_situacao LLAST"
					+ " ON cbdo.last_id=LLAST.last_id"
					+ " LEFT OUTER JOIN cadastro.empresa empr"
					+ " ON cbdo.empr_id=empr.empr_id"
					+ " LEFT OUTER JOIN atendimentopublico.atend_motivo_encmt amen"
					+ " ON cbdo.amen_id   =amen.amen_id"
					+ " WHERE caac.caac_id = :idCobrancaAtividadeAcaoCronograma "
					+ " GROUP BY temp.fzst_id,"
					+ "   cbdo.cbdo_icantesapos ,"
					+ "   cbdo.cbdo_icacimalimite ,"
					+ "   casit.cast_id ,"
					+ "   cdst.cdst_id ,"
					+ "   catg.catg_id ,"
					+ "   cbcm.cbcm_amreferencia ,"
					+ "   cbcr.cbcr_id ,"
					+ "   caac.caac_tmcomando ,"
					+ "   cbct.cbct_id ,"
					+ "   cbgr.cbgr_id ,"
					+ " 	 greg.greg_id ,"
					+ "   loca.loca_id ,"
					+ "   stcm.stcm_id ,"
					+ "   rota.rota_id ,"
					+ "   qdra.qdra_id ,"
					+ "   qdra.qdra_nnquadra ,"
					+ "   stcm.stcm_cdsetorcomercial ,"
					+ "   caac.caac_dtprevista ,"
					+ "   iper.iper_id ,"
					+ "   LLAST.last_id ,"
					+ "   lest.lest_id ,"
					+ "   epod.epod_id ,"
					+ "   cbac.cbac_id ,"
					+ "   empr.empr_id ,"
					+ "   amen.amen_id ,"
					+ "   loca.uneg_id ,"
					+ "   imov.last_id ,"
					+ "   imov.lest_id,"
					+ "   cbdo.demf_id,"

					+ "   case when (svtp.SVTP_NNCODIGOCONSTANTE = "
					+ ServicoTipo.TIPO_CORTE_LIGACAO_AGUA
					+ " and cbac.cbac_id = "
					+ CobrancaAcao.CORTE_FISICO
					+ " and casit.cast_id = "
					+ CobrancaAcaoSituacao.EXECUTADA
					+ ") then cotp.cotp_id end"

					+ " ORDER BY temp.fzst_id,"
					+ "   cbdo.cbdo_icantesapos,"
					+ "   cbdo.cbdo_icacimalimite,"
					+ "   casit.cast_id,"
					+ "   cdst.cdst_id,"
					+ "   catg.catg_id ,"
					+ "   epod.epod_id,"
					+ "   greg.greg_id,"
					+ "   loca.loca_id,"
					+ "   stcm.stcm_id,"
					+ "   rota.rota_id,"
					+ "   qdra.qdra_id,"
					+ "   qdra.qdra_nnquadra,"
					+ "   stcm.stcm_cdsetorcomercial,"
					+ "   iper.iper_id,"
					+ "   LLAST.last_id," + "   lest.lest_id";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT)
					.addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER)
					.addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER)
					.addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("idDocEmissaoForma", Hibernate.INTEGER)
					.addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.addScalar("idCorteTipo", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoCronograma",
							idCobrancaAtividadeAcaoCronograma).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id,coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id),emp.id,moen.id, loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobAcaoAtivCron "
			// +
			// "left join cobAcaoAtivCron.cobrancaAcaoCronograma cobAcaoCronog "
			// + "left join cobAcaoCronog.cobrancaAcao cobAcao "
			// +
			// "left join cobAcaoCronog.cobrancaGrupoCronogramaMes cobGrupCronogramaMes "
			// + "left join cobGrupCronogramaMes.cobrancaGrupo cobGrupo "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join imov.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivCron.id = :idCobrancaAtividadeAcaoCronograma "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// +
			// "cobAcaoSit.id,cobDebSit.id,categ.id,cobGrupCronogramaMes.anoMesReferencia,cobAcaoCronog.id,"
			// +
			// "cobAcaoAtivCron.comando,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,cobAcaoAtivCron.dataPrevista,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id  "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id";
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoCronograma",
			// idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * atualiza o sequencial de conta impressão
	 * 
	 * @author Sávio Luiz
	 * @date 18/05/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSequencialCobrancaDocumentoImpressao(
			Map<Integer, Integer> mapAtualizaSequencial)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = "update gcom.cobranca.CobrancaDocumento "
				+ "set cbdo_nnsequencialimpressao =:sequencialCobrancaDocumento ,cbdo_tmultimaalteracao = :dataAtual "
				+ "where cbdo_id = :idCobrancaDocumento ";
		if (mapAtualizaSequencial != null && !mapAtualizaSequencial.isEmpty()) {
			Iterator iteMapAtualizaSequencia = mapAtualizaSequencial.keySet()
					.iterator();

			try {
				while (iteMapAtualizaSequencia.hasNext()) {
					Integer idCobrancaDocumento = (Integer) iteMapAtualizaSequencia
							.next();
					Integer sequencialCobrancaDocumento = mapAtualizaSequencial
							.get(idCobrancaDocumento);
					session.createQuery(consulta)
							.setInteger("idCobrancaDocumento",
									idCobrancaDocumento)
							.setInteger("sequencialCobrancaDocumento",
									sequencialCobrancaDocumento)
							.setDate("dataAtual", new Date()).executeUpdate();
				}
			} catch (HibernateException e) {
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				HibernateUtil.closeSession(session);

			}
		}

	}

	/**
	 * Pesquisar relação de protocolos de documentos de cobrança do cronograma
	 * 
	 * @author Ana Maria
	 * @date 15/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarProtocoloDocumentoCobrancaCronograma(
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ ProtocoloDocumentoCobrancaRelatorioHelper.class.getName()
					+ " ( "
					+ "greg.id, greg.nomeAbreviado, greg.nome, "
					+ "uneg.id, uneg.nome, loca.id, loca.descricao, "
					+ "cbdo.codigoSetorComercial, count(*), sum(cbdo.valorDocumento), "
					+ "min(cbdo.sequencialImpressao), max(cbdo.sequencialImpressao),"
					+ "empr.descricao) "
					+ "from CobrancaDocumento cbdo "
					+ "inner join cbdo.cobrancaAcaoAtividadeCronograma caac "
					+ "inner join caac.cobrancaAcaoCronograma cbcr "
					+ "inner join cbcr.cobrancaAcao cbac"
					+ "inner join cbdo.localidade loca "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join cbcr.cobrancaGrupoCronogramaMes cbcm "
					+ "inner join cbdo.empresa empr "
					+ "where caac.id = :idCobrancaAcaoAtividadeCronograma "
					+ "group by empr.id, greg.id, greg.nomeAbreviado, greg.nome, uneg.id, uneg.nome, loca.id, loca.descricao, cbdo.codigoSetorComercial, empr.descricao "
					+ "order by empr.id, greg.id, uneg.id, loca.id, cbdo.codigoSetorComercial";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeCronograma",
							idCobrancaAcaoAtividadeCronograma.intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar relação de protocolos de documentos de cobrança do cronograma
	 * 
	 * @author Ana Maria
	 * @date 15/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarProtocoloDocumentoCobrancaEventual(
			Integer idCobrancaAcaoAtividadeComand)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ ProtocoloDocumentoCobrancaRelatorioHelper.class.getName()
					+ " ( "
					+ "greg.id, greg.nomeAbreviado, greg.nome, "
					+ "uneg.id, uneg.nome, loca.id, loca.descricao, "
					+ "cbdo.codigoSetorComercial, count(*), sum(cbdo.valorDocumento), "
					+ "min(cbdo.sequencialImpressao), max(cbdo.sequencialImpressao),"
					+ "empr.descricao) "
					+ "from CobrancaDocumento cbdo "
					+ "inner join cbdo.cobrancaAcaoAtividadeComando cacm "
					+ "inner join cacm.cobrancaAcao cbac "
					+ "inner join cbdo.localidade loca "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join cbdo.empresa empr "
					+ "where cacm.id = :idCobrancaAcaoAtividadeComand "
					+ "group by empr.id, greg.id, greg.nomeAbreviado, greg.nome, uneg.id, uneg.nome, loca.id, loca.descricao, cbdo.codigoSetorComercial, empr.descricao "
					+ "order by empr.id, greg.id, uneg.id, loca.id, cbdo.codigoSetorComercial";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeComand",
							idCobrancaAcaoAtividadeComand.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera a coleção de OS para o encerramento
	 * 
	 * [UC0478] - Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0007] - Determinar Situação da Ordem de Serviço
	 * 
	 * @author Sávio Luiz
	 * @date 28/05/2007
	 * 
	 * @throws ControladorException
	 */
	public void atualizarParmsOS(Collection colecaoIdsOS,
			Integer idMotivoEncerramento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {

			String atualizarOS = "";

			atualizarOS = "update gcom.atendimentopublico.ordemservico.OrdemServico "
					+ "set orse_tmultimaalteracao = :ultimaAlteracao, "
					+ "amen_id = :idMotivoEncerramento, "
					+ "orse_cdsituacao = :encerrado, "
					+ "orse_tmencerramento = :dataEncerramento ";

			atualizarOS = atualizarOS + " where orse_id in (:idsOrdemServico)";

			if (colecaoIdsOS.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + colecaoIdsOS.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) colecaoIdsOS, 999);

				int qtdQuebras = 999;
				int indice = colecaoIdsOS.size() / qtdQuebras;
				if (colecaoIdsOS.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE  "
							+ indice + " = " + particoes.get(i).size());

					session.createQuery(atualizarOS)
							.setParameterList("idsOrdemServico",
									particoes.get(i))
							.setTimestamp("ultimaAlteracao", new Date())
							.setInteger("idMotivoEncerramento",
									idMotivoEncerramento)
							.setShort("encerrado",
									OrdemServico.SITUACAO_ENCERRADO)
							.setTimestamp("dataEncerramento", new Date())
							.executeUpdate();
				}
			} else {
				session.createQuery(atualizarOS)
						.setParameterList("idsOrdemServico", colecaoIdsOS)
						.setTimestamp("ultimaAlteracao", new Date())
						.setInteger("idMotivoEncerramento",
								idMotivoEncerramento)
						.setShort("encerrado", OrdemServico.SITUACAO_ENCERRADO)
						.setTimestamp("dataEncerramento", new Date())
						.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera os dados de documento item
	 * 
	 * @author Sávio Luiz
	 * @created 29/05/2006
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosCobrancaDocumentoItem(
			Integer idDocumentoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT "
					+ " contaG.indicadorHistorico,"// 0
					+ " guiaPagamentoG.indicadorHistorico,"// 1
					+ " debitoACobrarG.indicadorHistorico,"// 2
					+ " cdi.id,"// 3
					+ " cdi.valorItemCobrado,"// 4
					+ " contaG.id,"// 5
					+ " guiaPagamentoG.id,"// 6
					+ " debitoACobrarG.id "// 7
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.contaGeral contaG "
					+ "LEFT JOIN cdi.guiaPagamentoGeral guiaPagamentoG "
					+ "LEFT JOIN cdi.debitoACobrarGeral  debitoACobrarG "
					+ "WHERE cd.id = :idDocumentoCobranca ";

			retorno = session.createQuery(consulta)
					.setInteger("idDocumentoCobranca", idDocumentoCobranca)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00609] Transferencia de Debitos/Creditos
	 * 
	 * [FS0004] Validar Registro Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @created 05/06/2007
	 * 
	 * @param idRA
	 * @exception ErroRepositorioException
	 */
	public Object[] pesquisarRegistroAtendimentoTransferenciaDebitoCredito(
			Integer idRA) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;

		String consulta = null;

		try {

			consulta = "SELECT "
					+ " rgat.id," // 0
					+ " step.id,"// 1
					+ " step.descricao,"// 2
					+ " imov.id," // 3
					+ " rgat.codigoSituacao " // 4
					+ "FROM RegistroAtendimento rgat "
					+ "INNER JOIN rgat.solicitacaoTipoEspecificacao step "
					+ "LEFT JOIN rgat.imovel imov "
					+ "WHERE rgat.id = :idRA AND imov.indicadorExclusao <> :imovelExclusao ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idRA", idRA)
					.setShort("imovelExclusao", Imovel.IMOVEL_EXCLUIDO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00609] Transferencia de Debitos/Creditos
	 * 
	 * [FS0004] Validar Registro Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @created 05/06/2007
	 * 
	 * @param idSolicitacaoTipoEspecificacao
	 * @exception ErroRepositorioException
	 */
	public EspecificacaoTipoValidacao pesquisarEspecificacaoTipoValidacaoTransferenciaDebitoCredito(
			Integer idSolicitacaoTipoEspecificacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		EspecificacaoTipoValidacao retorno = null;

		String consulta = null;

		try {

			consulta = "SELECT "
					+ " estv " // 0
					+ "FROM EspecificacaoTipoValidacao estv "
					+ "INNER JOIN estv.solicitacaoTipoEspecificacao step "
					+ "WHERE step.id = :idSolicitacaoTipoEspecificacao AND "
					+ " estv.codigoConstante = :transferenciaDebito ";

			retorno = (EspecificacaoTipoValidacao) session
					.createQuery(consulta)
					.setInteger("idSolicitacaoTipoEspecificacao",
							idSolicitacaoTipoEspecificacao)
					.setCharacter("transferenciaDebito",
							EspecificacaoTipoValidacao.TRANSFERENCIA_DEBITO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar relação de parcelamento
	 * 
	 * @author Ana Maria
	 * @date 01/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<RelacaoParcelamentoRelatorioHelper> pesquisarRelacaoParcelamento(
			FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento)
			throws ErroRepositorioException {

		Collection<RelacaoParcelamentoRelatorioHelper> retorno = null;
		Collection<Object[]> retornoConsulta = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		String groupBy = " GROUP BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados()
						.isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( l.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id as idMunicipio, \n  muni.muni_nmmunicipio as municipio";
			groupBy += "muni.muni_nmmunicipio, muni.muni_id, ";
			orderBy += " muni.muni_nmmunicipio, ";
		}
		Query query = null;

		Map parameters = new HashMap();

		try {
			consulta = " select pst.pcst_dsparcelamentosituacao AS situacao,"// 0
					+ " to_char(p.loca_id,'0000')||' - '||l.loca_nmlocalidade AS localidade,"// 1
					+ " UPPER(c.clie_nmcliente)AS cliente,"// 2
					+ " cf.cfon_cdddd AS ddd,"// 3
					+ " cf.cfon_nnfone AS fone,"// 4
					+ " substr(to_char(p.imov_id,'00000000'),1,8) ||'.'|| substr(to_char(p.imov_id,'00000000'),9,1) AS matricula,"// 5
					+ " p.parc_id AS idParcelamento,"// 6
					+ " p.parc_tmparcelamento AS dataParcelamento,"// 7
					+ " to_char(cnta.cnta_dtvencimentoconta, 'DD')AS vencimento,"// 8
					+ " p.parc_vldebitoatualizado AS valorDebito,"// 9
					+ " p.parc_vlentrada AS entrada,"// 10
					+ " p.parc_vlprestacao AS valorPrestacao,"// 11
					+ " p.parc_nnprestacoes AS numeroPrestacao,"// 12
					+ " p.loca_id as idLocalidade,"// 13
					+ " greg.greg_id as idGerencia, greg.greg_nmabreviado as gerencia,"// 14,15
					+ " unid.unid_dsunidade as unidade"// 16
					+ selectMunicipio
					+ " from cobranca.parcelamento p"
					+ " inner join faturamento.conta cnta ON p.imov_id = cnta.imov_id and p.parc_amreferenciafaturamento = cnta.cnta_amreferenciaconta"
					+ " inner join cadastro.cliente c ON c.clie_id = p.clie_id"
					+ " left join seguranca.usuario usur ON usur.usur_id = p.usur_id"
					+ " left join cadastro.unidade_organizacional unid ON usur.unid_id = unid.unid_id"
					+ " inner join cadastro.localidade l ON p.loca_id = l.loca_id"
					+ joinMunicipio
					+ " inner join cadastro.gerencia_regional greg on l.greg_id = greg.greg_id"
					+ " inner join cadastro.unidade_negocio uneg on l.uneg_id = uneg.uneg_id"
					+ " inner join cobranca.parcelamento_situacao pst ON p.pcst_id = pst.pcst_id"
					+ " left join cadastro.cliente_fone cf ON c.clie_id = cf.clie_id and cf.cfon_icfonepadrao = 1"
					+ " inner join cadastro.imovel imov ON p.imov_id = imov.imov_id "
					+ " where 1=1";

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getParcelamentoSituacao().getId() != null) {
				consulta += " and p.pcst_id = :situacao ";
				parameters.put("situacao", filtrarRelacaoParcelamento
						.getParcelamento().getParcelamentoSituacao().getId());
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and p.loca_id = :idLocalidade ";
				parameters.put("idLocalidade", filtrarRelacaoParcelamento
						.getParcelamento().getLocalidade());
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and l.muni_idprincipal IN ( :idMunicipios )";
				parameters.put("idMunicipios", filtrarRelacaoParcelamento
						.getColecaoMunicipiosAssociados());
				if (!temLocalidade) {
					consulta += " and p.loca_id = l.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				consulta += " and p.parc_cdsetorcomercial = :codigoSetorComercial ";
				parameters.put("codigoSetorComercial",
						filtrarRelacaoParcelamento.getParcelamento()
								.getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and p.parc_nnquadra = :numeroQuadra ";
				parameters.put("numeroQuadra", filtrarRelacaoParcelamento
						.getParcelamento().getNumeroQuadra());
			}

			if (filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null
					&& filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null) {
				consulta += " and p.parc_tmparcelamento between (:dataParcelamentoInicial) and (:dataParcelamentoFinal) ";
				parameters
						.put("dataParcelamentoInicial",
								filtrarRelacaoParcelamento
										.getDataParcelamentoInicial());
				parameters.put("dataParcelamentoFinal",
						filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if (filtrarRelacaoParcelamento.getAnoMesReferenciaContabil() != null) {

				consulta += " and p.parc_amreferenciafaturamento = :anoMesReferenciaContabil ";
				parameters.put("anoMesReferenciaContabil",
						filtrarRelacaoParcelamento
								.getAnoMesReferenciaContabil());
			}

			if (filtrarRelacaoParcelamento.getPeriodoContabil() != null) {

				consulta += " and p.parc_amreferenciafaturamento like :periodoContabil ";
				parameters.put("periodoContabil",
						filtrarRelacaoParcelamento.getPeriodoContabil());
			}

			if (filtrarRelacaoParcelamento.getValorDebitoInicial() != null
					&& filtrarRelacaoParcelamento.getValorDebitoFinal() != null) {
				consulta += " and p.parc_vldebitoatualizado between (:valorDebitoInicial) and (:valorDebitoFinal) ";
				parameters.put("valorDebitoInicial",
						filtrarRelacaoParcelamento.getValorDebitoInicial());
				parameters.put("valorDebitoFinal",
						filtrarRelacaoParcelamento.getValorDebitoFinal());
			}

			if (filtrarRelacaoParcelamento.getIdGerencia() != null) {
				consulta += " and greg.greg_id = :idGerencia ";
				parameters.put("idGerencia",
						filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null) {
				consulta += " and uneg.uneg_id in (:idUnidadeNegocio) ";
				parameters.put("idUnidadeNegocio",
						filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdsMotivoDesfazimento() != null
					&& !filtrarRelacaoParcelamento.getIdsMotivoDesfazimento()
							.isEmpty()) {
				consulta += " and p.pmdz_id in (:idsMotivoDesfazimento) ";
				parameters.put("idsMotivoDesfazimento",
						filtrarRelacaoParcelamento.getIdsMotivoDesfazimento());
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel()
							.isEmpty()) {
				consulta += " and imov.iper_id in (:idsPerfisImovel) ";
				parameters.put("idsPerfisImovel",
						filtrarRelacaoParcelamento.getColecaoPerfilImovel());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				consulta += " and p.usur_id = :idUsuario ";
			}

			// Coleção de Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional ";
				parameters
						.put("idUnidadeOrganizacional",
								filtrarRelacaoParcelamento
										.getIdUnidadeOrganizacional());
			}

			consulta += groupBy
					+ "p.parc_id, p.loca_id, l.loca_nmlocalidade, c.clie_nmcliente, pst.pcst_dsparcelamentosituacao, "
					+ "p.imov_id, p.parc_tmparcelamento, cnta.cnta_dtvencimentoconta, p.parc_vldebitoatualizado, p.parc_vlentrada, "
					+ "p.parc_vlprestacao, p.parc_nnprestacoes, cf.cfon_cdddd, cf.cfon_nnfone, greg.greg_id, greg.greg_nmabreviado, unid.unid_dsunidade "
					+ orderBy
					+ " greg.greg_id, l.loca_nmlocalidade, vencimento  ASC, "
					+ "valorDebito DESC, cliente, numeroPrestacao ASC ";

			query = session.createQuery(consulta);

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
					.getColecaoMunicipiosAssociados())) {
				query = session.createSQLQuery(consulta)
						.addScalar("situacao", Hibernate.STRING)
						.addScalar("localidade", Hibernate.STRING)
						.addScalar("cliente", Hibernate.STRING)
						.addScalar("ddd", Hibernate.STRING)
						.addScalar("fone", Hibernate.STRING)
						.addScalar("matricula", Hibernate.STRING)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("dataParcelamento", Hibernate.TIMESTAMP)
						.addScalar("vencimento", Hibernate.STRING)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)
						.addScalar("numeroPrestacao", Hibernate.SHORT)
						.addScalar("idLocalidade", Hibernate.INTEGER)
						.addScalar("idGerencia", Hibernate.INTEGER)
						.addScalar("gerencia", Hibernate.STRING)
						.addScalar("unidade", Hibernate.STRING)
						.addScalar("idMunicipio", Hibernate.INTEGER)
						.addScalar("municipio", Hibernate.STRING);

			} else {
				query = session.createSQLQuery(consulta)
						.addScalar("situacao", Hibernate.STRING)
						.addScalar("localidade", Hibernate.STRING)
						.addScalar("cliente", Hibernate.STRING)
						.addScalar("ddd", Hibernate.STRING)
						.addScalar("fone", Hibernate.STRING)
						.addScalar("matricula", Hibernate.STRING)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("dataParcelamento", Hibernate.TIMESTAMP)
						.addScalar("vencimento", Hibernate.STRING)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)
						.addScalar("numeroPrestacao", Hibernate.SHORT)
						.addScalar("idLocalidade", Hibernate.INTEGER)
						.addScalar("idGerencia", Hibernate.INTEGER)
						.addScalar("gerencia", Hibernate.STRING)
						.addScalar("unidade", Hibernate.STRING);
			}

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

			if (retornoConsulta.size() > 0) {
				retorno = new ArrayList();
				RelacaoParcelamentoRelatorioHelper helper = null;
				for (Iterator iter = retornoConsulta.iterator(); iter.hasNext();) {
					Object[] element = (Object[]) iter.next();
					helper = new RelacaoParcelamentoRelatorioHelper();
					helper.setSituacao((String) element[0]);
					helper.setLocalidade((String) element[1]);
					helper.setCliente((String) element[2]);
					if (element[3] != null) {
						helper.setDdd((String) element[3]);
						helper.setTelefone((String) element[4]);
					}
					helper.setMatricula((String) element[5]);
					helper.setParcelamento((Integer) element[6]);
					helper.setDataParcelamento((Date) element[7]);
					helper.setVencimento((String) element[8]);
					helper.setDebitoTotal((BigDecimal) element[9]);
					helper.setValorEntrada((BigDecimal) element[10]);
					helper.setValorParcelamento((BigDecimal) element[11]);
					helper.setNumeroParcelamento((Short) element[12]);
					helper.setIdLocalidade((Integer) element[13]);
					helper.setIdGerencia((Integer) element[14]);
					helper.setGerencia((String) element[15]);
					if (element[16] != null) {
						helper.setUnidade((String) element[16]);
					}

					if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados())) {
						helper.setIdMunicipio((Integer) element[17]);
						helper.setMunicipio((String) element[18]);
					}
					retorno.add(helper);
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * @author Sávio Luiz, Anderson Italo
	 * @created 15/06/2006, 25/02/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarCobrancaAcaoAtividadeComandoSemRealizacao()
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cacm.id,ca.id,servTipo.id,doctipo.id,cacm.dataEncerramentoPrevista,"
					+ " cacm.realizacao, cacm.comando "
					+ "from CobrancaAcaoAtividadeComando cacm "
					+ " inner join cacm.cobrancaAcao ca"
					+ " left join ca.servicoTipo servTipo "
					+ " left join ca.documentoTipo doctipo "
					+ "where cacm.dataEncerramentoRealizada is null and cacm.realizacao is not null";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).list()));

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobrança
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Sávio Luiz
	 * @date 18/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<DadosPesquisaCobrancaDocumentoHelper> pesquisarCobrancaDocumentoEventual(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id,"
					+ "cobrancaDocumento.emissao, "
					+ "cobrancaDocumento.imovel.id, "
					+ "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobCrit.percentualQuantidadeMinimoPagoParceladoCancelado, "
					+ "cobCrit.valorLimitePrioridade)  "
					+ "from CobrancaDocumento cobrancaDocumento "
					+ "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "where cobrancaDocumento.cobrancaAcaoAtividadeComando.id = :idCobrancaAtividadeAcaoComando "
					+ "order by cobrancaDocumento.id";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobrança
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Sávio Luiz
	 * @date 18/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarOrdemServicoEventual(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select orse.orse_id as idOS,"
					+ " orse.orse_cdsituacao as codigoOS,"
					+ " orse.orse_dtfiscalizacaosituacao as dataFiscalizacao,"
					+ " orse.orse_tmencerramento as dataEncerramento,"
					+ " cob.cbdo_id as idCobDocumento,"
					+ " cob.cbdo_vldocumento as valorDocumento,"
					+ " cobCrit.cbct_pcvlminimopgparccanc as pec,"
					+ " cobCrit.cbct_pcqtminimopgparccanc as qdt,"
					+ " cobCrit.cbct_vllimiteprioridade as valorLimite,"
					+ " orse.fzst_id as idFiscalizacaoSit,"
					+ " atMotEnc.amen_icexecucao as indicadorExecucao,"
					+ " imov.imov_id as idImovel,"
					+ " imov.loca_id as idLocalidade, "
					+ " atMotEnc.amen_id as idMotivoEncerramento "
					+ "from atendimentopublico.ordem_servico orse "
					+ "inner join cobranca.cobranca_documento cob on cob.cbdo_id = orse.cbdo_id "
					+ "    and cob.cacm_id = :idCobrancaAtividadeAcaoComando "
					+ "left join cobranca.cobranca_criterio cobCrit "
					+ "     on cobCrit.cbct_id = cob.cbct_id "
					+ "left join cadastro.imovel imov "
					+ "      on imov.imov_id = orse.imov_id "
					+ "left join  atendimentopublico.atend_motivo_encmt atMotEnc "
					+ "      on atMotEnc.amen_id = orse.amen_id ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("codigoOS", Hibernate.SHORT)
					.addScalar("dataFiscalizacao", Hibernate.DATE)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("idCobDocumento", Hibernate.INTEGER)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("pec", Hibernate.BIG_DECIMAL)
					.addScalar("qdt", Hibernate.BIG_DECIMAL)
					.addScalar("valorLimite", Hibernate.BIG_DECIMAL)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indicadorExecucao", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idMotivoEncerramento", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando)

					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 19/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void deletarResumoCobrancaAcaoEventual(int idCobrancaAcaoCronograma)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "delete ResumoCobrancaAcaoEventual resumoCobrancaAcaoEventual "
					+ "where resumoCobrancaAcaoEventual.cobrancaAcaoAtividadeComando.id = :idCobrancaAcaoCronograma ";

			session.createQuery(consulta)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author Sávio Luiz
	 * @date 19/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoEventualAgrupadoPorDataPrevista(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = " select temp.fzst_id as idFiscalizacaoSit,"
					+ " cbdo.cbdo_icantesapos as indAntesApos,"
					+ " cbdo.cbdo_icacimalimite as indAcimaLimite,"
					+ " casit.cast_id as idCobrancaAcaoSit,"
					+ " cdst.cdst_id as idCobrancaDebitoSit,"
					+ " catg.catg_id as idCategoria,"
					+ " epod.epod_id as idEsferaPoder,"
					+ " cbct.cbct_id as idCobrancaCriterio,"
					+ " cbgr.cbgr_id as idCobrancaGrupo,"
					+ " greg.greg_id as idGerencia,"
					+ " loca.loca_id as idLocalidade,"
					+ " stcm.stcm_id as idSetor,"
					+ " rota.rota_id as idRota,"
					+ " qdra.qdra_id as idQuadra,"
					+ " qdra.qdra_nnquadra as numeroQuadra,"
					+ " stcm.stcm_cdsetorcomercial as codigoSetor,"
					+ " iper.iper_id as idPerfilImovel,"
					+ " coalesce(llast.last_id,imov.last_id) as idLigacaoAguaSit,"
					+ " coalesce(lest.lest_id,imov.lest_id) as idLigacaoEsgotoSit,"
					+ " empr.empr_id as idEmpresa,"
					+ " amen.amen_id as idAtendMotivoEnc,"
					+ " loca.uneg_id as idUnidadeNegocio,"
					+ " count(cbdo.cbdo_id) as qtdeCobrancaDocumento,"
					+ " sum(cbdo.cbdo_vldocumento) as valorCobrancaDoc"
					+ " from cobranca.cobranca_documento cbdo"
					+ "  LEFT OUTER JOIN"
					+ " ("
					+ " SELECT osfs.fzst_id,"
					+ " osfs.OSFS_DTFISCALIZACAOSITUACAO,"
					+ " cbdo.cbdo_id"
					+ " FROM cobranca.cobranca_documento cbdo,"
					+ " atendimentopublico.ordem_servico orse,"
					+ " atendimentopublico.ordem_servico_fisc_sit osfs"
					+ " WHERE "
					+ " cbdo.cacm_id = :idCobrancaAtividadeAcaoComando"
					+ " AND orse.cbdo_id = cbdo.cbdo_id"
					+ " AND osfs.orse_id = orse.orse_id"
					+ " ) temp ON temp.cbdo_id = cbdo.cbdo_id"
					+ " left outer join cadastro.esfera_poder epod                         on cbdo.epod_id=epod.epod_id"
					+ " left outer join cobranca.cobranca_acao_situacao casit             on cbdo.cast_id=casit.cast_id"
					+ " left outer join cobranca.cobranca_debito_situacao cdst             on cbdo.cdst_id=cdst.cdst_id"
					+ " left outer join cadastro.categoria catg                         on cbdo.catg_id=catg.catg_id"
					+ " left outer join cobranca.cobranca_acao_ativ_cmd cacm     on cbdo.cacm_id=cacm.cacm_id"
					+ " left outer join cobranca.cobranca_acao cbac                     on cacm.cbac_id=cbac.cbac_id"
					+ " left outer join cobranca.cobranca_criterio cbct                 on cbdo.cbct_id=cbct.cbct_id"
					+ " left outer join cadastro.imovel imov                             on cbdo.imov_id=imov.imov_id"
					+ " left outer join cadastro.localidade loca                         on imov.loca_id=loca.loca_id"
					+ " left outer join cadastro.gerencia_regional greg                 on loca.greg_id=greg.greg_id"
					+ " left outer join cadastro.setor_comercial stcm                     on imov.stcm_id=stcm.stcm_id"
					+ " left outer join cadastro.quadra qdra                             on imov.qdra_id=qdra.qdra_id"
					+ " left outer join micromedicao.rota rota                             on qdra.rota_id=rota.rota_id"
					+ " left outer join cobranca.cobranca_grupo cbgr                     on rota.cbgr_id=cbgr.cbgr_id"
					+ " left outer join cadastro.imovel_perfil iper                     on imov.iper_id=iper.iper_id"
					+ " left outer join atendimentopublico.ligacao_esgoto_situacao lest on cbdo.lest_id= lest.lest_id"
					+ " left outer join atendimentopublico.ligacao_agua_situacao llast     on cbdo.last_id= llast.last_id"
					+ " left outer join cadastro.empresa empr                             on cbdo.empr_id=empr.empr_id"
					+ " left outer join atendimentopublico.atend_motivo_encmt amen on cbdo.amen_id=amen.amen_id"
					+ " where "
					+ "  cacm.cacm_id = :idCobrancaAtividadeAcaoComando"
					+ " group by"
					+ " temp.fzst_id ,cbdo.cbdo_icantesapos ,cbdo.cbdo_icacimalimite ,"
					+ " casit.cast_id ,cdst.cdst_id ,catg.catg_id ,cacm.cacm_dtencerramentoprevista ,"
					+ " cbct.cbct_id ,cbgr.cbgr_id ,greg.greg_id ,loca.loca_id ,stcm.stcm_id ,"
					+ " rota.rota_id ,qdra.qdra_id ,qdra.qdra_nnquadra ,stcm.stcm_cdsetorcomercial ,"
					+ " iper.iper_id ,llast.last_id ,lest.lest_id ,epod.epod_id ,cbac.cbac_id ,empr.empr_id ,"
					+ " amen.amen_id ,loca.uneg_id ,imov.last_id ,imov.lest_id"
					+ " order by"
					+ " temp.fzst_id,cbdo.cbdo_icantesapos,cbdo.cbdo_icacimalimite,casit.cast_id,"
					+ " cdst.cdst_id,catg.catg_id,epod.epod_id,greg.greg_id,loca.loca_id,stcm.stcm_id,"
					+ " rota.rota_id,qdra.qdra_id,qdra.qdra_nnquadra,stcm.stcm_cdsetorcomercial,"
					+ " iper.iper_id, llast.last_id,lest.lest_id ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT)
					.addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER)
					.addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER)
					.addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER)
					.addScalar("idCobrancaGrupo", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id,coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id), emp.id,moen.id,loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeComando cobAcaoAtivComando "
			// + "left join cobAcaoAtivComando.cobrancaAcao cobAcao "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join rot.cobrancaGrupo cobGrupo "
			// + "left join imov.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivComando.id = :idCobrancaAtividadeAcaoComando "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,categ.id,"
			// +
			// "cobAcaoAtivComando.dataEncerramentoPrevista,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id  "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id ";
			//
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoComando",
			// idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das ações de cobrança
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * 
	 * @author Sávio Luiz
	 * @date 19/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoAtividadeComando(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		try {
			atualizar = "update gcom.cobranca.CobrancaAcaoAtividadeComando "
					+ " set cacm_dtencerramentorealizada = :dataRealizacao,cacm_tmultimaalteracao = :dataAtual "
					+ " where cacm_id = :idCobrancaAtividadeAcaoComando";

			session.createQuery(atualizar)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando)
					.setDate("dataRealizacao", new Date())
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Gerar Curva ABC de Debitos
	 * 
	 * [UC0621] Gerar Curva ABC de Debitos
	 * 
	 * @author Ivan Sérgio
	 * @date 01/08/2007
	 * 
	 */
	public Collection gerarCurvaAbcDebitos(String classificacao,
			String indicadorImovelMedicaoIndividualizada,
			String indicadorImovelParalizacaoFaturamentoCobranca,
			String[] gerenciaRegional, String idLocalidadeInicial,
			String idLocalidadeFinal, String idSetorComercialInicial,
			String idSetorComercialFinal, String idMunicipio,
			String[] situacaoLigacaoAgua, String[] situacaoLigacaoEsgoto,
			String intervaloConsumoMinimoFixadoEsgotoInicial,
			String intervaloConsumoMinimoFixadoEsgotoFinal,
			String indicadorMedicao, String idTipoMedicao,
			String idPerfilImovel, String idTipoCategoria, String[] categoria,
			String idSubCategoria) throws ErroRepositorioException {

		List retorno = null;
		Session session = HibernateUtil.getSession();
		String hqlAux = "";
		String orderBy = "";
		String joinMunicipio = " left join localidade.municipio municipio ";
		if (idMunicipio != null && !idMunicipio.equals("")) {
			joinMunicipio = " inner join localidade.municipio municipio ";
		}
		boolean finaliza = false;

		try {
			String hql = "select distinct"
					+ "	imovel.id, "
					+ "	ligacaoAguaSituacao.id, "
					+ "	ligacaoAgua.dataCorte, "
					+ "	ligacaoAgua.dataSupressao, "
					+ "	gerenciaRegional.id, "
					+ "	gerenciaRegional.nomeAbreviado, "
					+ "	gerenciaRegional.nome, "
					+ "	localidade.id, "
					+ "	localidade.descricao, "
					+ "   municipio.id, "
					+ "	municipio.nome, "
					+ "	setorComercial.id, "
					+ "	setorComercial.codigo, "
					+ "	setorComercial.descricao, "
					+ "	categoria.descricao, "
					+ "	subcategoria.descricao "
					+

					"from "
					+ "	ImovelSubcategoria imovelSubcategoria "
					+ "	inner join imovelSubcategoria.comp_id.imovel imovel "
					+ "	left  join imovelSubcategoria.comp_id.subcategoria subcategoria "
					+ "	left  join subcategoria.categoria categoria "
					+ " 	inner join imovel.localidade localidade "
					+ joinMunicipio
					+ " 	inner join localidade.gerenciaRegional gerenciaRegional "
					+ "	inner join imovel.setorComercial setorComercial "
					+ "	left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " 	left  join imovel.ligacaoAgua ligacaoAgua "
					+ " 	left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " 	left  join imovel.ligacaoEsgoto ligacaoEsgoto "
					+ "	left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " 	left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel "
					+ " 	left  join imovel.imovelPerfil imovelPerfil "
					+ "   Where ";

			// Aplica as Condicoes da consulta
			// **************************************

			// Classificacao
			if (classificacao.trim().equalsIgnoreCase("ESTADO")) {
				orderBy = "";
			} else if (classificacao.trim().equalsIgnoreCase("REGIONAL")) {
				orderBy = " Order By gerenciaRegional.id ";
			} else if (classificacao.trim().equalsIgnoreCase("LOCAL")) {
				orderBy = " Order By localidade.id ";
			} else if (classificacao.trim().equalsIgnoreCase("SETORCOMERCIAL")) {
				orderBy = " Order By setorComercial.id ";
			} else if (classificacao.trim().equalsIgnoreCase("MUNICIPIO")) {
				orderBy = " Order By municipio.nome ";
			}

			// gerenciaRegional
			if ((gerenciaRegional != null) && (gerenciaRegional.length > 0)) {
				if (gerenciaRegional.length == 1
						&& !gerenciaRegional[0].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

					hql += "gerenciaRegional.id = " + gerenciaRegional[0]
							+ " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < gerenciaRegional.length; i++) {
						if (!gerenciaRegional[i].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

							hqlAux += gerenciaRegional[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "gerenciaRegional.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Localidade
			if ((idLocalidadeInicial != null && !idLocalidadeInicial.equals(""))
					&& (idLocalidadeFinal != null && !idLocalidadeFinal
							.equals(""))) {

				hql += "localidade.id >= " + idLocalidadeInicial + " and "
						+ "localidade.id <= " + idLocalidadeFinal + " and ";
				finaliza = true;
			}

			// Setor Comercial Inicial e Final
			if ((idSetorComercialInicial != null && !idSetorComercialInicial
					.equals(""))
					&& (idSetorComercialFinal != null && !idSetorComercialFinal
							.equals(""))) {

				hql += "setorComercial.id >= " + idSetorComercialInicial
						+ " and " + "setorComercial.id <= "
						+ idSetorComercialFinal + " and ";
				finaliza = true;
			}

			// Município
			if (idMunicipio != null && !idMunicipio.equals("")) {
				hql += "municipio.id = " + idMunicipio + " and ";
				finaliza = true;
			}

			// Imoveis com Medicao Individualizada
			if (indicadorImovelMedicaoIndividualizada.equals("1")) {
				hql += "imovel.imovelCondominio is not null and ";
				finaliza = true;
			}

			// Imoveis com Paralizacao de Faturamento/Cobranca
			if (indicadorImovelParalizacaoFaturamentoCobranca.equals("1")) {
				hql += "( (imovel.faturamentoSituacaoTipo.id in (1, 4, 5)) or ";
				// hql += "(imovel.cobrancaSituacao.id in (5, 7, 8, 9)) ) and ";
				hql += " (exists( select ics.id from ImovelCobrancaSituacao ics "
						+ " where ics.imovel.id = imovel.id  and ics.dataRetiradaCobranca is null "
						+ " and ics.cobrancaSituacao.id in (5, 7, 8, 9))) ) and ";
				finaliza = true;
			}

			// Situacao da Ligacao de Agua
			if ((situacaoLigacaoAgua != null)
					&& (situacaoLigacaoAgua.length > 0)) {
				if (situacaoLigacaoAgua.length == 1
						&& !situacaoLigacaoAgua[0].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

					hql += "ligacaoAguaSituacao.id = " + situacaoLigacaoAgua[0]
							+ " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < situacaoLigacaoAgua.length; i++) {
						if (!situacaoLigacaoAgua[i].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

							hqlAux += situacaoLigacaoAgua[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "ligacaoAguaSituacao.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Situacao da Ligacao de Esgoto
			if ((situacaoLigacaoEsgoto != null)
					&& (situacaoLigacaoEsgoto.length > 0)) {
				if (situacaoLigacaoEsgoto.length == 1
						&& !situacaoLigacaoEsgoto[0].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

					hql += "ligacaoEsgotoSituacao.id = "
							+ situacaoLigacaoEsgoto[0] + " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < situacaoLigacaoEsgoto.length; i++) {
						if (!situacaoLigacaoEsgoto[i].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

							hqlAux += situacaoLigacaoEsgoto[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "ligacaoEsgotoSituacao.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Intervalo de Consumo Minimo Fixado de Esgoto
			if ((intervaloConsumoMinimoFixadoEsgotoInicial != null)
					&& (!intervaloConsumoMinimoFixadoEsgotoInicial.equals(""))
					&& (intervaloConsumoMinimoFixadoEsgotoFinal != null)
					&& (!intervaloConsumoMinimoFixadoEsgotoFinal.equals(""))) {

				hql += "ligacaoEsgoto.consumoMinimo >= "
						+ intervaloConsumoMinimoFixadoEsgotoInicial + " and ";
				hql += "ligacaoEsgoto.consumoMinimo <= "
						+ intervaloConsumoMinimoFixadoEsgotoFinal + " and ";
				finaliza = true;
			}

			// indicador medição
			if (indicadorMedicao != null
					&& indicadorMedicao.equals("comMedicao")) {
				// tipo medicao
				// [SF0001 - Selecionar os Imoveis por Tipo de Medicao]
				if (idTipoMedicao != null
						&& idTipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA
								.toString())) {
					hql += "hidrometroInstalacaoHistorico.id is not null and ";
					finaliza = true;
				} else if (idTipoMedicao != null
						&& idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
					hql += "hidrometroInstalacaoHistoricoImovel.id is not null and ";
					finaliza = true;
				} else {
					hql += "(hidrometroInstalacaoHistorico.id is not null or ";
					hql += "hidrometroInstalacaoHistoricoImovel.id is not null) and ";
					finaliza = true;
				}
			} else if (indicadorMedicao != null
					&& indicadorMedicao.equals("semMedicao")) {
				hql += "(hidrometroInstalacaoHistorico.id is null and ";
				hql += "hidrometroInstalacaoHistoricoImovel.id is null) and ";
				finaliza = true;
			}

			// imovel Perfil
			if (idPerfilImovel != null
					&& !idPerfilImovel.equals("")
					&& !idPerfilImovel.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {

				hql += "imovelPerfil.id = " + idPerfilImovel + " and ";
				finaliza = true;
			}

			// categoria
			if (categoria == null) {

				if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PARTICULAR
								.toString())) {
					hql += "( (categoria.id = " + Categoria.RESIDENCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.COMERCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.INDUSTRIAL_INT
							+ ") ) and ";
					finaliza = true;
				} else if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PUBLICO
								.toString())) {
					hql += "categoria.id = " + Categoria.PUBLICO_INT + " and ";
					finaliza = true;
				}

			} else if ((categoria.length == 1)
					&& (categoria[0].trim().equalsIgnoreCase(new Integer(
							ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {

				if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PARTICULAR
								.toString())) {
					hql += "( (categoria.id = " + Categoria.RESIDENCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.COMERCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.INDUSTRIAL_INT
							+ ") ) and ";
					finaliza = true;
				} else if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PUBLICO
								.toString())) {
					hql += "categoria.id = " + Categoria.PUBLICO_INT + " and ";
					finaliza = true;
				}

			} else {
				for (int i = 0; i < categoria.length; i++) {
					if (!categoria[i].trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {

						hqlAux += categoria[i].toString() + ",";
					}
				}

				if (!hqlAux.equals("")) {
					hql += "categoria.id in (" + hqlAux;
					hqlAux = "";

					// Retira a ultima virgula e finaliza a condicao
					hql = hql.substring(0, hql.length() - 1) + ") and ";
					finaliza = true;
				}
			}

			// SubCategoria
			if (idSubCategoria != null
					&& !idSubCategoria.equals("")
					&& !idSubCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				hql += "subcategoria.id = " + idSubCategoria + " and ";
				finaliza = true;
			} else if (idTipoCategoria != null
					&& !idTipoCategoria.equals("")
					&& !idTipoCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {

				hql += "subcategoria.categoria.id = categoria.id and ";
				hql += "subcategoria.id = imovelSubcategoria.comp_id.subcategoria.id and ";
				finaliza = true;
			}

			// Finaliza a condicao
			if (finaliza) {
				hql = hql.substring(0, hql.length() - 5) + orderBy;
			} else {
				hql = hql.substring(0, hql.length() - 9) + orderBy;
			}
			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Ana Maria Data: 08/07/2007 Pesquisa os ID dos Imovéis pelo Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @return Coleção de Ids dos Imóveis
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsImoveisCliente(String codigoCliente)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imov.id " + "from ClienteImovel clieImov "
					+ "inner join clieImov.imovel imov "
					+ "inner join clieImov.cliente clie "
					+ "where clie.id = :codigoCliente";

			retorno = session
					.createQuery(consulta)
					.setInteger("codigoCliente",
							new Integer(codigoCliente).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos dos imóveis
	 * Author: Ana Maria Data: 28/06/2006
	 * 
	 * @param idsImoveis
	 *            Matriculas dos Imoveis
	 * @param contaSituacaoNormal
	 *            Situação Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situação Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situação Incluída de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Coleção de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImoveis(Collection idsImoveis,
			int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento,  "
					+ "conta.iper_id as imovelPerfil, categoria.catg_iccobrancaacrescimos as icAcrescimos "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "INNER JOIN cadastro.imovel imovel on imovel.imov_id = conta.imov_id "
					+ "INNER JOIN cadastro.categoria categoria on categoria.catg_id = imovel.imov_idcategoriaprincipal "					
					+ "WHERE conta.imov_id in (:idsImoveis) "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			consulta += " GROUP BY conta.iper_id, conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id, categoria.catg_iccobrancaacrescimos ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createSQLQuery(consulta)
							.addScalar("idConta", Hibernate.INTEGER)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("dataRevisao", Hibernate.DATE)
							.addScalar("referencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("idSituacaoAtual", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT)
							.addScalar("idMotivoRevisao", Hibernate.INTEGER)
							.addScalar("ultimaAlteracao", Hibernate.DATE)
							.addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("consumoEsgoto", Hibernate.INTEGER)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("idParcelamento", Hibernate.INTEGER)
							.addScalar("imovelPerfil", Hibernate.INTEGER)
							.addScalar("icAcrescimos", Hibernate.INTEGER)							
							.setParameterList("idsImoveis", particoes.get(i))
							.setInteger("situacaoNormal",
									new Integer(contaSituacaoNormal))
							.setInteger("situacaoRetificada",
									new Integer(contaSituacaoRetificada))
							.setInteger("situacaoIncluida",
									new Integer(contaSituacaoIncluida))
							.setInteger("situacaoParcelada",
									new Integer(contaSituacaoParcelada))
							.setInteger("inicialReferencia",
									new Integer(anoMesInicialReferenciaDebito))
							.setInteger("finalReferencia",
									new Integer(anoMesFinalReferenciaDebito))
							.setDate("inicialVencimento",
									anoMesInicialVecimentoDebito)
							.setDate("finalVencimento",
									anoMesFinalVencimentoDebito).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("imovelPerfil", Hibernate.INTEGER)
						.addScalar("icAcrescimos", Hibernate.INTEGER)
						.setParameterList("idsImoveis", idsImoveis)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia",
								new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia",
								new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Ana Maria Data:
	 * 08/08/2007
	 * 
	 * @param idImoveis
	 *            Matriculas dos Imoveis
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situação Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Coleção de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoIdsImoveis(Integer idCliente,
			Collection idsImoveis, int indicadorPagamento,
			String situacaoNormal, Date dataVencimentoInicial,
			Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection retorno = new ArrayList();
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			if (idsImoveis != null && !idsImoveis.isEmpty()) {

				consulta += "UNION ";

				consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
						+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
						+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
						+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
						+ "debTipo.dbtp_id as idDebitoTipo, "
						+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
						+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
						+ "FROM faturamento.guia_pagamento guia "
						+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
						+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
						+ "WHERE guia.imov_id in (:idsImoveis) "
						+ "and guia.dcst_idatual = :situacaoNormal "
						+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

				consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
						+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

				if (indicadorPagamento == 1) {
					consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
				}

				if (idsImoveis.size() > 999) {

					System.out.println("## TAMANHO TOTAL = "
							+ idsImoveis.size());

					List<List<Integer>> particoes = CollectionUtil.particao(
							(List<Integer>) idsImoveis, 999);

					int qtdQuebras = 999;
					int indice = idsImoveis.size() / qtdQuebras;

					if (idsImoveis.size() % qtdQuebras != 0) {
						indice++;
					}

					System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

					for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTIÇÃO DE INDICE "
								+ indice + " = " + particoes.get(i).size());

						Collection retornoPart = null;

						retornoPart = session
								.createSQLQuery(consulta)
								.addScalar("idGuia", Hibernate.INTEGER)
								.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
								.addScalar("anoMesReferencia",
										Hibernate.INTEGER)
								.addScalar("dataVencimento", Hibernate.DATE)
								.addScalar("indicadorCobrancaMulta",
										Hibernate.SHORT)
								.addScalar("descricaoDebitoTipo",
										Hibernate.STRING)
								.addScalar("dataEmissao", Hibernate.DATE)
								.addScalar("idDebitoTipo", Hibernate.INTEGER)
								.addScalar("numeroPrestacoesDebito",
										Hibernate.SHORT)
								.addScalar("numeroPrestacoesTotal",
										Hibernate.SHORT)
								.addScalar("valorPagamento",
										Hibernate.BIG_DECIMAL)
								.addScalar("dataPagamento", Hibernate.DATE)
								.setInteger("idCliente", idCliente)
								.setParameterList("idsImoveis",
										particoes.get(i))
								.setInteger("situacaoNormal",
										new Integer(situacaoNormal))
								.setDate("inicialVencimento",
										dataVencimentoInicial)
								.setDate("finalVencimento", dataVencimentoFinal)
								.list();

						retorno.addAll(retornoPart);
					}
				} else {

					retorno = session
							.createSQLQuery(consulta)
							.addScalar("idGuia", Hibernate.INTEGER)
							.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
							.addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("descricaoDebitoTipo", Hibernate.STRING)
							.addScalar("dataEmissao", Hibernate.DATE)
							.addScalar("idDebitoTipo", Hibernate.INTEGER)
							.addScalar("numeroPrestacoesDebito",
									Hibernate.SHORT)
							.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.setInteger("idCliente", idCliente)
							.setParameterList("idsImoveis", idsImoveis)
							.setInteger("situacaoNormal",
									new Integer(situacaoNormal))
							.setDate("inicialVencimento", dataVencimentoInicial)
							.setDate("finalVencimento", dataVencimentoFinal)
							.list();
				}

			} else {
				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idGuia", Hibernate.INTEGER)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("descricaoDebitoTipo", Hibernate.STRING)
						.addScalar("dataEmissao", Hibernate.DATE)
						.addScalar("idDebitoTipo", Hibernate.INTEGER)
						.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
						.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.setInteger("idCliente", idCliente)
						.setInteger("situacaoNormal",
								new Integer(situacaoNormal))
						.setDate("inicialVencimento", dataVencimentoInicial)
						.setDate("finalVencimento", dataVencimentoFinal).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Ana Maria Data:
	 * 08/08/2007
	 * 
	 * @param idImoveis
	 *            Matriculas dos Imoveis
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situação Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Coleção de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoIdsImoveis(Integer idCliente,
			Collection idsImoveis, int indicadorPagamento,
			String situacaoNormal, Short clienteRelacaoTipo,
			Date dataVencimentoInicial, Date dataVencimentoFinal)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM cadastro.cliente_guia_pagamento clieGuia "
					+ "INNER JOIN faturamento.guia_pagamento guia on guia.gpag_id = clieGuia.gpag_id "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE clieGuia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			if (clienteRelacaoTipo != null) {
				consulta += " and clieGuia.crtp_id = "
						+ clienteRelacaoTipo.toString();
			}

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			consulta += "UNION ";

			consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			if (idsImoveis != null && !idsImoveis.isEmpty()) {

				consulta += "UNION ";

				consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
						+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
						+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
						+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
						+ "debTipo.dbtp_id as idDebitoTipo, "
						+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
						+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
						+ "FROM faturamento.guia_pagamento guia "
						+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
						+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
						+ "WHERE guia.imov_id in (:idsImoveis) "
						+ "and guia.dcst_idatual = :situacaoNormal "
						+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

				consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
						+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

				if (indicadorPagamento == 1) {
					consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
				}

				if (idsImoveis.size() > 999) {

					System.out.println("## TAMANHO TOTAL = "
							+ idsImoveis.size());

					List<List<Integer>> particoes = CollectionUtil.particao(
							(List<Integer>) idsImoveis, 999);

					int qtdQuebras = 999;
					int indice = idsImoveis.size() / qtdQuebras;

					if (idsImoveis.size() % qtdQuebras != 0) {
						indice++;
					}

					System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

					for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTIÇÃO DE INDICE "
								+ indice + " = " + particoes.get(i).size());

						Collection retornoPart = null;

						retornoPart = session
								.createSQLQuery(consulta)
								.addScalar("idGuia", Hibernate.INTEGER)
								.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
								.addScalar("anoMesReferencia",
										Hibernate.INTEGER)
								.addScalar("dataVencimento", Hibernate.DATE)
								.addScalar("indicadorCobrancaMulta",
										Hibernate.SHORT)
								.addScalar("descricaoDebitoTipo",
										Hibernate.STRING)
								.addScalar("dataEmissao", Hibernate.DATE)
								.addScalar("idDebitoTipo", Hibernate.INTEGER)
								.addScalar("numeroPrestacoesDebito",
										Hibernate.SHORT)
								.addScalar("numeroPrestacoesTotal",
										Hibernate.SHORT)
								.addScalar("valorPagamento",
										Hibernate.BIG_DECIMAL)
								.addScalar("dataPagamento", Hibernate.DATE)
								.setInteger("idCliente", idCliente)
								.setParameterList("idsImoveis",
										particoes.get(i))
								.setInteger("situacaoNormal",
										new Integer(situacaoNormal))
								.setDate("inicialVencimento",
										dataVencimentoInicial)
								.setDate("finalVencimento", dataVencimentoFinal)
								.list();

						retorno.addAll(retornoPart);
					}
				} else {

					retorno = session
							.createSQLQuery(consulta)
							.addScalar("idGuia", Hibernate.INTEGER)
							.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
							.addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("descricaoDebitoTipo", Hibernate.STRING)
							.addScalar("dataEmissao", Hibernate.DATE)
							.addScalar("idDebitoTipo", Hibernate.INTEGER)
							.addScalar("numeroPrestacoesDebito",
									Hibernate.SHORT)
							.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.setInteger("idCliente", idCliente)
							.setParameterList("idsImoveis", idsImoveis)
							.setInteger("situacaoNormal",
									new Integer(situacaoNormal))
							.setDate("inicialVencimento", dataVencimentoInicial)
							.setDate("finalVencimento", dataVencimentoFinal)
							.list();
				}

			} else {
				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idGuia", Hibernate.INTEGER)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("descricaoDebitoTipo", Hibernate.STRING)
						.addScalar("dataEmissao", Hibernate.DATE)
						.addScalar("idDebitoTipo", Hibernate.INTEGER)
						.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
						.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.setInteger("idCliente", idCliente)
						.setInteger("situacaoNormal",
								new Integer(situacaoNormal))
						.setDate("inicialVencimento", dataVencimentoInicial)
						.setDate("finalVencimento", dataVencimentoFinal).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem ralação fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdImoveisClienteSemRelacaoFim(
			String codigoCliente, Short relacaoTipo)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteImovel ci "
					+ "inner join ci.imovel imovel "
					+ "inner join ci.cliente cliente ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join ci.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta
					+ "where cliente.id = :codigo and ci.dataFimRelacao is null";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem ralação fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdImoveisClienteSuperiorSemRelacaoFim(
			Collection<Integer> idsCliente, Short clienteRelacaoTipo)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteImovel ci "
					+ "inner join ci.imovel imovel "
					+ "inner join ci.cliente cliente "
					+ "where ci.dataFimRelacao is null and "
					// (cliente.id =:codigo or cliente.cliente.id = :codigo) and
					+ "cliente.id in (:idsCliente) ";
			if (clienteRelacaoTipo != null
					&& !clienteRelacaoTipo.equals(new Short("99"))) {
				consulta = consulta + " and ci.clienteRelacaoTipo.id = "
						+ clienteRelacaoTipo;
			}

			retorno = session.createQuery(consulta)
					.setParameterList("idsCliente", idsCliente).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem ralação fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Relação Tipo Cliente Imovel
	 * @return Coleção de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosClienteResumido(String codigoCliente,
			String tipoRelacao, String anoMesInicial, String anoMesFinal,
			Date dataVencimentoDebitoInicial, Date dataVencimentoDebitoFinal)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT imov.imov_id as idImovel, "
					+ " sum( "
					+ " CASE "
					+ " WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null "
					+ " THEN conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - conta.cnta_vlimpostos "
					+ " END "
					+ " ) as valorDebito, 'CONTA' as tipoDebito "
					+ " FROM cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.conta conta "
					+ " on conta.imov_id = imov.imov_id and (conta.dcst_idatual = "
					+ DebitoCreditoSituacao.NORMAL.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.RETIFICADA.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.INCLUIDA.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.PARCELADA.toString()
					+ " ) "
					+ " left outer join arrecadacao.pagamento pagtoConta "
					+ " on conta.cnta_id = pagtoConta.cnta_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'CONTA' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum(dbac.dbac_vldebito - (trunc(dbac.dbac_vldebito/dbac.dbac_nnprestacaodebito, 2)*(dbac.dbac_nnprestacaocobradas + coalesce(dbac.dbac_nnparcelabonus,0)))) as valorDebito, "
					// +
					// " sum(dbac.dbac_vldebito - round(round(dbac.dbac_vldebito/dbac.dbac_nnprestacaodebito, 2)*dbac.dbac_nnprestacaocobradas, 2)) as valorDebito, "
					+ " 'DÉBITO A COBRAR' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.debito_a_cobrar dbac "
					+ " on dbac.imov_id = imov.imov_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'DÉBITO A COBRAR' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum( "
					+ " CASE "
					+ " WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null "
					+ " THEN gpag.gpag_vldebito "
					+ " END "
					+ " ) as valorDebito, 'GUIA DE PAGAMENTO' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.guia_pagamento gpag "
					+ " on gpag.imov_id = imov.imov_id "
					+ " left outer join arrecadacao.pagamento pagtoGuia "
					+ " on gpag.gpag_id = pagtoGuia.gpag_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'GUIA DE PAGAMENTO' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum(crar.crar_vlcredito - round(round(crar.crar_vlcredito/crar.crar_nnprestacaocredito, 2)*crar.crar_nnprestacaorealizadas, 2)) as valorDebito, "
					+ " 'CRÉDITO A REALIZAR' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.credito_a_realizar crar "
					+ " on crar.imov_id = imov.imov_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'CRÉDITO A REALIZAR' "
					+ " order by idImovel, tipoDebito ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("tipoDebito", Hibernate.STRING)
					.setInteger("codigo", new Integer(codigoCliente).intValue())
					.setInteger("anoMesInicial", new Integer(anoMesInicial))
					.setInteger("anoMesFinal", new Integer(anoMesFinal))
					.setDate("dataVencimentoDebitoInicial",
							dataVencimentoDebitoInicial)
					.setDate("dataVencimentoDebitoInicial",
							dataVencimentoDebitoFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * Obtem os parcelamentos de débitos efetuados que estejam com situação
	 * normal
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSituacaoNormal(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(parc) "
					+ "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc "
					+ "WHERE parc.imovel.id = :idImovel "
					+ "AND parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND dbac.numeroPrestacaoCobradas < (dbac.numeroPrestacaoDebito - coalesce(dbac.numeroParcelaBonus,0))  "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("parcelamentoSituacao",
							ParcelamentoSituacao.NORMAL)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarImovelParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "inner join dac.parcelamento parcelamento "
					+ "where parcelamento.id = :idParcelamento "
					+ "and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0))"
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id) "
					+ "and debitoTipo.id <> :debitoTipo ";

			retorno = session
					.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("debitoTipo",
							DebitoTipo.JUROS_SOBRE_PARCELAMENTO)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Creditos A Realizar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car,creditoTipo.descricao, creditoTipo.id "
					+ "from CreditoARealizar car "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join car.creditoTipo creditoTipo "
					+ "inner join car.parcelamento parcelamento "
					+ "where parcelamento.id = :idParcelamento "
					+ "and (car.numeroPrestacaoRealizada < (car.numeroPrestacaoCredito "
					+ " - coalesce(car.numeroParcelaBonus,0)) or "
					+ "car.valorResidualMesAnterior > 0) "
					+ "and car.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Sávio Luiz, Raphael Rossiter
	 * @data 26/05/2006, 04/01/2008
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitirCAER(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento as cbdo "
					+ "LEFT JOIN fetch cbdo.empresa as empr "
					+ "LEFT JOIN fetch cbdo.localidade as loca "
					+ "LEFT JOIN fetch loca.unidadeNegocio as uneg "
					+ "LEFT JOIN fetch loca.enderecoReferencia as enderecoReferenciaLocalidade "
					+ "LEFT JOIN fetch loca.logradouroCep as logCepLocalidade "
					+ "LEFT JOIN fetch logCepLocalidade.cep as cepLocalidade "
					+ "LEFT JOIN fetch logCepLocalidade.logradouro as logLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTipo as logTipoLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTitulo as logTituloLocalidade "
					+ "LEFT JOIN fetch loca.logradouroBairro as logBairroLocalidade "
					+ "LEFT JOIN fetch logBairroLocalidade.bairro as bairroLocalidade "
					+ "LEFT JOIN fetch bairroLocalidade.municipio as municipioLocalidade "
					+ "LEFT JOIN fetch municipioLocalidade.unidadeFederacao as unidadeFederacaoLocalidade "
					+ "LEFT JOIN fetch cbdo.imovel as imov "
					+ "LEFT JOIN fetch imov.leituraAnormalidade as ltan "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro "
					+ "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun "
					+ "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep "
					+ "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo "
					+ "LEFT JOIN fetch log.logradouroTitulo "
					+ "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia "
					+ "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo "
					+ "LEFT JOIN fetch cbdo.imovelPerfil "
					+ "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional "
					+ "LEFT JOIN fetch imov.ligacaoAgua.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN fetch hih.hidrometro "
					+ "LEFT JOIN fetch hih.hidrometroLocalInstalacao "
					+ "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY loca.id, cbdo.codigoSetorComercial, rot.codigo, imov.numeroSequencialRota, "
					+ "cbdo.numeroQuadra, imov.lote, imov.subLote, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(
					session.createQuery(consulta)
							.setInteger("idCorteAdministrativoOUFisico",
									idCobrancaAcao)
							.setTimestamp("dataEmissao", dataEmissao)
							.setFirstResult(quantidadeCobrancaDocumentoInicio)
							.setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 01/09/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer verificarRDUtilizadaPeloImovel(Integer idRD, Integer idImovel)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select parc.id "
					+ "from Parcelamento parc "
					+ "left join parc.resolucaoDiretoria rd "
					+ "where parc.imovel.id = :idImovel "
					+ "and rd.id = :idRD "
					+ "and rd.indicadorParcelamentoUnico = :indicadorParcelamentoUnico "
					+ "and parc.parcelamentoSituacao = :parcelamentoSituacao ";

			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idRD", idRD)
					.setShort("indicadorParcelamentoUnico",
							ConstantesSistema.SIM)
					.setInteger("parcelamentoSituacao",
							ParcelamentoSituacao.NORMAL).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * (DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta a ser
	 * parcelada ocorrendo na tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar Única Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterDebitoTipoDeFiscalizacaoSituacaoServicoACobrar(
			Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select fiscalizacao.debitoTipo.id "
					+ "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in "
					+ "(select debitoCobrado.debitoTipo "
					+ "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 01/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoACobrarSancoes(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum (dbac.dbac_vldebito) as valorDebito"
					+ " from faturamento.debito_a_cobrar  dbac where dbac.imov_id = :idImovel and"
					+ " (dbac.dbtp_id = :sancoesRegulamentares or "
					+ " dbac.dbtp_id = :multaPorInfracao or "
					+ " dbac.dbtp_id = :instalSubstHidrometro or "
					+ " dbac.dbtp_id = :consumoNaoContabilizado) "
					+ " and dbac.dbac_nnprestacaocobradas < dbac.dbac_nnprestacaodebito "
					+ " and dbac.dcst_idatual = :normal "
					+ " and dbac.dbac_amreferenciadebito >= :anoMesInicialReferenciaDebito "
					+ " and dbac.dbac_amreferenciadebito <= :anoMesFinalReferenciaDebito ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("sancoesRegulamentares",
							DebitoTipo.SANCOES_REGULAMENTARES)
					.setInteger("multaPorInfracao",
							DebitoTipo.MULTA_POR_INFRACAO)
					.setInteger("consumoNaoContabilizado",
							DebitoTipo.CONSUMO_NAO_CONTABILIZADO)
					.setInteger("instalSubstHidrometro",
							DebitoTipo.INSTAL_SUBST_HIDROMETRO)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 06/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoACobrar(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum (dbac.dbac_vldebito) as valorDebito"
					+ " from faturamento.debito_a_cobrar  dbac where dbac.imov_id = :idImovel and"
					+ " (dbac.dbtp_id = :atualizacaoMonetaria or "
					+ " dbac.dbtp_id = :jurosMora or "
					+ " dbac.dbtp_id = :multaImpontualidade or "
					+ " dbac.dbtp_id = :acrescImpontualidade )"
					+ " and dbac.dbac_nnprestacaocobradas < (dbac.dbac_nnprestacaodebito - coalesce(dbac.dbac_nnparcelabonus,0)) "
					+ " and dbac.dcst_idatual = :normal "
					// +
					// " and dbac.dbac_amreferenciadebito >= :anoMesInicialReferenciaDebito "
					// +
					// " and dbac.dbac_amreferenciadebito <= :anoMesFinalReferenciaDebito ";
					// alterado por Vivianne Sousa 11/09/2008
					// analista Adriano
					+ " and dbac.dbac_amcobrancadebito >= :anoMesInicialReferenciaDebito "
					+ " and dbac.dbac_amcobrancadebito <= :anoMesFinalReferenciaDebito ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("atualizacaoMonetaria",
							DebitoTipo.ATUALIZACAO_MONETARIA)
					.setInteger("jurosMora", DebitoTipo.JUROS_MORA)
					.setInteger("multaImpontualidade",
							DebitoTipo.MULTA_IMPONTUALIDADE)
					.setInteger("acrescImpontualidade",
							DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * Faz parte de [UC0067] Obter Débito do Imóvel ou Cliente Obtem os débitos
	 * total de um cliente
	 */
	public Collection pesquisarDebitosCliente(Integer idCliente,
			Short relacaoTipo, Collection idsImoveis, int indicadorPagamento,
			int indicadorConta, String contaSituacaoNormal,
			String contaSituacaoRetificada, String contaSituacaoIncluida,
			String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento,  "
					+ "conta.iper_id as imovelPerfil, categoria.catg_iccobrancaacrescimos as icAcrescimos "
					+ "FROM cadastro.cliente_conta clieConta "
					+ "INNER JOIN faturamento.conta conta on conta.cnta_id = clieConta.cnta_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "INNER JOIN cadastro.imovel imovel on imovel.imov_id = conta.imov_id "
					+ "INNER JOIN cadastro.categoria categoria on categoria.catg_id = imovel.imov_idcategoriaprincipal "					
					+ "WHERE clieConta.clie_id = :idCliente "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (relacaoTipo != null) {
				consulta += "and clieConta.crtp_id = " + relacaoTipo.toString();
			}

			consulta += " GROUP BY conta.iper_id, conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id, categoria.catg_iccobrancaacrescimos ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " UNION ";

			consulta += "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento, "
					+ "conta.iper_id as imovelPerfil, categoria.catg_iccobrancaacrescimos as icAcrescimos "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "INNER JOIN cadastro.imovel imovel on imovel.imov_id = conta.imov_id "
					+ "INNER JOIN cadastro.categoria categoria on categoria.catg_id = imovel.imov_idcategoriaprincipal "
					+ "WHERE conta.imov_id in (:idsImoveis) "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciacontabil is null ";
			}

			consulta += " GROUP BY conta.iper_id, conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id, categoria.catg_iccobrancaacrescimos  ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";
			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createSQLQuery(consulta)
							.addScalar("idConta", Hibernate.INTEGER)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("dataRevisao", Hibernate.DATE)
							.addScalar("referencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("idSituacaoAtual", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT)
							.addScalar("idMotivoRevisao", Hibernate.INTEGER)
							.addScalar("ultimaAlteracao", Hibernate.DATE)
							.addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("consumoEsgoto", Hibernate.INTEGER)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("idParcelamento", Hibernate.INTEGER)
							.addScalar("imovelPerfil", Hibernate.INTEGER)
							.addScalar("icAcrescimos", Hibernate.INTEGER)							
							.setInteger("idCliente", idCliente)
							.setParameterList("idsImoveis", particoes.get(i))
							.setInteger("situacaoNormal",
									new Integer(contaSituacaoNormal))
							.setInteger("situacaoRetificada",
									new Integer(contaSituacaoRetificada))
							.setInteger("situacaoIncluida",
									new Integer(contaSituacaoIncluida))
							.setInteger("situacaoParcelada",
									new Integer(contaSituacaoParcelada))
							.setInteger("inicialReferencia",
									new Integer(anoMesInicialReferenciaDebito))
							.setInteger("finalReferencia",
									new Integer(anoMesFinalReferenciaDebito))
							.setDate("inicialVencimento",
									anoMesInicialVecimentoDebito)
							.setDate("finalVencimento",
									anoMesFinalVencimentoDebito).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("imovelPerfil", Hibernate.INTEGER)
						.addScalar("icAcrescimos", Hibernate.INTEGER)
						.setInteger("idCliente", idCliente)
						.setParameterList("idsImoveis", idsImoveis)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia",
								new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia",
								new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 14/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoCobradoContas(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum(dbcb_vlprestacao) as valorDebito"
					+ " from faturamento.debito_cobrado dbcb"
					+ " where dbcb.cnta_id in "
					+ "    (select cnta_id from faturamento.conta c where imov_id = :idImovel and"
					+ " 	cnta_amreferenciaconta >= :anoMesInicialReferenciaDebito "
					+ "     and cnta_amreferenciaconta <= :anoMesFinalReferenciaDebito"
					+ "		and not exists (select pgmt_id from arrecadacao.pagamento p where c.cnta_id = p.cnta_id)"
					+ "     and(dcst_idatual = :situacaoNormal "
					+ "     or dcst_idatual = :situacaoRetificada "
					+ "     or dcst_idatual = :situacaoIncluida )";

			if (indicadorDividaAtiva == 1) {
				consulta += " and cnta_amrerenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += " and cnta_amrerenciacontabil is null ";
			}

			consulta += ") and (dbcb.dbtp_id = :atualizacaoMonetaria or dbcb.dbtp_id = :jurosMora or "
					+ "dbcb.dbtp_id = :multaImpontualidade or dbcb.dbtp_id = :acrescImpontualidade) ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("atualizacaoMonetaria",
							DebitoTipo.ATUALIZACAO_MONETARIA)
					.setInteger("jurosMora", DebitoTipo.JUROS_MORA)
					.setInteger("multaImpontualidade",
							DebitoTipo.MULTA_IMPONTUALIDADE)
					.setInteger("acrescImpontualidade",
							DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada",
							DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida",
							DebitoCreditoSituacao.INCLUIDA).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 20/09/2007
	 * 
	 * @param idImovel
	 * @param anoMesInicialReferenciaDebito
	 * @param anoMesFinalReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoCobradoSancoes(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = " select sum(dbcb_vlprestacao) valorDebito "
					+ " from faturamento.debito_cobrado dbcb "
					+ " where dbcb.cnta_id in "
					+ " (select cnta_id from faturamento.conta where imov_id = :idImovel and "
					+ " cnta_amreferenciaconta >= :anoMesInicialReferenciaDebito "
					+ " and cnta_amreferenciaconta <= :anoMesFinalReferenciaDebito "
					+ " and (dcst_idatual = :situacaoNormal "
					+ " or dcst_idatual = :situacaoRetificada "
					+ " or dcst_idatual = :situacaoIncluida )  ";

			if (indicadorDividaAtiva == 1) {
				consulta += " and cnta_amrerenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += " and cnta_amrerenciacontabil is null ";
			}

			consulta += ") and (dbcb.dbtp_id = :sancoesRegulamentares or "
					+ " dbcb.dbtp_id = :multaPorInfracao or "
					+ " dbcb.dbtp_id = :consumoNaoContabilizado or "
					+ " dbcb.dbtp_id = :instalSubstHidrometro) ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("sancoesRegulamentares",
							DebitoTipo.SANCOES_REGULAMENTARES)
					.setInteger("multaPorInfracao",
							DebitoTipo.MULTA_POR_INFRACAO)
					.setInteger("consumoNaoContabilizado",
							DebitoTipo.CONSUMO_NAO_CONTABILIZADO)
					.setInteger("instalSubstHidrometro",
							DebitoTipo.INSTAL_SUBST_HIDROMETRO)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada",
							DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida",
							DebitoCreditoSituacao.INCLUIDA).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0701] Informar Índices dos Acréscimos de Impontualidade
	 * 
	 * @author Sávio Luiz
	 * @created 26/09/2007
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMaximoAnoMesIndicesAcerscimosImpontualidade()
			throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {
			consulta = " select max(anoMesReferencia)  "
					+ " from IndicesAcrescimosImpontualidade ";

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * Retorna uma colecao de Debitos por Faixa de Valores dos Imoveis
	 * 
	 * @author Ivan Sergio
	 * @created 20/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoImovelPorFaixaValores(String idImovel,
			String valorMinimoDebito, String anoMesReferenciaInicial,
			String anoMesReferenciaFinal, String classificacao,
			boolean pesquisaMunicipio) throws ErroRepositorioException {

		String sql;
		String orderBy;
		String joinMunicipio = " LEFT JOIN cadastro.municipio muni on muni.muni_id = loca.muni_idprincipal ";
		if (pesquisaMunicipio) {
			joinMunicipio = " INNER JOIN cadastro.municipio muni on muni.muni_id = loca.muni_idprincipal ";
		}
		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {
			sql = "SELECT "
					+ "	dfv.dfvl_vlfaixainicio as faixaInicial, "
					+ "	dfv.dfvl_vlfaixafim as faixaFinal, "
					+ "	dfv.dfvl_id as idFaixa, "
					+ "	count( temp.idImovel ) as quantidadeLigacoes, "
					+ "	sum( temp.totalDebitos ) as total, "
					+ "	sum( temp.qtdeDebitos ) as qtdeDocumentos, "
					+ "	temp.idGerencia as idGerencia, "
					+ "	temp.nomeGerencia as nomeGerencia, "
					+ "	temp.idLocalidade as idLocalidade, "
					+ "	temp.nomeLocalidade as nomeLocalidade, "
					+ "	temp.idSetor as idSetor, "
					+ "	temp.codigoSetor as codigoSetor, "
					+ "	temp.nomeSetor as nomeSetor, "
					+ " 	temp.idMunicipio as idMunicipio, "
					+ " 	temp.nomeMunicipio as nomeMunicipio "
					+ "FROM "
					+ "	faturamento.debito_faixa_valores dfv "
					+ "	LEFT OUTER JOIN( "
					+ "		SELECT	debitos.idImovel, "
					+ "			    gerencia.greg_id as idGerencia, "
					+ "				gerencia.greg_nmabreviado as nomeGerencia, "
					+ "				loca.loca_id as idLocalidade, "
					+ "				loca.loca_nmlocalidade as nomeLocalidade, "
					+ "				setor.stcm_id as idSetor, "
					+ "				setor.stcm_cdsetorcomercial as codigoSetor, "
					+ "				setor.stcm_nmsetorcomercial as nomeSetor, "
					+ "				sum( debitos.valorDebitos ) as totalDebitos, "
					+ "				sum( debitos.qtdeDebitos )  as qtdeDebitos, "
					+ "				muni.muni_id as idMunicipio, "
					+ "				muni.muni_nmmunicipio as nomeMunicipio "
					+ "		FROM ("
					+ "			SELECT imov.imov_id as idImovel, "
					+ "					'CONTA' as tipoDebito, "
					+ "					sum( "
					+ "						CASE WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null THEN "
					+ "							conta.cnta_vlagua + "
					+ "							conta.cnta_vlesgoto + "
					+ "							conta.cnta_vldebitos - "
					+ "							conta.cnta_vlcreditos - "
					+ "							coalesce( conta.cnta_vlimpostos, 0 ) "
					+ "						ELSE "
					+ "							0.00 "
					+ "						END "
					+ "					) as valorDebitos, "
					+ "					count( "
					+ "						CASE WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null THEN "
					+ "							conta.cnta_id " + "						END "
					+ "					) as qtdeDebitos " + "			FROM "
					+ "				cadastro.imovel imov "
					+ "				LEFT OUTER JOIN faturamento.conta conta "
					+ "					on conta.imov_id = imov.imov_id and "
					+ "					conta.dcst_idatual in ( 0, 1, 2 ) "
					+ "				LEFT OUTER JOIN arrecadacao.pagamento pagtoConta "
					+ "					on conta.cnta_id = pagtoConta.cnta_id "
					+ "			WHERE " + "				(conta.cnta_amreferenciaconta >= "
					+ anoMesReferenciaInicial
					+ " and "
					+ "				conta.cnta_amreferenciaconta <= "
					+ anoMesReferenciaFinal
					+ ") and "
					+ "				imov.imov_id in ( "
					+ idImovel
					+ " ) "
					+ "			GROUP BY "
					+ "				imov.imov_id, "
					+ "				'CONTA' "
					+ "			UNION "
					+

					"			SELECT "
					+ "				imov.imov_id as idImovel, "
					+ "				'GUIA' as tipoDebito, "
					+ "				sum( "
					+ "					CASE WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null THEN "
					+ "						gpag.gpag_vldebito "
					+ "					ELSE "
					+ "						0.00 "
					+ "					END "
					+ "				) as valorDebitos, "
					+ "				count( "
					+ "					CASE WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null THEN "
					+ "						gpag.gpag_id "
					+ "					END "
					+ "				) as qtdeDebitos "
					+ "			FROM "
					+ "				cadastro.imovel imov "
					+ "				LEFT OUTER JOIN faturamento.guia_pagamento gpag "
					+ "					on gpag.imov_id = imov.imov_id "
					+ "				LEFT OUTER JOIN arrecadacao.pagamento pagtoGuia "
					+ "					on gpag.gpag_id = pagtoGuia.gpag_id "
					+ "			WHERE "
					+ "				(gpag.gpag_amreferenciacontabil >= "
					+ anoMesReferenciaInicial
					+ " and "
					+ "				gpag.gpag_amreferenciacontabil <= "
					+ anoMesReferenciaFinal
					+ ") and "
					+ "				imov.imov_id in ( "
					+ idImovel
					+ " ) "
					+ "			GROUP BY "
					+ "				imov.imov_id, "
					+ " 				'GUIA' "
					+ "		) debitos "
					+ "		INNER JOIN cadastro.imovel imov "
					+ "			on debitos.idImovel = imov.imov_id "
					+ "		INNER JOIN cadastro.setor_comercial setor "
					+ "			on imov.stcm_id = setor.stcm_id "
					+ "		INNER JOIN cadastro.localidade loca "
					+ "			on imov.loca_id = loca.loca_id "
					+ joinMunicipio
					+ "		INNER JOIN cadastro.gerencia_regional gerencia "
					+ "			on loca.greg_id = gerencia.greg_id "
					+ "		WHERE "
					+ "			debitos.valorDebitos is null or "
					+ "			debitos.valorDebitos > 0 "
					+ "		GROUP BY "
					+ "			debitos.idImovel, "
					+ "			gerencia.greg_id, "
					+ "			gerencia.greg_nmabreviado, "
					+ "			loca.loca_id, "
					+ "			loca.loca_nmlocalidade, "
					+ "			setor.stcm_id, "
					+ "			setor.stcm_cdsetorcomercial, "
					+ "			setor.stcm_nmsetorcomercial, "
					+ "			muni.muni_id, "
					+ "			muni.muni_nmmunicipio "
					+ "		) temp "
					+ "	on temp.totalDebitos between dfv.dfvl_vlfaixainicio and dfv.dfvl_vlfaixafim "
					+ "WHERE "
					+ "	temp.totalDebitos > "
					+ valorMinimoDebito
					+ " "
					+ "GROUP BY "
					+ "	temp.idGerencia, "
					+ "	temp.nomeGerencia, "
					+ "	temp.idLocalidade, "
					+ "	temp.nomeLocalidade, "
					+ "	temp.idSetor, "
					+ "	temp.codigoSetor, "
					+ "	temp.nomeSetor, "
					+ "	dfv.dfvl_vlfaixainicio, "
					+ "	dfv.dfvl_vlfaixafim, "
					+ "	dfv.dfvl_id, "
					+ "	temp.idMunicipio, "
					+ "	temp.nomeMunicipio " + "ORDER BY ";

			// Classificacao
			orderBy = "";
			if (classificacao.trim().equalsIgnoreCase("ESTADO")) {
				orderBy = "	dfv.dfvl_id, " + "	temp.idGerencia, "
						+ "	temp.idLocalidade, " + "	temp.idSetor";

			} else if (classificacao.trim().equalsIgnoreCase("REGIONAL")) {
				orderBy = "	temp.idGerencia, " + "	dfv.dfvl_id, "
						+ "	temp.idLocalidade, " + "	temp.idSetor";

			} else if (classificacao.trim().equalsIgnoreCase("LOCAL")) {
				orderBy = "	temp.idGerencia, " + "	temp.idLocalidade, "
						+ "	dfv.dfvl_id, " + "	temp.idSetor";
			} else if (classificacao.trim().equalsIgnoreCase("SETORCOMERCIAL")) {
				orderBy = "	temp.idGerencia, " + "	temp.idLocalidade, "
						+ "	temp.idSetor, " + "	dfv.dfvl_id";
			} else if (classificacao.trim().equalsIgnoreCase("MUNICIPIO")) {
				orderBy = "	temp.idGerencia, " + "	temp.idMunicipio, "
						+ "	dfv.dfvl_id, " + "	temp.idSetor";
			}

			sql += orderBy;

			retorno = session.createSQLQuery(sql)
					.addScalar("faixaInicial", Hibernate.BIG_DECIMAL)
					.addScalar("faixaFinal", Hibernate.BIG_DECIMAL)
					.addScalar("idFaixa", Hibernate.INTEGER)
					.addScalar("quantidadeLigacoes", Hibernate.INTEGER)
					.addScalar("total", Hibernate.BIG_DECIMAL)
					.addScalar("qtdeDocumentos", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("nomeGerencia", Hibernate.STRING)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("nomeSetor", Hibernate.STRING)
					.addScalar("idMunicipio", Hibernate.INTEGER)
					.addScalar("nomeMunicipio", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC0216] Calcular Acréscimo por Impontualidade
	 * 
	 * @autor: Raphael Rossiter
	 * 
	 *         Pesquisa os dados do Indices Acrescimo Impontualidade menor ao
	 *         ano mes referencia
	 * 
	 * @param anoMesReferenciaDebito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIndiceAcrescimoImpontualidade()
			throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select min(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2)";

			retorno = session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotas(String codigoSetorComercial,
			String rotaInicial, String rotaFinal, String idLocalidade,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where rota.codigo between :rotaInicial and :rotaFinal "
					+ " and setor.codigo = :setorComercial "
					+ " and localidade.id = :idLocalidade"
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idLocalidade", new Integer(idLocalidade))
					.setInteger("setorComercial",
							new Integer(codigoSetorComercial))
					.setInteger("rotaInicial", new Integer(rotaInicial))
					.setInteger("rotaFinal", new Integer(rotaFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloSetor(
			String codigoSetorComercialInicial,
			String codigoSetorComercialFinal, String idLocalidade,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where setor.codigo between :codigoSetorComercialInicial and :codigoSetorComercialFinal "
					+ " and localidade.id = :idLocalidade"
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idLocalidade", new Integer(idLocalidade))
					.setInteger("codigoSetorComercialInicial",
							new Integer(codigoSetorComercialInicial))
					.setInteger("codigoSetorComercialFinal",
							new Integer(codigoSetorComercialFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloLocalidade(
			String idLocalidadeInicial, String idLocalidadeFinal,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where localidade.id between :idLocalidadeInicial and :idLocalidadeFinal "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idLocalidadeInicial",
							new Integer(idLocalidadeInicial))
					.setInteger("idLocalidadeFinal",
							new Integer(idLocalidadeFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloGerencia(
			String idGerenciaRegional, String idCobrancaAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade"
					+ " inner join localidade.unidadeNegocio unidadeNegocio"
					+ " inner join unidadeNegocio.gerenciaRegional gerenciaRegional"
					+ " where gerenciaRegional.id = :idGerenciaRegional "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idGerenciaRegional",
							new Integer(idGerenciaRegional))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloGrupo(String idGrupoCobranca,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join rota.cobrancaGrupo cobrancaGrupo"
					+ " where cobrancaGrupo.id = :idGrupoCobranca "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idGrupoCobranca", new Integer(idGrupoCobranca))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Flávio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloUnidadeNegocio(
			String idUnidadeNegocio, String idCobrancaAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade"
					+ " inner join localidade.unidadeNegocio unidadeNegocio"
					+ " where unidadeNegocio.id = :idUnidadeNegocio "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idUnidadeNegocio",
							new Integer(idUnidadeNegocio))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasPorCobrancaAcao(String idCobrancaAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a variável que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " where rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio)
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @autor: Raphael Rossiter
	 * 
	 *         Verifica se existe uma devolução associada ao credito
	 * 
	 * @param creditoARealizar
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean existeDevolucao(CreditoARealizar creditoARealizar)
			throws ErroRepositorioException {

		Integer retornoHQL = null;
		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT devl.id " + "FROM Devolucao devl "
					+ "INNER JOIN devl.creditoARealizarGeral crar "
					+ "WHERE crar.id = :idCreditoARealizar ";

			retornoHQL = (Integer) session.createQuery(consulta)
					.setInteger("idCreditoARealizar", creditoARealizar.getId())
					.setMaxResults(1).uniqueResult();

			if (retornoHQL != null) {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Inserir Comando Negaivação
	 * 
	 * @autor: Ana Maria
	 * 
	 *         [FS0019] Verificar existência de Parcelamento
	 * 
	 * @param idImovel
	 * @return Cliente
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClienteResponsavelParcelamento(Integer idImovel)
			throws ErroRepositorioException {

		Cliente retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select clie " + "from Parcelamento parc "
					+ "inner join parc.cliente clie "
					+ "where parc.imovel.id = :idImovel "
					+ "order by parc.parcelamento desc ";

			retorno = (Cliente) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0200] Inserir Débito Automático
	 * 
	 * @autor Rodrigo Silveira
	 * @date 28/01/2008 [FS0006] Verificar Data de Opção já Excluída
	 * 
	 * @param matriculaImovel
	 * @param dataOpcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String verificarDataOpcaoJaExcluida(String matriculaImovel,
			Date dataOpcao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "where imovel.id = :matricula AND "
					+ "deb.dataExclusao is not null "
					+ "and deb.dataOpcaoDebitoContaCorrente = :data";

			retorno = session
					.createQuery(consultaDataOpcao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0737] Atualiza Quantdade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * Retorna dados dos parcelamentos com RD = 8 que estejam com situação
	 * normal e que não exista outro parcelamento com data posterior
	 * 
	 * @author Vivianne Sousa
	 * @date 31/01/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParcelamentoRDEspecial(
			Integer situacaoParcelamento, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "SELECT parc.parc_id as idParc, "
					+ " parc.parc_tmparcelamento as dataParc, "
					+ " parc_nnprestacoes as numeroPrestacoesParc, "
					+ " parc.imov_id as idImovel, "
					+ " parc.parc_nnparcelaspagasconsecs as numeroparcelaspagasconsecutiva "
					+ "FROM cobranca.parcelamento parc "
					+ "WHERE parc.rdir_id = :idRD "
					+ " AND parc.pcst_id = :situacaoParcelamento "
					+ " AND parc.loca_id = :idLocalidade "
					+ " AND parc.parc_tmparcelamento = "
					+ "      (SELECT max(parc_tmparcelamento) "
					+ "       FROM cobranca.parcelamento "
					+ "       WHERE imov_id = parc.imov_id) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idParc", Hibernate.INTEGER)
					.addScalar("dataParc", Hibernate.DATE)
					.addScalar("numeroPrestacoesParc", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("numeroparcelaspagasconsecutiva",
							Hibernate.SHORT).setInteger("idRD", 8)
					.setInteger("situacaoParcelamento", situacaoParcelamento)
					.setInteger("idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
	 * 
	 * @author Vivianne Sousa
	 * @created 07/02/2008
	 * 
	 * @param idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarNumeroParcelasPagasConsecutivasParcelamento(
			Integer idParcelamento, Short numeroParcelas)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaParcelamento;

		try {
			atualizaParcelamento = "update gcom.cobranca.parcelamento.Parcelamento "
					+ "set parc_nnparcelaspagasconsecs = :numeroParcelas, "
					+ "parc_tmultimaalteracao = :ultimaAlteracao  "
					+ "where parc_id = :idParcelamento";

			session.createQuery(atualizaParcelamento)
					.setInteger("idParcelamento", idParcelamento)
					.setShort("numeroParcelas", numeroParcelas)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0676] - Consultar Resumo da Negativacao
	 * 
	 * Pesquisa resumo Negativacao
	 * 
	 * @author Marcio Roberto
	 * @date 28/02/2008
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection consultarNegativacao(
			DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper,
			int tipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			switch (tipo) {
			case 1:
				// [SB0001] - Seleciona quantidade de negativações incluidas.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " where 1 = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by neg.id " + " order by neg.id ";
				break;
			case 2:
				// [SB0002] - Seleciona quantidade de negativações incluidas por
				// situação do Débito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " inner join re.cobrancaDebitoSituacao stcb "
						+ " where 1 = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao "
						+ " order by stcb.id, stcb.descricao ";
				break;

			case 3:
				// [SB0003] - Seleciona quantidade de negativações por situação
				// de Negativação - RNEG_ICNEGATIVCONFIRMADA = 1.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by neg.id " + " order by neg.id ";
				break;

			case 4:
				// [SB0003] - Seleciona quantidade de negativações por situação
				// de Negativação - RNEG_ICNEGATIVCONFIRMADA = 2.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 2 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by neg.id " + " order by neg.id ";
				break;

			case 5:
				// [SB0004] - Seleciona quantidade de negativações por situação
				// de Negativação e cobranca do Debito.
				// [SB0002] - Seleciona quantidade de negativações incluidas por
				// situação do Débito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " inner join re.cobrancaDebitoSituacao stcb "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao "
						+ " order by stcb.id, stcb.descricao ";
				break;
			case 6:
				// [SB0002] - Seleciona quantidade de negativações incluidas por
				// situação do Débito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " inner join re.cobrancaDebitoSituacao stcb "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 2 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao "
						+ " order by stcb.id, stcb.descricao ";
				break;
			default:
				break;
			}

			if (tipo == 2) {
				// tipo 2

			} else if (tipo == 1) {
				// tipo 1

			}

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * <Breve descrição sobre o subfluxo>
	 * 
	 * <Identificador e nome do subfluxo>
	 * 
	 * <Breve descrição sobre o fluxo secundário>
	 * 
	 * <Identificador e nome do fluxo secundário>
	 * 
	 * @author Márcio Roberto
	 * @date 07/05/2008
	 * 
	 * @param dadosConsultaNegativacaoHelper
	 * @return
	 */

	public String criarCondicionaisResumosHQL(
			DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper) {

		String sql = " ";
		String restricao = "";
		/*
		 * A partir daqui sera montanda a parte dos condicionais da query estas
		 * condicionais serão usadas se necessarias, o q determina seus usos são
		 * os parametros que veem carregados no objeto
		 * InformarDadosGeracaoRelatorioConsultaHelper que é recebido do caso de
		 * uso [UC0304] Informar Dados para Geração de Relatorio ou COnsulta
		 */
		if (dadosConsultaNegativacaoHelper != null) {

			// Inicio Parametros simples
			if (dadosConsultaNegativacaoHelper.getIdNegativador() != null) {
				sql = sql + " and re.negativador.id = "
						+ dadosConsultaNegativacaoHelper.getIdNegativador();
			} else {
				if (dadosConsultaNegativacaoHelper.getColecaoNegativador() != null
						&& !dadosConsultaNegativacaoHelper
								.getColecaoNegativador().isEmpty()) {
					boolean consulta = true;
					if (dadosConsultaNegativacaoHelper.getColecaoNegativador()
							.size() == 1) {
						Iterator it = dadosConsultaNegativacaoHelper
								.getColecaoNegativador().iterator();
						while (it.hasNext()) {
							Negativador obj = (Negativador) it.next();
							if (obj != null && obj.getId() == -1) {
								consulta = false;
							}
						}
					}
					if (consulta) {
						Iterator iterator = dadosConsultaNegativacaoHelper
								.getColecaoNegativador().iterator();
						Negativador negativador = null;
						restricao = restricao + " and re.negativador.id  in (";
						while (iterator.hasNext()) {
							negativador = (Negativador) iterator.next();
							restricao = restricao + negativador.getId() + ",";
						}
						restricao = Util.removerUltimosCaracteres(restricao, 1);
						restricao = restricao + ") ";
					}
				}
			}

			// if
			// (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoInicio()
			// != null) {
			// if
			// (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoFim()
			// != null) {
			// sql = sql
			// +
			// " and (re.dataProcessamentoEnvio >= '"+Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
			// .getPeriodoEnvioNegativacaoInicio())+"'"
			// +
			// " and re.dataProcessamentoEnvio <= '"+Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
			// .getPeriodoEnvioNegativacaoFim())+"'"
			// + ")";
			// }
			//
			// }

			if (dadosConsultaNegativacaoHelper
					.getPeriodoEnvioNegativacaoInicio() != null
					&& dadosConsultaNegativacaoHelper
							.getPeriodoEnvioNegativacaoFim() != null) {
				sql = sql
						+ " and (re.dataProcessamentoEnvio >= to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
								.getPeriodoEnvioNegativacaoInicio())
						+ "','YYYY-MM-DD')"
						+ " and re.dataProcessamentoEnvio <= to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
								.getPeriodoEnvioNegativacaoFim())
						+ "','YYYY-MM-DD')" + ")";

			} else {
				if (dadosConsultaNegativacaoHelper
						.getPeriodoEnvioNegativacaoInicio() != null) {
					sql = sql
							+ " and re.dataProcessamentoEnvio >= '"
							+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
									.getPeriodoEnvioNegativacaoInicio()) + "'";
				}
				if (dadosConsultaNegativacaoHelper
						.getPeriodoEnvioNegativacaoFim() != null) {
					sql = sql
							+ " and re.dataProcessamentoEnvio <= '"
							+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
									.getPeriodoEnvioNegativacaoFim()) + "'";
				}
			}

			if (dadosConsultaNegativacaoHelper
					.getNumeroExecucaoResumoNegativacao() != null) {
				sql = sql
						+ " and re.numeroExecucaoResumoNegativacao = "
						+ dadosConsultaNegativacaoHelper
								.getNumeroExecucaoResumoNegativacao();
			}

			if (dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoCobrancaGrupo().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoCobrancaGrupo().iterator();
					while (it.hasNext()) {
						CobrancaGrupo obj = (CobrancaGrupo) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoCobrancaGrupo().iterator();
					CobrancaGrupo cobrancaGrupo = null;
					restricao = restricao + " and re.cobrancaGrupo.id in (";
					while (iterator.hasNext()) {
						cobrancaGrupo = (CobrancaGrupo) iterator.next();
						restricao = restricao + cobrancaGrupo.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoGerenciaRegional().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoGerenciaRegional().iterator();
					while (it.hasNext()) {
						GerenciaRegional gerReg = (GerenciaRegional) it.next();
						if (gerReg != null && gerReg.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoGerenciaRegional().iterator();
					GerenciaRegional gerenciaRegional = null;
					restricao = restricao + " and re.gerenciaRegional.id in (";
					while (iterator.hasNext()) {
						gerenciaRegional = (GerenciaRegional) iterator.next();
						restricao = restricao + gerenciaRegional.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoUnidadeNegocio().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoUnidadeNegocio().iterator();
					while (it.hasNext()) {
						UnidadeNegocio obj = (UnidadeNegocio) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoUnidadeNegocio().iterator();
					UnidadeNegocio unidadeNegocio = null;
					restricao = restricao + " and re.unidadeNegocio.id in (";
					while (iterator.hasNext()) {
						unidadeNegocio = (UnidadeNegocio) iterator.next();
						restricao = restricao + unidadeNegocio.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";

				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoCategoria() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoCategoria()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoCategoria().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoCategoria().iterator();
					while (it.hasNext()) {
						Categoria obj = (Categoria) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoCategoria().iterator();
					Categoria categoria = null;
					restricao = restricao + " and re.categoria.id in (";
					while (iterator.hasNext()) {
						categoria = (Categoria) iterator.next();
						restricao = restricao + categoria.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoClienteTipo() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoClienteTipo()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoClienteTipo()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoClienteTipo().iterator();
					while (it.hasNext()) {
						ClienteTipo obj = (ClienteTipo) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoClienteTipo().iterator();
					ClienteTipo clienteTipo = null;
					restricao = restricao + " and re.clienteTipo.id in (";
					while (iterator.hasNext()) {
						clienteTipo = (ClienteTipo) iterator.next();
						restricao = restricao + clienteTipo.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoEsferaPoder() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoEsferaPoder()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoEsferaPoder()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoEsferaPoder().iterator();
					while (it.hasNext()) {
						EsferaPoder obj = (EsferaPoder) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoEsferaPoder().iterator();
					EsferaPoder esferaPoder = null;
					restricao = restricao + " and re.esferaPoder.id  in (";
					while (iterator.hasNext()) {
						esferaPoder = (EsferaPoder) iterator.next();
						restricao = restricao + esferaPoder.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			// *******************************************************
			// RM3755
			// Autor: Ivan Sergio
			// Data: 14/01/2011
			// "or" por se LEFT
			// *********************************************************
			if (dadosConsultaNegativacaoHelper.getColecaoLigacaoAguaSituacao() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoLigacaoAguaSituacao().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper
						.getColecaoLigacaoAguaSituacao().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoLigacaoAguaSituacao().iterator();
					while (it.hasNext()) {
						LigacaoAguaSituacao obj = (LigacaoAguaSituacao) it
								.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoLigacaoAguaSituacao().iterator();
					LigacaoAguaSituacao ligacaoAguaSituacao = null;
					restricao = restricao
							+ " or re.ligacaoAguaSituacao.id  in (";
					while (iterator.hasNext()) {
						ligacaoAguaSituacao = (LigacaoAguaSituacao) iterator
								.next();
						restricao = restricao + ligacaoAguaSituacao.getId()
								+ ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}
			// *******************************************************

			if (dadosConsultaNegativacaoHelper.getColecaoImovelPerfil() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoImovelPerfil()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoImovelPerfil()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoImovelPerfil().iterator();
					while (it.hasNext()) {
						ImovelPerfil obj = (ImovelPerfil) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoImovelPerfil().iterator();
					ImovelPerfil imovelPerfil = null;
					restricao = restricao + " and re.imovelPerfil.id  in (";
					while (iterator.hasNext()) {
						imovelPerfil = (ImovelPerfil) iterator.next();
						restricao = restricao + imovelPerfil.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getIdEloPolo() != null) {
				sql = sql + " and re.localidade.localidade.id = "
						+ dadosConsultaNegativacaoHelper.getIdEloPolo();
			}

			if (dadosConsultaNegativacaoHelper.getIdLocalidade() != null) {
				sql = sql + " and re.localidade.id = "
						+ dadosConsultaNegativacaoHelper.getIdLocalidade();
			}

			if (dadosConsultaNegativacaoHelper.getIdSetorComercial() != null) {
				sql = sql + " and re.setorComercial.id = "
						+ dadosConsultaNegativacaoHelper.getIdSetorComercial();
			}

			if (dadosConsultaNegativacaoHelper.getIdQuadra() != null) {
				sql = sql + " and re.quadra.id = "
						+ dadosConsultaNegativacaoHelper.getIdQuadra();
			}

			// if (dadosConsultaNegativacaoHelper.getIdGrupoCobranca() != null)
			// {
			// sql = sql
			// + " and re.cobrancaGrupo.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdGrupoCobranca();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdGerenciaRegional() !=
			// null) {
			// sql = sql
			// + " and re.gerenciaRegional.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdGerenciaRegional();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdImovelPerfil() != null) {
			// sql = sql
			// + " and re.imovelPerfil.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdImovelPerfil();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdCategoria() != null) {
			// sql = sql
			// + " and re.categoria.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdCategoria();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdEsferaPoder() != null) {
			// sql = sql
			// + " and re.esferaPoder.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdEsferaPoder();
			// }
		}

		String retorno = sql + restricao;

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * [SB0001] - Processar Documentos Cobrança Consultar os documentos de
	 * cobranca sem carregar os criterios de cobranca
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos,Sávio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 22/05/2008, 08/07/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoResumoAcaoCobranca(
			int idCobrancaAtividadeAcaoCronograma,
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id, "
					+ "cobrancaDocumento.emissao, "
					+ "cobrancaDocumento.imovel.id, "
					+ "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.id, "
					+ "cas.id, "
					+ "loc.id, "
					+ "cobrancaDocumento.categoria.id, "
					+ "cobrancaDocumento.esferaPoder.id, "
					+ "cobrancaDocumento.cobrancaDebitoSituacao.id ) "
					+ "from CobrancaDocumento cobrancaDocumento "
					+ "left join cobrancaDocumento.localidade loc "
					+ "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "left join cobrancaDocumento.cobrancaAcaoSituacao cas "
					+ (idCobrancaAtividadeAcaoCronograma != ConstantesSistema.NUMERO_NAO_INFORMADO ? "where cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id = :idCobrancaAtividadeAcaoCronograma "
							: "where cobrancaDocumento.cobrancaAcaoAtividadeComando.id = :idCobrancaAtividadeAcaoComando ")
					// +
					// " and (cobrancaDocumento.cobrancaDebitoSituacao is null or "
					// + "      cobrancaDocumento.cobrancaDebitoSituacao.id = "
					// + CobrancaDebitoSituacao.PENDENTE + " ) "
					+ "order by cobrancaDocumento.id";

			if (idCobrancaAtividadeAcaoCronograma != ConstantesSistema.NUMERO_NAO_INFORMADO) {
				retorno = session
						.createQuery(consulta)
						.setInteger("idCobrancaAtividadeAcaoCronograma",
								idCobrancaAtividadeAcaoCronograma).list();
			} else {
				retorno = session
						.createQuery(consulta)
						.setInteger("idCobrancaAtividadeAcaoComando",
								idCobrancaAtividadeAcaoComando).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das ações de cobrança com a
	 * atividade emitir já realizada e a atividade encerrar ainda não realizada
	 * e realizar a atividade encerrar das ações que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobrança Eventual Consultar os documentos
	 * de cobranca sem carregar os criterios de cobranca
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CACM_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_COMANDO
	 * 
	 * @author Rafael Santos,Sávio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 04/06/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoEventualSemCriterio(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cbdo_id as idCobrancaDocumento, "
					+ // 0
					"cbdo_tmemissao as emissao, "
					+ // 1
					"imov_id as idImovel, "
					+ // 2
					"cbdo_vldocumento as valorDocumento, "
					+ // 3
					"cbct_id as idCriterio, "
					+ // 4
					"cast_id as idSituacaoAcao " // 5
					+ " from cobranca.cobranca_documento cobranca"
					+ " where cacm_id = :idCobrancaAtividadeAcaoComando ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("emissao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("idCriterio", Hibernate.INTEGER)
					.addScalar("idSituacaoAcao", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Método para atualizar a situacao do documento item de acordo com a
	 * situacao da conta / guia de pagamento / debito a cobrar. Este método será
	 * usado nos métodos cancelar/desfazer cancelamento conta, incluir /
	 * desfazer parcelamento, incluir / excluir pagamento, movimento de
	 * arrecadadores
	 * 
	 * @param situacaoDebito
	 * @param dataSituacao
	 * @param idConta
	 * @param idGuiaPagamento
	 * @param idDebitoACobrar
	 * @throws ErroRepositorioException
	 * 
	 * @author Francisco do Nascimento
	 * @date 26/05/2008
	 * 
	 */
	public void atualizarSituacaoCobrancaDocumentoItem(Integer situacaoDebito,
			Date dataSituacao, Integer idConta, Integer idGuiaPagamento,
			Integer idDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		// Atualizar apenas o item do documento do cobranca com a maior data de
		// emissao
		String queryAtualizar = "";
		String queryConsultar = "";
		try {

			/*
			 * * Alteração em 10/02/09 Por Francisco / Ana Breda Alterado para
			 * atualizar apenas itens contidos em documentos do tipo Aviso de
			 * corte, corte administrativo e corte fisico, por conta do Resumo
			 * de Ação de cobrança.
			 */
			String dataSituacaoParaSQL = Util
					.formatarDataComTracoAAAAMMDD(dataSituacao);

			queryConsultar = "select cobrancado1_.cdit_id as idItem "
					+ " from cobranca.cobranca_documento_item cobrancado1_ "
					+ " inner join cobranca.cobranca_documento cobrancado0_ on cobrancado0_.cbdo_id = cobrancado1_.cbdo_id ";

			if (idConta != null) {

				queryConsultar = queryConsultar
						+ " inner join (select conta3_.cnta_id as idConta "
						+ " from faturamento.conta conta2_, faturamento.conta conta3_ "
						+ " where conta2_.cnta_id = "
						+ idConta
						+ " and conta2_.imov_id = conta3_.imov_id "
						+ " and conta2_.cnta_amreferenciaconta = conta3_.cnta_amreferenciaconta) conta on conta.idConta = cobrancado1_.cnta_id ";

				queryConsultar = queryConsultar
						+ " where cobrancado0_.dotp_id <> "
						+ DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('"
						+ dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS')  ";
			} else if (idGuiaPagamento != null) {

				queryConsultar = queryConsultar
						+ " where cobrancado0_.dotp_id <> "
						+ DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('"
						+ dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS') "
						+ "and cobrancado1_.gpag_id = " + idGuiaPagamento;
			} else if (idDebitoACobrar != null) {

				queryConsultar = queryConsultar
						+ " where cobrancado0_.dotp_id <> "
						+ DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('"
						+ dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS') "
						+ "and cobrancado1_.dbac_id = " + idDebitoACobrar;
			} else {
				return;
			}

			queryConsultar = queryConsultar
					+ " order by cobrancado0_.cbdo_tmemissao desc ";

			Collection idsItem = session.createSQLQuery(queryConsultar)
					.addScalar("idItem", Hibernate.INTEGER).list();

			session.clear();

			if (idsItem != null && !idsItem.isEmpty()) {
				// Integer idItem = (Integer) pesquisa.iterator().next();
				queryAtualizar = "update gcom.cobranca.CobrancaDocumentoItem cdi "
						+ " set cobrancaDebitoSituacao = :situacaoDebito, dataSituacaoDebito = :dataSituacaoDebito ,"
						+ " ultimaAlteracao = :ultimaAlteracao "
						+ "	where cdit_id in (:idsItem)";

				session.createQuery(queryAtualizar)
						.setInteger("situacaoDebito", situacaoDebito)
						.setDate("dataSituacaoDebito", dataSituacao)
						.setTimestamp("ultimaAlteracao", new Date())
						.setParameterList("idsItem", idsItem).executeUpdate();

			}
			session.flush();

		} catch (HibernateException e) {
			System.out.println("Erro: " + e.getMessage());

			throw new ErroRepositorioException(e, "Erro no Hibernate: "
					+ e.getMessage());
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Recupera os dados de documento item com situacao atualizada
	 * 
	 * @author Francisco do Nascimento
	 * @created 19/05/08
	 * 
	 * @param idDocumentoCobranca
	 *            id do documento de cobranca
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosCobrancaDocumentoItemSituacaoJaAtualizada(
			Integer idDocumentoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT cdi.id,"// 0
					+ " cdi.valorItemCobrado,"// 1
					+ " cdi.cobrancaDebitoSituacao.id, " // 2
					+ " cdi.dataSituacaoDebito " // 3
					+ "FROM CobrancaDocumentoItem cdi "
					+ "WHERE cdi.cobrancaDocumento.id = :idDocumentoCobranca ";

			retorno = session.createQuery(consulta)
					.setInteger("idDocumentoCobranca", idDocumentoCobranca)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel,
			Date dataEmissao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id,documentoTipo.id "
					+ "FROM CobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca "
					+ "WHERE to_date(cd.emissao, 'yyyy-MM-dd') = :dataEmissao AND "
					+ "imovel.id = :idImovel";

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

			retorno = (Object[]) session.createQuery(consulta)
					.setString("dataEmissao", sdf.format(dataEmissao))
					.setInteger("idImovel", idImovel.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel,
			BigDecimal valorPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id,documentoTipo.id "
					+ "FROM CobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca "
					+ "WHERE cd.valorDocumento = :valorDocumento AND "
					+ "imovel.id = :idImovel";

			retorno = (Object[]) session.createQuery(consulta)
					.setBigDecimal("valorDocumento", valorPagamento)
					.setInteger("idImovel", idImovel.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel,
			Date dataEmissao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id " // 15
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.imovel imov "
					+ "WHERE to_date(cd.emissao, 'yyyy-MM-dd') = :dataEmissao AND "
					+ "imovel.id = :idImovel";

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

			retorno = session.createQuery(consulta)
					.setString("dataEmissao", sdf.format(dataEmissao))
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UCXXXX] - Emitir Documento de Cobrança
	 * 
	 * @author Rafael Corrêa
	 * @date 02/09/2009
	 * 
	 * @param idCobrancaDocumento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<ContaGeral> pesquisarCobrancaDocumentoItem(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<ContaGeral> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT contaGeral "
					+ "FROM CobrancaDocumentoItem cdi "
					+ "INNER JOIN cdi.cobrancaDocumento cd "
					+ "INNER JOIN cdi.contaGeral contaGeral "
					+ "LEFT JOIN FETCH contaGeral.conta conta "
					+ "LEFT JOIN FETCH contaGeral.contaHistorico contaHistorico "
					+ "WHERE cd.id = :idCobrancaDocumento "
					+ "ORDER BY conta.referencia ";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Verificar se existe pagamento para contas de um imovel as quais foram
	 * utilizadas como entrada num parcelamento
	 * 
	 * @param idImovel
	 * @param dataParcelamento
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 * @author Francisco do Nascimento
	 * @date 03/07/2008
	 * 
	 */
	public boolean exitePagamentoContaEntradaParcelamento(Integer idImovel,
			Date dataParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;
		boolean existe = false;

		try {
			/*
			 * SELECT * FROM cobranca.parcelamento parc, faturamento.conta c,
			 * arrecadacao.pagamento pag where parc.parc_id = c.parc_id and
			 * pag.cnta_id = c.cnta_id and c.imov_id = 18604620 and
			 * cast(parc.parc_tmparcelamento as Date) = '2008-06-12'
			 */
			consulta = "SELECT parc.parc_id as id FROM cobranca.parcelamento parc, "
					+ "faturamento.conta c, arrecadacao.pagamento pag "
					+ "where parc.parc_id = c.parc_id and pag.cnta_id = c.cnta_id and "
					+ "c.imov_id = "
					+ idImovel
					+ " and "
					+ "cast(parc.parc_tmparcelamento as Date) = to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(dataParcelamento)
					+ "','YYYY-MM-DD')";
			// consulta = "SELECT parc.id FROM Parcelamento parc, "
			// + "Conta c, "
			// + "Pagamento pag "
			// + "WHERE parc.id = c.parcelamento.id "
			// + " and c.id = pag.conta.id "
			// + " and c.imovel.id = :idImovel and c.parcelamento is not null "
			// + " and cast(c.parcelamento as Date) = :dataParcelamento ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER).setMaxResults(1)
					.uniqueResult();

			if (retorno != null) {
				existe = true;
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return existe;

	}

	/**
	 * Consulta as contas transferidas
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarContasTransferidas(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT contaOrigem.cnta_amreferenciaconta as anoMesReferencia, contaOrigem.imov_id as idImovelOrigem, "
					+ " contaDestino.imov_id as idImovelDestino, usuario.usur_nmusuario as nomeUsuario, "
					+ " contaOrigem.cnta_tmultimaalteracao as dataTransferencia, contaOrigem.cnta_id as idConta "
					+ " FROM faturamento.conta contaDestino "
					+ " INNER JOIN faturamento.conta contaOrigem "
					+ " on contaDestino.cnta_idorigem = contaOrigem.cnta_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on contaOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " contaOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " contaDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " contaOrigem.cnta_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT contaHistOrigem.cnhi_amreferenciaconta as anoMesReferencia, contaHistOrigem.imov_id as idImovelOrigem, "
					+ " contaHistDestino.imov_id as idImovelDestino, usuario.usur_nmusuario as nomeUsuario, "
					+ " contaHistOrigem.cnhi_tmultimaalteracao as dataTransferencia, contaHistOrigem.cnta_id as idConta "
					+ " FROM faturamento.conta_historico contaHistDestino "
					+ " INNER JOIN faturamento.conta_historico contaHistOrigem "
					+ " on contaHistDestino.cnta_idorigem = contaHistOrigem.cnta_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on contaHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " contaHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " contaHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " contaHistOrigem.cnhi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, anoMesReferencia ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idConta", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idConta", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta os débitos a cobrar transferidos
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarDebitosACobrarTransferidos(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, debitoDestino.imov_id as idImovelDestino, "
					+ " debitoOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " debitoOrigem.dbac_tmultimaalteracao as dataTransferencia, debitoOrigem.dbac_id as idDebito "
					+ " FROM faturamento.debito_a_cobrar debitoDestino "
					+ " INNER JOIN faturamento.debito_a_cobrar debitoOrigem "
					+ " on debitoDestino.dbac_idorigem = debitoOrigem.dbac_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on debitoOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on debitoOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " debitoOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " debitoDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " debitoOrigem.dbac_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, debitoHistDestino.imov_id as idImovelDestino, "
					+ " debitoHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " debitoHistOrigem.dahi_tmultimaalteracao as dataTransferencia, debitoHistOrigem.dbac_id as idDebito "
					+ " FROM faturamento.deb_a_cobrar_hist debitoHistDestino "
					+ " INNER JOIN faturamento.deb_a_cobrar_hist debitoHistOrigem "
					+ " on debitoHistDestino.dbac_idorigem = debitoHistOrigem.dbac_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on debitoHistOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on debitoHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " debitoHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " debitoHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " debitoHistOrigem.dahi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, debitoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idDebito", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idDebito", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta as guias de pagamento transferidas
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarGuiasDePagamentoTransferidas(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, guiaDestino.imov_id as idImovelDestino, "
					+ " guiaOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " guiaOrigem.gpag_tmultimaalteracao as dataTransferencia, guiaOrigem.gpag_id as idGuia "
					+ " FROM faturamento.guia_pagamento guiaDestino "
					+ " INNER JOIN faturamento.guia_pagamento guiaOrigem "
					+ " on guiaDestino.gpag_idorigem = guiaOrigem.gpag_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on guiaOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on guiaOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " guiaOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " guiaDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " guiaOrigem.gpag_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, guiaHistDestino.imov_id as idImovelDestino, "
					+ " guiaHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " guiaHistOrigem.gphi_tmultimaalteracao as dataTransferencia, guiaHistOrigem.gpag_id as idGuia "
					+ " FROM faturamento.guia_pagamento_historico guiaHistDestino "
					+ " INNER JOIN faturamento.guia_pagamento_historico guiaHistOrigem "
					+ " on guiaHistDestino.gpag_idorigem = guiaHistOrigem.gpag_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on guiaHistOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on guiaHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " guiaHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " guiaHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " guiaHistOrigem.gphi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, debitoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idGuia", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idGuia", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta os créditos a realizar transferidos
	 * 
	 * [UC0204] - Consultar Transferências do Débito
	 * 
	 * @author Rafael Corrêa
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarCreditosARealizarTransferidos(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT creditoTipo.crti_dscreditotipo as creditoTipo, creditoDestino.imov_id as idImovelDestino, "
					+ " creditoOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " creditoOrigem.crar_tmultimaalteracao as dataTransferencia, creditoOrigem.crar_id as idCredito "
					+ " FROM faturamento.credito_a_realizar creditoDestino "
					+ " INNER JOIN faturamento.credito_a_realizar creditoOrigem "
					+ " on creditoDestino.crar_idorigem = creditoOrigem.crar_id "
					+ " INNER JOIN faturamento.credito_tipo creditoTipo "
					+ " on creditoOrigem.crti_id = creditoTipo.crti_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on creditoOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " creditoOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " creditoDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " creditoOrigem.crar_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT creditoTipo.crti_dscreditotipo as creditoTipo, creditoHistDestino.imov_id as idImovelDestino, "
					+ " creditoHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " creditoHistOrigem.carh_tmultimaalteracao as dataTransferencia, creditoHistOrigem.crar_id as idCredito "
					+ " FROM faturamento.cred_a_realiz_hist creditoHistDestino "
					+ " INNER JOIN faturamento.cred_a_realiz_hist creditoHistOrigem "
					+ " on creditoHistDestino.crar_idorigem = creditoHistOrigem.crar_id "
					+ " INNER JOIN faturamento.credito_tipo creditoTipo "
					+ " on creditoHistOrigem.crti_id = creditoTipo.crti_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on creditoHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " creditoHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " creditoHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " creditoHistOrigem.carh_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, creditoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("creditoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idCredito", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("creditoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idCredito", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 15/07/2008
	 */
	public Collection<Object[]> obterNomeCPFTestemunhas(Integer unidadeUsuario)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select usur.nomeUsuario,usur.cpf "
					+ " from UnidadeOrganizacionalTestemunha unte "
					+ " inner join unte.unidadeOrganizacional un "
					+ " inner join unte.usuario usur "
					+ " where un.id = :unidadeUsuario and "
					+ " unte.dataFimRelacao is null " + " order by unte.id ";

			retorno = (Collection<Object[]>) session.createQuery(consulta)
					.setInteger("unidadeUsuario", unidadeUsuario).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0852] Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * Cancela uma guia de pagamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idGuiaPagamento
	 * @throws ErroRepositorioException
	 */
	public void cancelarGuiaPagamento(Integer idGuiaPagamento,
			Integer anoMesReferenciaContabil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String cancelarGuia;

		try {
			cancelarGuia = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "SET " + "dcst_idatual = :idCancelada, "
					+ "gpag_amreferenciacontabil = :anoMesReferenciaContabil, "
					+ "gpag_tmultimaalteracao = :ultimaAlteracao "
					+ "where gpag_id = :idGuiaPagamento";

			session.createQuery(cancelarGuia)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.setInteger("idCancelada", DebitoCreditoSituacao.CANCELADA)
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0852] Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param parcelamento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaDoParcelamentoNaoPago(Integer parcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT cnta FROM Conta cnta "
					+ "INNER JOIN cnta.parcelamento parc "
					+ "WHERE parc.id = :parcelamento "
					+ "and cnta.debitoCreditoSituacaoAtual in (0,1,2) ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", parcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * Pesquisa as contas associadas ao imóvel
	 * 
	 * @author: Rafael Corrêa
	 * @date: 28/10/2008
	 */
	public Collection<Object[]> pesquisarContasInformarContasEmCobranca(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta,
			Collection<Integer> idsImoveis, SistemaParametro sistemaParametro)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT conta.cnta_id as idConta, "
					+ " ( "
					+ " 	coalesce( conta.cnta_vlagua, 0 ) + "
					+ " 	coalesce( conta.cnta_vlesgoto, 0 ) + "
					+ " 	coalesce( conta.cnta_vldebitos, 0 ) - "
					+ " 	coalesce( conta.cnta_vlcreditos, 0 ) - "
					+ " 	coalesce( conta.cnta_vlimpostos, 0 ) "
					+ " ) as valorConta, 1 as indicadorPagamentoValido, conta.imov_id as idImovel"
					+ " FROM faturamento.conta conta "
					+ " LEFT OUTER JOIN arrecadacao.pagamento pagto "
					+ " on pagto.cnta_id = conta.cnta_id "
					+ " WHERE conta.imov_id in ( :idsImoveis ) "
					+ " and conta.cmrv_id is null and conta.cnta_dtrevisao is null "
					+ " and pagto.pgmt_id is null and conta.dcst_idatual in (:incluida,:normal,:retificada) ";

			if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {
				// 2.1.19.1. Caso o indicador para incluir contas fora do
				// vencimento para cobrança corresponda a NÃO
				if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca()
						.compareTo(ConstantesSistema.NAO) == 0) {
					consulta = consulta
							+ " and conta.cnta_dtvencimentooriginal <= to_date('"
							+ Util.formatarDataComTracoAAAAMMDD(Util
									.subtrairNumeroDiasDeUmaData(new Date(),
											comandoEmpresaCobrancaConta
													.getQtdDiasVencimento()))
							+ "','YYYY-MM-DD') ";
				} else {
					consulta = consulta
							+ " and exists (select distinct cnta2.imov_id "
							+ " 			from faturamento.conta cnta2 "
							+ "				where cnta2.cnta_dtvencimentooriginal <= to_date('"
							+ Util.formatarDataComTracoAAAAMMDD(Util
									.subtrairNumeroDiasDeUmaData(new Date(),
											comandoEmpresaCobrancaConta
													.getQtdDiasVencimento()))
							+ "','YYYY-MM-DD') "
							+ "					and cnta2.imov_id = conta.imov_id "
							+ " 				and cnta2.cnta_amreferenciaconta < "
							+ sistemaParametro.getAnoMesArrecadacao()
							+ " 				and cnta2.cmrv_id is null "
							+ "					and cnta2.cnta_dtrevisao is null ";

					consulta = consulta + " and conta.dcst_idatual in ( "
							+ DebitoCreditoSituacao.NORMAL + ", "
							+ DebitoCreditoSituacao.INCLUIDA + ", "
							+ DebitoCreditoSituacao.RETIFICADA + " ) ";

					if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {

						consulta = consulta
								+ " and conta.cnta_amreferenciaconta between "
								+ comandoEmpresaCobrancaConta
										.getReferenciaContaInicial()
								+ " and "
								+ comandoEmpresaCobrancaConta
										.getReferenciaContaFinal();
					}

					if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

						consulta = consulta
								+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between "
								+ comandoEmpresaCobrancaConta
										.getValorMinimoConta()
								+ " and "
								+ comandoEmpresaCobrancaConta
										.getValorMaximoConta();
					}
					consulta = consulta + " ) ";
				}

			} else {
				consulta = consulta
						+ " and conta.cnta_dtvencimentooriginal < to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(new Date())
						+ "','YYYY-MM-DD') ";
			}

			consulta = consulta
					+ criarCondicionaisPesquisarContasInformarContasEmCobranca(comandoEmpresaCobrancaConta);

			if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null
					|| comandoEmpresaCobrancaConta
							.getDataVencimentoContaInicial() != null
					|| comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

				consulta = consulta
						+ " UNION "
						+ "SELECT conta.cnta_id as idConta, "
						+ " ( "
						+ " 	coalesce( conta.cnta_vlagua, 0 ) + "
						+ " 	coalesce( conta.cnta_vlesgoto, 0 ) + "
						+ " 	coalesce( conta.cnta_vldebitos, 0 ) - "
						+ " 	coalesce( conta.cnta_vlcreditos, 0 ) - "
						+ " 	coalesce( conta.cnta_vlimpostos, 0 ) "
						+ " ) as valorConta, 2 as indicadorPagamentoValido, conta.imov_id as idImovel"
						+ " FROM faturamento.conta conta "
						+ " LEFT OUTER JOIN arrecadacao.pagamento pagto "
						+ " on pagto.cnta_id = conta.cnta_id "
						+ " WHERE conta.imov_id in ( :idsImoveis ) and "
						+ " conta.cnta_amreferenciaconta <  "
						+ sistemaParametro.getAnoMesArrecadacao()
						+ " and "
						+ " conta.cmrv_id is null and conta.cnta_dtrevisao is null and ";

				if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {
					// 2.1.19.1. Caso o indicador para incluir contas fora do
					// vencimento para cobrança corresponda a NÃO
					if (sistemaParametro
							.getIndicadorIncluirContasForaVenCobranca()
							.compareTo(ConstantesSistema.NAO) == 0) {
						consulta = consulta
								+ " conta.cnta_dtvencimentooriginal < to_date('"
								+ Util.formatarDataComTracoAAAAMMDD(Util
										.subtrairNumeroDiasDeUmaData(
												new Date(),
												comandoEmpresaCobrancaConta
														.getQtdDiasVencimento()))
								+ "','YYYY-MM-DD') and ";
					} else {
						consulta = consulta
								+ " not exists (select distinct cnta2.imov_id "
								+ " 			from faturamento.conta cnta2 "
								+ "				where cnta2.cnta_dtvencimentooriginal > to_date('"
								+ Util.formatarDataComTracoAAAAMMDD(Util
										.subtrairNumeroDiasDeUmaData(
												new Date(),
												comandoEmpresaCobrancaConta
														.getQtdDiasVencimento()))
								+ "','YYYY-MM-DD') "
								+ "					and cnta2.imov_id = conta.imov_id  "
								+ " 				and cnta2.cnta_amreferenciaconta < "
								+ sistemaParametro.getAnoMesArrecadacao()
								+ " 				and cnta2.cmrv_id is null "
								+ "					and cnta2.cnta_dtrevisao is null ";

						consulta = consulta + " and conta.dcst_idatual in ( "
								+ DebitoCreditoSituacao.NORMAL + ", "
								+ DebitoCreditoSituacao.INCLUIDA + ", "
								+ DebitoCreditoSituacao.RETIFICADA + " ) ";

						if (comandoEmpresaCobrancaConta
								.getReferenciaContaInicial() != null) {

							consulta = consulta
									+ " and (conta.cnta_amreferenciaconta not between "
									+ comandoEmpresaCobrancaConta
											.getReferenciaContaInicial()
									+ " and "
									+ comandoEmpresaCobrancaConta
											.getReferenciaContaFinal();
						}

						if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

							consulta = consulta
									+ " or ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) not between "
									+ comandoEmpresaCobrancaConta
											.getValorMinimoConta()
									+ " and "
									+ comandoEmpresaCobrancaConta
											.getValorMaximoConta();
						}
						consulta = consulta + " )) and ";
					}

				} else {
					consulta = consulta
							+ " conta.cnta_dtvencimentooriginal <= to_date('"
							+ Util.formatarDataComTracoAAAAMMDD(new Date())
							+ "','YYYY-MM-DD')  and ";
				}

				consulta = consulta
						+ criarCondicionaisPesquisarContasInformarContasEmCobrancaNegacao(comandoEmpresaCobrancaConta);
			}

			retorno = session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorPagamentoValido", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setParameterList("idsImoveis", idsImoveis)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	private String criarCondicionaisPesquisarContasInformarContasEmCobranca(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta) {
		String retorno = "";
		Collection<SetorComercial> setoresComponent = null;
		try {
			setoresComponent = pesquisarSetoresComerciaisComandoEmpresaCobrancaContaSetorComercial(comandoEmpresaCobrancaConta
					.getId());
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		if (setoresComponent != null && !setoresComponent.isEmpty()) {
			retorno += " and conta.cnta_cdsetorcomercial in( ";
			for (SetorComercial setor : setoresComponent) {
				retorno += setor.getCodigo() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1);
			retorno += ") ";
		} else {
			if (comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial() != null) {
				retorno = retorno
						+ " and conta.cnta_cdsetorcomercial between "
						+ comandoEmpresaCobrancaConta
								.getCodigoSetorComercialInicial()
						+ " and "
						+ comandoEmpresaCobrancaConta
								.getCodigoSetorComercialFinal();
			}

			if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {
				retorno = retorno
						+ " and conta.cnta_nnquadra between "
						+ comandoEmpresaCobrancaConta.getQuadraInicial()
								.getNumeroQuadra()
						+ " and "
						+ comandoEmpresaCobrancaConta.getQuadraFinal()
								.getNumeroQuadra();
			}
		}

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {
			retorno = retorno + "  and conta.cnta_amreferenciaconta between "
					+ comandoEmpresaCobrancaConta.getReferenciaContaInicial()
					+ " and "
					+ comandoEmpresaCobrancaConta.getReferenciaContaFinal();
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {
			retorno = retorno
					+ "  and conta.cnta_dtvencimentooriginal between to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
							.getDataVencimentoContaInicial())
					+ "','YYYY-MM-DD') and to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
							.getDataVencimentoContaFinal()) + "','YYYY-MM-DD')";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {
			retorno = retorno
					+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between "
					+ comandoEmpresaCobrancaConta.getValorMinimoConta()
					+ " and "
					+ comandoEmpresaCobrancaConta.getValorMaximoConta();
		}

		return retorno;
	}

	private String criarCondicionaisPesquisarContasInformarContasEmCobrancaNegacao(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta) {
		String retorno = " pagto.pgmt_id is null and conta.dcst_idatual in ( "
				+ DebitoCreditoSituacao.NORMAL + ", "
				+ DebitoCreditoSituacao.INCLUIDA + ", "
				+ DebitoCreditoSituacao.RETIFICADA + " ) and ( ";

		boolean algumCriterioContaInformado = false;

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {

			algumCriterioContaInformado = true;

			retorno = retorno + " conta.cnta_amreferenciaconta not between "
					+ comandoEmpresaCobrancaConta.getReferenciaContaInicial()
					+ " and "
					+ comandoEmpresaCobrancaConta.getReferenciaContaFinal()
					+ " or ";
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {

			algumCriterioContaInformado = true;

			retorno = retorno
					+ " conta.cnta_dtvencimentooriginal not between to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
							.getDataVencimentoContaInicial())
					+ "','YYYY-MM-DD') and to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
							.getDataVencimentoContaFinal())
					+ "','YYYY-MM-DD') or ";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

			algumCriterioContaInformado = true;

			retorno = retorno
					+ " ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) not between "
					+ comandoEmpresaCobrancaConta.getValorMinimoConta()
					+ " and "
					+ comandoEmpresaCobrancaConta.getValorMaximoConta()
					+ " or ";
		}

		if (algumCriterioContaInformado) {
			retorno = Util.removerUltimosCaracteres(retorno, 3) + " ) ";
		} else {
			retorno = Util.removerUltimosCaracteres(retorno, 6);
		}

		return retorno;
	}

	/**
	 * [UC0852] Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * Desassociar a conta do parcelamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void desassociarContaParcelamento(Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String desassociarConta;

		try {
			desassociarConta = "update gcom.faturamento.conta.Conta "
					+ "set parc_id = null, cnta_tmultimaalteracao = :ultimaAlteracao "
					+ "where cnta_id = :idConta";

			session.createQuery(desassociarConta)
					.setInteger("idConta", idConta.intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera os itens do parcelamento a partir do parcelamento
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public Collection<Object[]> pesquisarItensParcelamentos(
			Integer idParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select cg.id,"
					+ " dacg.id, "
					+ "CASE "
					+ " WHEN cg.indicadorHistorico = 2  "
					+ " THEN (conta.valorAgua + "
					+ "conta.valorEsgoto + "
					+ "conta.debitos - "
					+ "(conta.valorCreditos - coalesce(conta.valorImposto,0))) "
					+ " ELSE (ch.valorAgua + " + "ch.valorEsgoto + "
					+ "ch.valorDebitos - "
					+ "(ch.valorCreditos - coalesce(ch.valorImposto,0))) "
					+ " END " + " from ParcelamentoItem pi "
					+ " inner join pi.documentoTipo dotp "
					+ " left join pi.debitoACobrarGeral dacg "
					+ " left join pi.contaGeral cg "
					+ " left join cg.contaHistorico ch "
					+ " left join cg.conta conta "
					+ " where pi.parcelamento.id = :idParcelamento"
					+ "  and dotp.id in (6,1) ";

			retorno = (Collection<Object[]>) session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa se a conta está na tabela de empresa cobranca conta
	 * 
	 * @author Sávio Luiz, Raimundo Martins, Mariana Victor
	 * @date 23/10/2008, 03/10/2011, 25/06/2012
	 */
	public Integer pesquisarEmpresaCobrancaConta(Integer idConta,
			Integer idImovel, Date dataPagamentoParcelamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select ecc.ecco_id AS idEmprCobCnta "
					+ " from cobranca.empresa_cobranca_conta ecc "
					+ "   inner join cadastro.imovel_cobranca_situacao iscb on ecc.imov_id = iscb.imov_id and iscb.cbst_id = 1 "
					+ "   inner join (select min(ecco.ecco_dtenvioconta) as envio, "
					+ "   		max(ecco.ecco_dtretiradaconta) as retirada, "
					+ "   		ecco.imov_id, ecco.cecc_id "
					+ "   		from cobranca.empresa_cobranca_conta ecco "
					+ "   		where ecco.imov_id = :idImovel "
					+ "   		group by ecco.imov_id, ecco.cecc_id) aux on aux.imov_id = iscb.imov_id and aux.cecc_id = ecc.cecc_id "
					+ " where ecc.cnta_id = :idConta "
					+ "   and ((iscb.iscb_dtretiradacobranca is null and :dtPagamentoParcelamento >= iscb.iscb_dtimplantacaocobranca) "
					+ "     or (:dtPagamentoParcelamento between iscb.iscb_dtimplantacaocobranca and iscb.iscb_dtretiradacobranca)) "
					+ "   and ((aux.retirada is null and iscb.iscb_dtimplantacaocobranca >= aux.envio) "
					+ "  	or (iscb.iscb_dtimplantacaocobranca between aux.envio and aux.retirada)) ";

			Query q = session
					.createSQLQuery(consulta)
					.addScalar("idEmprCobCnta", Hibernate.INTEGER)
					.setInteger("idConta", idConta)
					.setInteger("idImovel", idImovel)
					.setDate("dtPagamentoParcelamento",
							dataPagamentoParcelamento);

			retorno = (Integer) q.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os dados do debito a cobrar
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public Object[] pesquisarDadosDebitoACobrar(Integer idDebitoACobrar)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select parc.id, " + " dabh.prestacaoDebito, "
					+ " dabh.prestacaoCobradas "
					+ " from DebitoACobrarHistorico dabh "
					+ " inner join dabh.parcelamento parc "
					+ " where dabh.id = :idDebitoACobrar";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os itens do parcelamento a partir do parcelamento
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public Collection<Object[]> pesquisarItensParcelamentosNivel2(
			Integer idParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select cg.id,"// 0
					+ " dacg.id, "// 1
					+ "CASE "// 2
					+ " WHEN cg.indicadorHistorico = 2  "
					+ " THEN (conta.valorAgua + "
					+ "conta.valorEsgoto + "
					+ "conta.debitos - "
					+ "(conta.valorCreditos - coalesce(conta.valorImposto,0))) "
					+ " ELSE (ch.valorAgua + "
					+ "ch.valorEsgoto + "
					+ "ch.valorDebitos - "
					+ "(ch.valorCreditos - coalesce(ch.valorImposto,0))) "
					+ " END "
					+ " from ParcelamentoItem pi "
					+ " left join pi.debitoACobrarGeral dacg "
					+ " inner join pi.parcelamento parc "
					+ " left join pi.contaGeral cg "
					+ " left join cg.contaHistorico ch "
					+ " left join cg.conta conta "
					+ " where parc.id = :idParcelamento";

			retorno = (Collection<Object[]>) session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 29/10/2008
	 */
	public Collection pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobranca(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que já monta uma coleção de
		 * GerarArquivoTextoContasCobrancaEmpresaHelper com tudo que é
		 * necessário **
		 */
		try {
			consulta = "select new gcom.cobranca.GerarArquivoTextoContasCobrancaEmpresaHelper("
					+ " comandoEmpresaCobrancaConta.id,"
					+ " comandoEmpresaCobrancaConta.empresa.id,"
					+ " comandoEmpresaCobrancaConta.empresa.descricao,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal,"
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id,"
					+ " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome,"
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome,"
					+ " count(ecco.comandoEmpresaCobrancaConta.id),"
					+ " sum(ecco.valorOriginalConta),"
					+ " comandoEmpresaCobrancaConta.ultimaAlteracao) "
					+ "from EmpresaCobrancaConta ecco "
					+ "inner join ecco.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "left join comandoEmpresaCobrancaConta.cliente cliente "
					+ "left join comandoEmpresaCobrancaConta.localidadeInicial localidadeInicial "
					+ "left join comandoEmpresaCobrancaConta.localidadeFinal localidadeFinal "
					+ "left join comandoEmpresaCobrancaConta.unidadeNegocio unidadeNegocio "
					+ "inner join comandoEmpresaCobrancaConta.empresa empresa "
					+ "inner join ecco.contaGeral contaGeral "
					+ "inner join contaGeral.conta conta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa "
					+ "and conta.debitoCreditoSituacaoAtual.id in ("
					+ DebitoCreditoSituacao.NORMAL
					+ ", "
					+ DebitoCreditoSituacao.RETIFICADA
					+ ", "
					+ DebitoCreditoSituacao.INCLUIDA
					+ " ) "
					+ "and  NOT EXISTS (select pg.contaGeral.id from Pagamento pg  where pg.contaGeral.id = conta.id) ";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta
					+ "group by new,"
					+ " comandoEmpresaCobrancaConta.empresa.id,"
					+ " comandoEmpresaCobrancaConta.empresa.descricao,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal,"
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id,"
					+ " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome,"
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome,"
					+ " comandoEmpresaCobrancaConta.ultimaAlteracao ";

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 29/10/2008
	 */
	public Collection pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobrancaResumido(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que já monta uma coleção de
		 * GerarArquivoTextoContasCobrancaEmpresaHelper com tudo que é
		 * necessário **
		 */
		try {
			consulta = "select new gcom.cobranca.GerarArquivoTextoContasCobrancaEmpresaHelper("
					+ " comandoEmpresaCobrancaConta.id,"
					+ " comandoEmpresaCobrancaConta.empresa.id,"
					+ " comandoEmpresaCobrancaConta.empresa.descricao,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal,"
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id,"
					+ " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome,"
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome,"
					// + " count(ecco.comandoEmpresaCobrancaConta.id),"
					// + " sum(ecco.valorOriginalConta),"
					+ " comandoEmpresaCobrancaConta.ultimaAlteracao) "
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					// +
					// "inner join ecco.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "left join comandoEmpresaCobrancaConta.cliente cliente "
					+ "left join comandoEmpresaCobrancaConta.localidadeInicial localidadeInicial "
					+ "left join comandoEmpresaCobrancaConta.localidadeFinal localidadeFinal "
					+ "left join comandoEmpresaCobrancaConta.unidadeNegocio unidadeNegocio "
					+ "inner join comandoEmpresaCobrancaConta.empresa empresa "
					// + "inner join ecco.contaGeral contaGeral "
					// + "inner join contaGeral.conta conta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa "
			/*
			 * + "and conta.debitoCreditoSituacaoAtual.id in (" +
			 * DebitoCreditoSituacao.NORMAL + ", " +
			 * DebitoCreditoSituacao.RETIFICADA +", " +
			 * DebitoCreditoSituacao.INCLUIDA + " ) " +
			 * "and  NOT EXISTS (select pg.conta.id from Pagamento pg  where pg.conta.id = conta.id) "
			 */;

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			/*
			 * consulta = consulta + "group by new," +
			 * " comandoEmpresaCobrancaConta.empresa.id," +
			 * " comandoEmpresaCobrancaConta.empresa.descricao," +
			 * " comandoEmpresaCobrancaConta.codigoSetorComercialInicial," +
			 * " comandoEmpresaCobrancaConta.codigoSetorComercialFinal," +
			 * "	comandoEmpresaCobrancaConta.valorMinimoConta," +
			 * " comandoEmpresaCobrancaConta.valorMaximoConta," +
			 * "	comandoEmpresaCobrancaConta.referenciaContaInicial," +
			 * "	comandoEmpresaCobrancaConta.referenciaContaFinal," +
			 * " comandoEmpresaCobrancaConta.dataVencimentoContaInicial," +
			 * "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal," +
			 * " comandoEmpresaCobrancaConta.dataExecucao," +
			 * " comandoEmpresaCobrancaConta.imovel.id," +
			 * " comandoEmpresaCobrancaConta.cliente.id," +
			 * " comandoEmpresaCobrancaConta.cliente.nome," +
			 * " comandoEmpresaCobrancaConta.localidadeInicial.id," +
			 * " comandoEmpresaCobrancaConta.localidadeFinal.id," +
			 * " comandoEmpresaCobrancaConta.unidadeNegocio.id," +
			 * " comandoEmpresaCobrancaConta.unidadeNegocio.nome," +
			 * " comandoEmpresaCobrancaConta.ultimaAlteracao ";
			 */

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice * quantidadeRegistros).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 29/10/2008
	 */
	public Collection<Object[]> pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCriterio(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select comandoEmpresaCobrancaConta.id, "
					+ "count(ecco.comandoEmpresaCobrancaConta.id), "
					+ "sum(ecco.valorOriginalConta) "
					+ "from EmpresaCobrancaConta ecco "
					+ "inner JOIN ecco.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					// + "inner join ecco.contaGeral contaGeral "
					// + "inner join contaGeral.conta conta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa and ecco.indicadorPagamentoValido = 1 "
			/*
			 * + "and conta.debitoCreditoSituacaoAtual.id in (" +
			 * DebitoCreditoSituacao.NORMAL + ", " +
			 * DebitoCreditoSituacao.RETIFICADA +", " +
			 * DebitoCreditoSituacao.INCLUIDA + " )" +
			 * "and  NOT EXISTS (select pg.conta.id from Pagamento pg where pg.conta.id = conta.id)"
			 */;

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta + " group by comandoEmpresaCobrancaConta.id  ";

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 29/10/2008
	 */
	public Integer pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobrancaCount(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT COUNT(DISTINCT comandoEmpresaCobrancaConta.id) "
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio, Mariana Victor
	 * @date: 29/10/2008, 02/05/2011
	 */
	public Collection<Object[]> pesquisarDadosArquivoTextoContasCobrancaEmpresa(
			Collection ids, Integer idUnidadeNegocio, Integer numeroPagina,
			int quantidadeRegistros, Integer idProgramaEspecial)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select ecco.ecco_id as idEmpresaCobrancaConta, "// 0
					+ "unidadeNegocio.uneg_id as idUnidadeNegocio, "// 1
					+ "unidadeNegocio.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 2
					+ "rota.ftgr_id as idGrupoFaturamento, "// 3
					+ "localidade.loca_id as idLocalidade, "// 4
					+ "localidade.loca_nmlocalidade as nomeLocalidade, "// 5
					+ "rota.rota_cdrota as codigoRota, "// 6
					+ "imovel.imov_nnsequencialrota as numeroSequencial, "// 7
					+ "conta.imov_id as idImovel, "// 8
					+ "cliente.clie_nmcliente as nomeCliente, "// 9
					+ "clienteTipo.cltp_id as idClienteTipo, "// 10
					+ "cliente.clie_nncpf as numeroCpf, "// 11
					+ "cliente.clie_nncnpj as numeroCnpj, "// 12
					+ "cliente.clie_nnrg as numeroRg, "// 13
					+ "quadra.qdra_nnquadra as numeroQuadra, "// 14
					+ "conta.cnta_id as idConta, "// 15
					+ "clienteFone.cfon_nnfone as numeroFone, "// 16
					+ "cliente.clie_nmabreviado as nomeAbreviadoCliente, "// 17
					+ "conta.cnta_amreferenciaconta as anoMesConta, "// 18
					+ "conta.cnta_dtvencimentooriginal as vencimentoConta, "// 19
					+ "conta.cnta_vlagua as valorAgua, "// 20
					+ "conta.cnta_vlesgoto as valorEsgoto, "// 21
					+ "conta.cnta_vldebitos as valorDebitos, "// 22
					+ "conta.cnta_vlcreditos as valorCreditos, "// 23
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 "
					+ "  then conta.cnta_cdsetorcomercial "
					+ "else stcm.stcm_cdsetorcomercial "
					+ "end as codigoSetorComercial, "// 24
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 "
					+ "  then conta.cnta_nnlote "
					+ "else imovel.imov_nnlote "
					+ "end as numeroLote, "// 25
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 "
					+ "  then conta.cnta_nnsublote "
					+ "else imovel.imov_nnsublote "
					+ "end as numeroSublote, "// 26
					+ "cliente.clie_id as idCliente, "// 27
					+ "gerenciaRegional.greg_id AS idGerenciaRegional, "// 28
					+ "gerenciaRegional.greg_nmregional AS nomeGerenciaRegional, "// 29
					+ "emco.emco_cdlayouttxt AS codigoLayout, "// 30
					+ "ecco.orse_id AS idOrdemServico " // 31
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ "inner join cadastro.imovel imovel  on imovel.imov_id  = conta.imov_id "
					+ "inner join cadastro.cliente_imovel clienteImovel   on clienteImovel.imov_id  = imovel.imov_id and (clienteImovel.crtp_id = 2 AND clienteImovel.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente cliente  on cliente.clie_id = clienteImovel.clie_id "
					+ "left outer join cadastro.cliente_fone clienteFone on (clienteFone.clie_id = cliente.clie_id and (clienteFone.cfon_icfonepadrao=1)) "
					+ "inner join cadastro.cliente_tipo clienteTipo on clienteTipo.cltp_id = cliente.cltp_id "
					+ "inner join cadastro.localidade localidade  on localidade.loca_id = imovel.loca_id "
					+ "inner join cadastro.unidade_negocio unidadeNegocio  on unidadeNegocio.uneg_id  = localidade.uneg_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on gerenciaRegional.greg_id = localidade.greg_id "
					+ "inner join cadastro.quadra quadra on quadra.qdra_id = imovel.qdra_id "
					+ "inner join micromedicao.rota rota on rota.rota_id = quadra.rota_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = ecco.empr_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imovel.stcm_id "
					+ "where ecco.cecc_id in (:ids) ";

			if (idUnidadeNegocio != null) {
				consulta = consulta
						+ " and localidade.uneg_id = :idUnidadeNegocio ";
			}

			consulta = consulta
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			if (idProgramaEspecial != null) {
				consulta += "and imovel.iper_id <> :idProgramaEspecial ";
			}

			consulta += " order by ecco.ecco_id, conta.imov_id ";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idEmpresaCobrancaConta", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idGrupoFaturamento", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("numeroSequencial", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("idClienteTipo", Hibernate.INTEGER)
					.addScalar("numeroCpf", Hibernate.STRING)
					.addScalar("numeroCnpj", Hibernate.STRING)
					.addScalar("numeroRg", Hibernate.STRING)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("numeroFone", Hibernate.STRING)
					.addScalar("nomeAbreviadoCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("vencimentoConta", Hibernate.DATE)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroLote", Hibernate.SHORT)
					.addScalar("numeroSublote", Hibernate.SHORT)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("codigoLayout", Hibernate.SHORT)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.setParameterList("ids", ids);

			if (idUnidadeNegocio != null) {
				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);
			}

			if (idProgramaEspecial != null) {
				query.setInteger("idProgramaEspecial", idProgramaEspecial);
			}

			retorno = query.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroPagina).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * @author Mariana Victor
	 * @date 25/11/2011
	 */
	public Collection<Object[]> pesquisarDadosImoveisArquivoTextoContasCobrancaEmpresa(
			Collection ids, Integer idUnidadeNegocio, Integer numeroPagina,
			int quantidadeRegistros, Integer idProgramaEspecial)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select "
					+ "unidadeNegocio.uneg_id as idUnidadeNegocio, "// 0
					+ "unidadeNegocio.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 1
					+ "rota.ftgr_id as idGrupoFaturamento, "// 2
					+ "localidade.loca_id as idLocalidade, "// 3
					+ "localidade.loca_nmlocalidade as nomeLocalidade, "// 4
					+ "rota.rota_cdrota as codigoRota, "// 5
					+ "imovel.imov_nnsequencialrota as numeroSequencial, "// 6
					+ "ecco.imov_id as idImovel, "// 7
					+ "cliente.clie_nmcliente as nomeCliente, "// 8
					+ "clienteTipo.cltp_id as idClienteTipo, "// 9
					+ "cliente.clie_nncpf as numeroCpf, "// 10
					+ "cliente.clie_nncnpj as numeroCnpj, "// 11
					+ "cliente.clie_nnrg as numeroRg, "// 12
					+ "quadra.qdra_nnquadra as numeroQuadra, "// 13
					+ "clienteFone.cfon_nnfone as numeroFone, "// 14
					+ "cliente.clie_nmabreviado as nomeAbreviadoCliente, "// 15
					+ "cliente.clie_id as idCliente, "// 16
					+ "gerenciaRegional.greg_id AS idGerenciaRegional, "// 17
					+ "gerenciaRegional.greg_nmregional AS nomeGerenciaRegional, "// 18
					+ "emco.emco_cdlayouttxt AS codigoLayout, "// 19
					+ "ecco.orse_id AS idOrdemServico " // 20
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ "inner join cadastro.imovel imovel  on imovel.imov_id  = conta.imov_id "
					+ "inner join cadastro.cliente_imovel clienteImovel   on clienteImovel.imov_id  = imovel.imov_id and (clienteImovel.crtp_id = 2 AND clienteImovel.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente cliente  on cliente.clie_id = clienteImovel.clie_id "
					+ "left outer join cadastro.cliente_fone clienteFone on (clienteFone.clie_id = cliente.clie_id and (clienteFone.cfon_icfonepadrao=1)) "
					+ "inner join cadastro.cliente_tipo clienteTipo on clienteTipo.cltp_id = cliente.cltp_id "
					+ "inner join cadastro.localidade localidade  on localidade.loca_id = imovel.loca_id "
					+ "inner join cadastro.unidade_negocio unidadeNegocio  on unidadeNegocio.uneg_id  = localidade.uneg_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on gerenciaRegional.greg_id = localidade.greg_id "
					+ "inner join cadastro.quadra quadra on quadra.qdra_id = imovel.qdra_id "
					+ "inner join micromedicao.rota rota on rota.rota_id = quadra.rota_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = ecco.empr_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imovel.stcm_id "
					+ "where ecco.cecc_id in (:ids) ";

			if (idUnidadeNegocio != null) {
				consulta = consulta
						+ " and localidade.uneg_id = :idUnidadeNegocio ";
			}

			consulta = consulta
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			if (idProgramaEspecial != null) {
				consulta += "and imovel.iper_id <> :idProgramaEspecial ";
			}

			consulta += " group by unidadeNegocio.uneg_id,  unidadeNegocio.uneg_nmunidadenegocio, "
					+ "  rota.ftgr_id,  localidade.loca_id,  localidade.loca_nmlocalidade,  rota.rota_cdrota, "
					+ "  imovel.imov_nnsequencialrota,  ecco.imov_id,  cliente.clie_nmcliente,  clienteTipo.cltp_id, "
					+ "  cliente.clie_nncpf,  cliente.clie_nncnpj,  cliente.clie_nnrg,  quadra.qdra_nnquadra, "
					+ "  clienteFone.cfon_nnfone,  cliente.clie_nmabreviado,  cliente.clie_id, "
					+ "  gerenciaRegional.greg_id,  gerenciaRegional.greg_nmregional,  emco.emco_cdlayouttxt, "
					+ "  ecco.orse_id" + " order by ecco.imov_id ";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idGrupoFaturamento", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("numeroSequencial", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("idClienteTipo", Hibernate.INTEGER)
					.addScalar("numeroCpf", Hibernate.STRING)
					.addScalar("numeroCnpj", Hibernate.STRING)
					.addScalar("numeroRg", Hibernate.STRING)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("numeroFone", Hibernate.STRING)
					.addScalar("nomeAbreviadoCliente", Hibernate.STRING)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("codigoLayout", Hibernate.SHORT)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.setParameterList("ids", ids);

			if (idUnidadeNegocio != null) {
				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);
			}

			if (idProgramaEspecial != null) {
				query.setInteger("idProgramaEspecial", idProgramaEspecial);
			}

			retorno = query.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroPagina).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * @author Mariana Victor
	 * @date 25/11/2011
	 */
	public Collection<Object[]> pesquisarDadosContasArquivoTextoContasCobrancaEmpresa(
			Integer idImovel, Integer idComando)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select "
					+ "   ecco.ecco_id                    	   AS idEmpresaCobrancaConta, " // 0
					+ "   conta.cnta_id                        AS idConta, " // 1
					+ "   conta.cnta_amreferenciaconta         AS anoMesConta, " // 2
					+ "   conta.cnta_dtvencimentoconta         AS vencimentoConta, " // 3
					+ "   conta.cnta_vlagua                    AS valorAgua, " // 4
					+ "   conta.cnta_vlesgoto                  AS valorEsgoto, " // 5
					+ "   conta.cnta_vldebitos                 AS valorDebitos, " // 6
					+ "   conta.cnta_vlcreditos                AS valorCreditos, " // 7
					+ "   CASE "
					+ "     WHEN emco.emco_cdlayouttxt IS NULL "
					+ "     OR emco.emco_cdlayouttxt    = 1 "
					+ "     THEN conta.cnta_cdsetorcomercial "
					+ "     ELSE stcm.stcm_cdsetorcomercial "
					+ "   END 							   AS codigoSetorComercial, " // 8
					+ "   CASE "
					+ "     WHEN emco.emco_cdlayouttxt IS NULL "
					+ "     OR emco.emco_cdlayouttxt    = 1 "
					+ "     THEN conta.cnta_nnlote "
					+ "     ELSE imovel.imov_nnlote "
					+ "   END 							   AS numeroLote, " // 9
					+ "   CASE "
					+ "     WHEN emco.emco_cdlayouttxt IS NULL "
					+ "     OR emco.emco_cdlayouttxt    = 1 "
					+ "     THEN conta.cnta_nnsublote "
					+ "     ELSE imovel.imov_nnsublote "
					+ "   END                              AS numeroSublote " // 10
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ "inner join cadastro.imovel imovel  on imovel.imov_id  = conta.imov_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = ecco.empr_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imovel.stcm_id "
					+ "where ecco.imov_id = :idImovel and ecco.cecc_id = :idComando ";

			consulta = consulta
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			consulta += " order by conta.cnta_amreferenciaconta ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idEmpresaCobrancaConta", Hibernate.INTEGER)
					// 0
					.addScalar("idConta", Hibernate.INTEGER)
					// 1
					.addScalar("anoMesConta", Hibernate.INTEGER)
					// 2
					.addScalar("vencimentoConta", Hibernate.DATE)
					// 3
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					// 4
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					// 5
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					// 6
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					// 7
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					// 8
					.addScalar("numeroLote", Hibernate.SHORT)
					// 9
					.addScalar("numeroSublote", Hibernate.SHORT)
					// 10
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa se a conta está na tabela de empresa cobranca conta
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public void removerEmpresaCobrancaContaPagamentos(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {
			consulta = consulta = "delete EmpresaCobrancaContaPagamentos empresaCobrancaContaPagamentos "
					+ "where empresaCobrancaContaPagamentos.anoMesPagamentoArrecadacao = :anoMesReferenciaArrecadacao and "
					+ "empresaCobrancaContaPagamentos.idImovel in("
					+ "select pagamento.imovel.id from Pagamento pagamento "
					+ "where pagamento.localidade.id = :idLocalidade and pagamento.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao )";

			session.createQuery(consulta)
					.setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Raphael Rossiter
	 * @date 13/11/2008
	 * 
	 * @return Collection<ResolucaoDiretoria>
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaMaiorDataVigenciaInicioPermissaoEspecial()
			throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from ResolucaoDiretoria rd "
					+ "where rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual "
					+ "order by rd.dataVigenciaInicio ";

			retorno = (Collection) session.createQuery(consulta)
					.setDate("dataAtual", new Date()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a quantidade de Rotas que nao possui um Criterio definido para
	 * cada uma das Acoes de Cobrancas passadas no filtro
	 * 
	 * @author Victor Cisneiros
	 * @date 10/12/2008
	 */
	public Integer pesquisarQtdeRotasSemCriteriosParaAcoesCobranca(
			PesquisarQtdeRotasSemCriteriosParaAcoesCobranca filtro)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (filtro.getIdGrupoCobranca() != null) {
			where += " AND r.cbgr_id = :idGrupoCobranca ";
		}
		if (filtro.getIdsRotas() != null && filtro.getIdsRotas().size() > 0) {
			where += " AND r.rota_id IN ( :idsRotas ) ";
		}

		try {
			String consulta = "SELECT count(*) as contador FROM ( "
					+

					"SELECT "
					+ "r.rota_id, "
					+ "( SELECT count(*) FROM cobranca.rota_acao_criterio rac WHERE rac.rota_id = r.rota_id AND rac.cbac_id IN (:idsAcoesCobranca) ) as existe_criterio "
					+ "FROM micromedicao.rota r WHERE 1 = 1 " + where
					+ ") numero_criterios_por_rotas WHERE existe_criterio < "
					+ filtro.getIdsAcoesCobranca().size();

			SQLQuery q = session.createSQLQuery(consulta);

			q.addScalar("contador", Hibernate.INTEGER);

			if (filtro.getIdGrupoCobranca() != null) {
				q.setInteger("idGrupoCobranca", filtro.getIdGrupoCobranca());
			}
			if (filtro.getIdsRotas() != null && filtro.getIdsRotas().size() > 0) {
				q.setParameterList("idsRotas", filtro.getIdsRotas());
			}
			q.setParameterList("idsAcoesCobranca", filtro.getIdsAcoesCobranca());

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Deleta as OrdemServicoUnidade geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarOrdemServicoUnidadeGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM OrdemServicoUnidade ou "
					+ "WHERE ou.ordemServico.id IN "
					+ "( SELECT o.id FROM OrdemServico o WHERE o.cobrancaDocumento.id IN ( :idsDocumentosCobranca ) ) ";

			if (idsDocumentosCobranca.size() > 999) {

				System.out.println("## TAMANHO TOTAL = "
						+ idsDocumentosCobranca.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsDocumentosCobranca, 999);

				int qtdQuebras = 999;
				int indice = idsDocumentosCobranca.size() / qtdQuebras;

				if (idsDocumentosCobranca.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTIÇÕES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTIÇÃO DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Query q = session.createQuery(consulta);
					q.setParameterList("idsDocumentosCobranca",
							particoes.get(i));

					retorno = (Integer) q.executeUpdate();
				}
			} else {
				Query q = session.createQuery(consulta);
				q.setParameterList("idsDocumentosCobranca",
						idsDocumentosCobranca);
				retorno = (Integer) q.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Remover os debitos a cobrar das ordens de servico geradas pelos
	 * documentos
	 * 
	 * @author Francisco do Nascimento
	 * @date 18/11/2009
	 */
	public void removerDebitoACobrarOrdemServicoGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "delete from DebitoACobrar dac where dac.ordemServico.id in "
					+ "  (SELECT os.id FROM OrdemServico os "
					+ "   where os.cobrancaDocumento.id in (:idsDocumentoCobranca) )";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentoCobranca", idsDocumentosCobranca);

			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Deleta as OrdemServico geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarOrdemServicoGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM OrdemServico "
					+ "WHERE cobrancaDocumento IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta as DebitoACobrar geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarDebitoACobrarGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca, Integer anoMesReferencia)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();
		Collection<Integer> idsDebitoACobrar = null;

		try {

			String consulta = "SELECT id FROM DebitoACobrar d "
					+ "WHERE d.imovel.id IN "
					+ "( SELECT c.imovel.id FROM CobrancaDocumento c WHERE c.id IN ( :idsDocumentosCobranca ) ORDER BY c.id ) "
					+ " and d.anoMesReferenciaDebito = :anoMesReferenciaDebito"
					+ " and d.debitoTipo.id = " + DebitoTipo.TAXA_COBRANCA;

			Query q = session
					.createQuery(consulta)
					.setParameterList("idsDocumentosCobranca",
							idsDocumentosCobranca)
					.setInteger("anoMesReferenciaDebito", anoMesReferencia);

			idsDebitoACobrar = q.list();

			if (idsDebitoACobrar != null && idsDebitoACobrar.size() > 0) {

				String exclusao1 = "DELETE FROM DebitoACobrarCategoria dac "
						+ "WHERE dac.id.debitoACobrar IN ( :idsDebitosACobrar ) ";

				q = session.createQuery(exclusao1).setParameterList(
						"idsDebitosACobrar", idsDebitoACobrar);

				q.executeUpdate();

				String exclusao2 = "DELETE FROM DebitoACobrar dac "
						+ "WHERE dac.id IN ( :idsDebitosACobrar ) ";

				q = session.createQuery(exclusao2).setParameterList(
						"idsDebitosACobrar", idsDebitoACobrar);

				retorno += (Integer) q.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta as CobrancaDocumentoItem geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarCobrancaDocumentoItemGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumentoItem cdi "
					+ "WHERE cdi.cobrancaDocumento.id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta os Documentos de Cobranca com os Ids passados como parametro
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarCobrancaDocumentos(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumento "
					+ "WHERE id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deletar os registros de imoveis nao gerados
	 * 
	 * @author Francisco do Nascimento
	 * @date 17/11/2009
	 */
	public void removerImoveisNaoGerados(Integer idCobrancaComandoCronograma,
			Integer idCobrancaComandoEventual) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM ImovelNaoGerado ing WHERE ";
			if (idCobrancaComandoCronograma != null) {
				consulta += " ing.cobrancaAcaoAtividadeCronograma.id =  "
						+ idCobrancaComandoCronograma;
			} else {
				consulta += " ing.cobrancaAcaoAtividadeComando.id =  "
						+ idCobrancaComandoEventual;
			}

			Query q = session.createQuery(consulta);
			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Inserir os registros de imoveis nao gerados dos documentos excedentes
	 * 
	 * @author Francisco do Nascimento
	 * @date 18/11/2009
	 */
	public void inserirImoveisNaoGeradosParaDocumentosExcedentes(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		String sequence = Util
				.obterNextValSequence("cobranca.seq_imovel_nao_gerado");
		try {
			stmt = con.createStatement();

			String consulta = " insert into cobranca.imovel_nao_gerado "
					+ " select " + sequence + ", caac_id, cacm_id, "
					+ " imov_id, " + MotivoNaoGeracaoDocCobranca.EXCEDEU_METAS
					+ ", " + Util.obterSQLDataAtual()
					+ " FROM cobranca.cobranca_documento where cbdo_id in (-1 ";
			for (Iterator iter = idsDocumentosCobranca.iterator(); iter
					.hasNext();) {
				Integer id = (Integer) iter.next();
				consulta += ", " + id;
			}
			consulta += ")";

			stmt.executeUpdate(consulta);

		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no SQL");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisar Quantidade de Ordens de Serviço Encerradas
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer pesquisarQuantidadeOrdensServicoEncerradasPorCobrancaAcaoAtividade(
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where += " AND cd.caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where += " AND cd.cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT orse_id FROM atendimentopublico.ordem_servico os "
					+ "INNER JOIN cobranca.cobranca_documento cd ON (os.cbdo_id = cd.cbdo_id) "
					+ "WHERE os.orse_cdsituacao <> "
					+ OrdemServico.SITUACAO_PENDENTE
					+ " "
					+ where
					+ " and ROWNUM <= 1";

			SQLQuery q = session.createSQLQuery(consulta);

			q.addScalar("orse_id", Hibernate.INTEGER);
			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma",
						idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando",
						idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar Quantidade de Pagamentos por Documentos de Cobrança
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer pesquisarQuantidadePagamentosPorDocumentosCobranca(
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where = "caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where = " cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT pgmt_id from arrecadacao.pagamento where "
					+ "cbdo_id IN ( SELECT cbdo_id FROM cobranca.cobranca_documento cd WHERE "
					+ where + " ) " + " AND ROWNUM <= 1";

			SQLQuery q = session.createSQLQuery(consulta);
			q.addScalar("pgmt_id", Hibernate.INTEGER);
			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma",
						idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando",
						idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar Quantidade de Comandos realizados de Ações de Cobrança
	 * sucessoras
	 * 
	 * @author Victor Cisneiros
	 * @date 23/12/2008
	 */
	public Integer pesquisarQuantidadeComandosSucessores(
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where = " caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where = " cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT cd1.cbdo_id id FROM cobranca.cobranca_documento cd1 "
					+ "WHERE "
					+ where
					+ "AND exists ( "
					+ "SELECT cd2.cbdo_id FROM cobranca.cobranca_documento cd2 "
					+ "WHERE cd1.imov_id = cd2.imov_id AND cd2.cbdo_tmemissao > cd1.cbdo_tmemissao "
					+ "AND cbac_id IN ( "
					+ "SELECT ca.cbac_id FROM cobranca.cobranca_acao ca WHERE cd1.cbac_id = ca.cbac_idacaoprecedente "
					+ ") " + ") and ROWNUM <= 1";

			SQLQuery q = session.createSQLQuery(consulta);
			q.addScalar("id", Hibernate.INTEGER);

			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma",
						idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando",
						idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0868] Gerar Relatorio de Pagamentos das Contas em Cobranca por Empresa
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioPagamentosContasCobrancaEmpresa(
			RelatorioPagamentosContasCobrancaEmpresaHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select ecc.imov_id as idImovel, " // 0
					+ "c.clie_nmcliente as nomeCliente, " // 1
					+ "eccp.eccp_amreferenciapagamento as anoMesConta, "// 2
					+ "ecc.ecco_vloriginalconta as valorConta, "// 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ "(select sum( coalesce(eccp_vlpagamentomes,0)) "
					+ "from cobranca.empr_cobr_conta_pagto eccp_sub "
					+ "where (eccp_sub.dbtp_id not in ( 80, 91, 94, 100 ) or eccp_sub.dbtp_id is null) and eccp_sub.ecco_id = ecc.ecco_id and eccp_sub.eccp_id = eccp.eccp_id ) as valorPrincipal, "// 5
					+ "(select sum(coalesce(eccp_vlpagamentomes,0) ) from cobranca.empr_cobr_conta_pagto eccp_sub "
					+ "where eccp_sub.dbtp_id in ( 80, 91, 94, 100 ) and eccp_sub.ecco_id = ecc.ecco_id and eccp_sub.eccp_id = eccp.eccp_id) as valorEncargos, "// 6
					+ "ecc.ecco_pcempresaconta as percentualEmpresa, " // 7
					+ "imovel.loca_id, " // 8
					+ "loca.loca_nmlocalidade "// 9
					+ "loca.greg_id, " // 10
					+ "greg.greg_nmregional, " // 11
					+ "loca.uneg_id, " // 12
					+ "uneg.uneg_nmunidadenegocio, " // 13
					+ "rota.rota_id " // 14
					+ "from cobranca.empr_cobr_conta_pagto eccp "
					+ "inner join cadastro.cliente_imovel ci on ( ci.imov_id = eccp.imov_id and ci.crtp_id = 2 and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente c on ( c.clie_id = ci.clie_id ) "
					+ "inner join cobranca.empresa_cobranca_conta ecc on ( ecc.ecco_id  = eccp.ecco_id )  "
					+ "inner join cadastro.imovel imovel on imovel.imov_id = eccp.imov_id "
					+ "inner join cadastro.localidade loca on loca.loca_id = imovel.loca_id "
					+ "inner join cadastro.unidade_negocio uneg on uneg.uneg_id = loca.uneg_id "
					+ "inner join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "inner join cadastro.quadra qdra on qdra.qdra_id = imovel.qdra_id "
					+ "inner join micromedicao.rota rota on rota.rota_id = qdra.rota_id "
					+ "where (eccp.eccp_ampagamento between :referenciaPagamentoInicial and :referenciaPagamentoFinal) and ecc.empr_id = :idEmpresa ";

			if (helper.getOpcaoTotalizacao() != null
					&& !helper.getOpcaoTotalizacao().equals("")) {

				if (helper.getOpcaoTotalizacao().equalsIgnoreCase("estado")) {

					consulta = consulta + " ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"estadoGerencia")) {

					consulta = consulta
							+ "order by greg.greg_id, uneg.uneg_id, loca.loca_id, "
							+ "imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"estadoUnidadeNegocio")) {

					consulta = consulta
							+ "order by greg.greg_id, uneg.uneg_id, loca.loca_id, "
							+ "imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"estadoLocalidade")) {

					consulta = consulta
							+ "order by loca.loca_id, imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"gerenciaRegional")) {

					consulta = consulta + "greg.gre_id = "
							+ helper.getCodigoGerencia()
							+ "greg.greg_id, uneg.uneg_id, imovel.imov_id, "
							+ "eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"gerenciaRegionalLocalidade")) {

					consulta = consulta
							+ "order by greg.greg_id, uneg.uneg_id, loca.loca_id, "
							+ "imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"unidadeNegocio")) {

					consulta = consulta
							+ " and uneg.uneg_id =  "
							+ helper.getUnidadeNegocio()
							+ " "
							+ "order by uneg.uneg_id, loca.loca_id, imovel.imov_id, "
							+ "eccp.eccp_amreferenciapagamento";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"localidade")) {

					consulta = consulta
							+ " and loca.loca_id =  "
							+ helper.getCodigoLocalidade()
							+ " "
							+ "order by  loca.loca_id, imovel.imov_id, eccp.eccp_amreferenciapagamento ";
				}

			}

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER)
					.addScalar("valorPrincipal", Hibernate.BIG_DECIMAL)
					.addScalar("valorEncargos", Hibernate.BIG_DECIMAL)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL)
					.setInteger("idEmpresa", helper.getEmpresa().getId())
					.setInteger("referenciaPagamentoInicial",
							helper.getReferenciaPagamentoInicial())
					.setInteger("referenciaPagamentoFinal",
							helper.getReferenciaPagamentoFinal()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0868] Gerar Relatorio de Pagamentos das Contas em Cobranca por Empresa
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioPagamentosContasCobrancaEmpresaCount(
			Integer idEmpresa, Integer referenciaPagamentoInicial,
			Integer referenciaPagamentoFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select count(ecc.imov_id) as qtdeRelatorio " // 0
					+ "from cobranca.empr_cobr_conta_pagto eccp "
					+ "inner join cadastro.cliente_imovel ci on ( ci.imov_id = eccp.imov_id and ci.crtp_id = 2 and ci.clim_dtrelacaofim is null ) "
					+ "inner join cobranca.empresa_cobranca_conta ecc on (eccp.ecco_id = ecc.ecco_id)  "
					+ "where ecc.empr_id = :idEmpresa "
					+ "and (eccp.eccp_ampagamento between :referenciaPagamentoInicial and :referenciaPagamentoFinal) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("qtdeRelatorio", Hibernate.INTEGER)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("referenciaPagamentoInicial",
							referenciaPagamentoInicial)
					.setInteger("referenciaPagamentoFinal",
							referenciaPagamentoFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0879] Gerar Extensao Comando Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 02/02/2009
	 */

	public Collection<Object[]> pesquisarDadosGerarExtensaoComandoContasCobrancaEmpresaParaCobranca(
			Integer idComandoEmpresaCobrancaConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select ccce.ccce_id as idExtensao, " // 0
					+ "ccce.ccce_amreferenciacontainicial as referenciaInicial, "// 1
					+ "ccce.ccce_amreferenciacontafinal as referenciaFinal, " // 2
					+ "ccce.ccce_dtexecucao as dataExecucao," // 3
					+ "ccce.ccce_nndiasvencimentocontas as diasVencimentoContas " // 4
					// + "count(ecco.cecc_id) as valorOriginalConta, " //4
					// + "sum(ecco.ecco_vloriginalconta) as somaContas "//5
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "left join cobranca.empresa_cobranca_conta ecco on ecco.ccce_id = ccce.ccce_id "
					+ "where ccce.cecc_id = :idComandoEmpresaCobrancaConta "
					+ "group by ccce.ccce_id, ccce.ccce_amreferenciacontainicial, ccce.ccce_amreferenciacontafinal, ccce.ccce_dtexecucao,ccce.ccce_nndiasvencimentocontas ";

			/*
			 * consulta = "select ccce.id, " // 0 +
			 * "ccce.referenciaContaInicial, "//1 +
			 * "ccce.referenciaContaFinal, " //2 + "ccce.dataExecucao, " //3 +
			 * "count(ecco.comandoEmpresaCobrancaConta.id), " //4 +
			 * "sum(ecco.valorOriginalConta) "//5 +
			 * "from EmpresaCobrancaConta ecco " +
			 * "left join ecco.comandoEmpresaCobrancaContaExtensao ccce " +
			 * "where ccce.id = :idComandoEmpresaCobrancaConta " +
			 * "group by ,,, ";
			 */

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idExtensao", Hibernate.INTEGER)
					.addScalar("referenciaInicial", Hibernate.INTEGER)
					.addScalar("referenciaFinal", Hibernate.INTEGER)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("diasVencimentoContas", Hibernate.INTEGER)
					// .addScalar("somaContas",Hibernate.BIG_DECIMAL)
					.setInteger("idComandoEmpresaCobrancaConta",
							idComandoEmpresaCobrancaConta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer retornaAnoMesContaUltimaExtensao(
			Integer idComandoEmpresaCobrancaConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select max(ccce.ccce_amreferenciacontafinal) as anoMesFinal "
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "where ccce.cecc_id = :idComandoEmpresaCobrancaConta";

			retorno = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("anoMesFinal", Hibernate.INTEGER)
					.setInteger("idComandoEmpresaCobrancaConta",
							idComandoEmpresaCobrancaConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0878] Gerar Relação de Parcelamento - Visão Analitica
	 * 
	 * @author Bruno Barros
	 * 
	 * @date 04/02/2009
	 */
	public Collection<Object[]> filtrarRelacaoParcelamentoAnalitico(
			FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento,
			Integer anoMesReferenciaFaturamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		SQLQuery query = null;
		String consulta = null;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados()
						.isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( loca.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id, \n  muni.muni_nmmunicipio ";
			orderBy += " muni.muni_nmmunicipio, ";
		}

		try {

			consulta = "select \n"
					+ "  distinct \n"
					+
					// 0
					"  parc.parc_id, \n"
					+
					// 1
					"  loca.loca_id, \n"
					+
					// 2
					"  loca.loca_nmlocalidade, \n"
					+
					// 3
					"  geRe.greg_id, \n"
					+
					// 4
					"  geRe.greg_nmregional, \n"
					+
					// 5
					"  clie.clie_nmcliente, \n"
					+
					// 6
					"  parc.imov_id, \n"
					+
					// 7
					"  coalesce( clieFone.cfon_cdddd || ' ' || clieFone.cfon_nnfone, '-' ) as telefone, \n"
					+
					// 8
					"  cast( to_char( cnta.cnta_dtvencimentoconta, 'dd' ) as integer ) as diaVencimento, \n"
					+
					// 9
					"  parc.parc_nnprestacoes * parc.parc_vlprestacao as debitoParcelado, \n"
					+
					// 10
					"  parc.parc_vlprestacao as valorParcela, \n"
					+
					// 11
					"  parc.parc_vlentrada - coalesce( cd.cbdo_vldesconto, 0 ) as entrada, \n"
					+
					// 12
					"  parc.parc_tmparcelamento as dataParcelamento, \n"
					+
					// 13
					"  parc.parc_nnprestacoes as qtdParcelas, \n"
					+
					// 14
					"  case when deAC.dbac_id is not null then \n"
					+ "    coalesce( deAC.dbac_nnprestacaocobradas, 0 ) \n"
					+ "  else \n"
					+ "    coalesce( deACH.dahi_nnprestacaocobradas, 0 ) \n"
					+ "  end as prestacoesCobradas, \n"
					+
					// 15
					"  case when deAC.dbac_id is not null then \n"
					+ "    coalesce( deAC.dbac_nnprestacaodebito - deAC.dbac_nnprestacaocobradas, 0 ) \n"
					+ "  else \n"
					+ "    coalesce( deACH.dahi_nnprestacaodebito - deACH.dahi_nnprestacaocobradas, 0 ) \n"
					+ "  end as qtdNaoCobradas, \n" +
					// 16
					"  unNe.uneg_nmabreviado as nomeUnidade, \n" +
					// 17
					"  usur.usur_nmlogin as login, \n" +
					// 18
					"  deAC.dbac_id as idDebitoACobrar, \n" +
					// 19
					"  deACH.dbac_id as idDebitoACobrarHistorico \n"
					+

					selectMunicipio
					+ "from \n"
					+ "    cobranca.parcelamento parc \n"
					+ "    inner join cadastro.localidade loca on ( loca.loca_id = parc.loca_id ) \n"
					+ joinMunicipio
					+ "    inner join cadastro.gerencia_regional geRe on ( geRe.greg_id = loca.greg_id ) \n"
					+ "    inner join cadastro.unidade_negocio unNe on ( loca.uneg_id = unNe.uneg_id ) \n"
					+ "    inner join cadastro.cliente clie on ( clie.clie_id = parc.clie_id ) \n"
					+ "    left join seguranca.usuario usur ON usur.usur_id = parc.usur_id \n"
					+ "    left join cadastro.unidade_organizacional unid ON usur.unid_id = unid.unid_id \n"
					+ "    inner join cadastro.imovel imo on ( imo.imov_id = parc.imov_id ) \n"
					+ "    inner join cadastro.quadra qua on ( qua.qdra_id = imo.qdra_id ) \n"
					+ "    left join cobranca.cobranca_documento cd on ( cd.parc_id = parc.parc_id ) "
					+ "	 left join cadastro.cliente_fone clieFone on ( clieFone.clie_id = clie.clie_id and \n"
					+ "	 clieFone.cfon_icfonepadrao = 1 ) \n"
					+ "	 left join faturamento.conta cnta on ( cnta.imov_id = parc.imov_id and cnta. \n"
					+ "	 cnta_amreferenciaconta = :anoMesReferenciaFaturamento ) \n"
					+ "	 left join faturamento.debito_a_cobrar deAC on ( deAC.parc_id = parc.parc_id \n"
					+ "	 and deAC.dcst_idatual in (1,0) and deAC.dbtp_id in ( 40, 41,42, 43, 45, 47,50 ) \n"
					+ "	 and \n"
					+ "	 deAC.dbac_id = (select min(auxiliar.dbac_id) from faturamento.debito_a_cobrar auxiliar \n"
					+ "	 where auxiliar.parc_id = parc.parc_id \n"
					+ "	 and auxiliar.dcst_idatual in (1,0) and auxiliar.dbtp_id in ( 40, 41,42, 43, 45, 47,50 ))) \n"
					+ "	 left join faturamento.deb_a_cobrar_hist deACH on ( deACH.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) and deACH.parc_id = parc.parc_id \n"
					+ "	 and \n"
					+ "	 deACH.dbac_id = (select min(auxiliarHistorico.dbac_id) from faturamento.deb_a_cobrar_hist auxiliarHistorico \n"
					+ "	 where auxiliarHistorico.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) and auxiliarHistorico.parc_id = parc.parc_id)) \n"
					+ "where \n"
					+ "  parc.pcst_id = 1 and \n"
					+ "  not exists ( select 'a' from cobranca.parcelamento_item parcItem where parcItem.dbac_id = deAC.dbac_id ) and \n"
					+ "  not exists ( select 'a' from cobranca.parcelamento_item parcItem where parcItem.dbac_id = deACH.dbac_id ) \n";

			// Verificamos quais os filtros informados
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				consulta += " and geRe.greg_id = :idGerenciaRegional \n";
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				consulta += " and unNe.uneg_id = :idUnidadeNegocio \n";
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				consulta += " and loca.loca_cdelo = :idElo \n";
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and parc.loca_id = :idLocalidade ";
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and loca.muni_idprincipal IN ( :idMunicipios )";
				if (!temLocalidade) {
					consulta += " and parc.loca_id = loca.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				consulta += " and parc.parc_cdsetorcomercial = :cdSetorComercial \n";
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and qua.qdra_nnquadra = :numeroQuadra \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				consulta += " and parc.usur_id = :idUsuario \n";
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				consulta += " and parc.parc_tmparcelamento between :dataInicial and :dataFinal \n";
			}

			if (filtrarRelacaoParcelamento.getAnoMesReferenciaContabil() != null) {

				consulta += " and parc.parc_amreferenciafaturamento = :anoMesReferenciaContabil \n";

			}

			if (filtrarRelacaoParcelamento.getPeriodoContabil() != null) {

				consulta += " and parc.parc_amreferenciafaturamento like :periodoContabil";
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel()
							.isEmpty()) {
				consulta += " and imo.iper_id in (:idsPerfisImovel) \n";

			}

			// Coleção Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional \n";

			}

			consulta += orderBy + "  loca_id, \n" + "  greg_id, \n"
					+ "  clie_nmcliente \n";

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
					.getColecaoMunicipiosAssociados())) {
				query = session
						.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("telefone", Hibernate.STRING)
						.addScalar("diaVencimento", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.INTEGER)
						.addScalar("prestacoesCobradas", Hibernate.INTEGER)
						.addScalar("qtdNaoCobradas", Hibernate.INTEGER)
						.addScalar("nomeUnidade", Hibernate.STRING)
						.addScalar("login", Hibernate.STRING)
						.addScalar("muni_id", Hibernate.INTEGER)
						.addScalar("muni_nmmunicipio", Hibernate.STRING)
						.addScalar("idDebitoACobrar", Hibernate.INTEGER)
						.addScalar("idDebitoACobrarHistorico",
								Hibernate.INTEGER);
			} else {
				query = session
						.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("telefone", Hibernate.STRING)
						.addScalar("diaVencimento", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.INTEGER)
						.addScalar("prestacoesCobradas", Hibernate.INTEGER)
						.addScalar("qtdNaoCobradas", Hibernate.INTEGER)
						.addScalar("nomeUnidade", Hibernate.STRING)
						.addScalar("login", Hibernate.STRING)
						.addScalar("idDebitoACobrar", Hibernate.INTEGER)
						.addScalar("idDebitoACobrarHistorico",
								Hibernate.INTEGER);
			}

			query.setInteger("anoMesReferenciaFaturamento",
					anoMesReferenciaFaturamento);

			// Adicionamos os parametros necessários
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				query.setInteger("idGerenciaRegional",
						filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				query.setInteger("idUnidadeNegocio",
						filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				query.setInteger("idLocalidade", filtrarRelacaoParcelamento
						.getParcelamento().getLocalidade().getId());
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				query.setParameterList("idMunicipios",
						filtrarRelacaoParcelamento
								.getColecaoMunicipiosAssociados());
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				query.setInteger("cdSetorComercial", filtrarRelacaoParcelamento
						.getParcelamento().getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				query.setInteger("numeroQuadra", filtrarRelacaoParcelamento
						.getParcelamento().getNumeroQuadra());
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				query.setTimestamp("dataInicial",
						filtrarRelacaoParcelamento.getDataParcelamentoInicial());
				query.setTimestamp("dataFinal",
						filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if (filtrarRelacaoParcelamento.getAnoMesReferenciaContabil() != null) {
				query.setInteger("anoMesReferenciaContabil",
						filtrarRelacaoParcelamento
								.getAnoMesReferenciaContabil());
			}

			if (filtrarRelacaoParcelamento.getPeriodoContabil() != null) {
				query.setString("periodoContabil",
						filtrarRelacaoParcelamento.getPeriodoContabil());
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel()
							.isEmpty()) {

				query.setParameterList("idsPerfisImovel",
						filtrarRelacaoParcelamento.getColecaoPerfilImovel());
			}

			// coleção Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				query.setInteger("idUnidadeOrganizacional",
						filtrarRelacaoParcelamento.getIdUnidadeOrganizacional());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {

				query.setInteger("idUsuario",
						filtrarRelacaoParcelamento.getIdUsuarioResponsavel());
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [FS0028] Verifica se
	 * existeParcelas em atraso [FS0029] Verificar se existe parcelamento em
	 * andamento
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterParcelamentoMaisAtualDoImovel(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parc.id, "// 0
					+ "rdir.id, "// 1
					+ "rdir.numeroResolucaoDiretoria "// 2
					+ "FROM Parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "INNER JOIN parc.parcelamentoSituacao parcSit "
					+ "LEFT JOIN parc.resolucaoDiretoria rdir "
					+ "WHERE imov.id = :idImovel AND parcSit.id = :parcNormal "
					+ "ORDER BY parc.parcelamento desc ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("parcNormal", ParcelamentoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [FS0028] Verifica se
	 * existeParcelas em atraso [FS0029] Verificar se existe parcelamento em
	 * andamento
	 * 
	 * verificar se existe parcelas a serem cobradas (selecionar na tabela de
	 * debito a cobrar (FATURAMENTO.DEBITO_A_COBRAR), a linha que tenha o
	 * PARC_ID = PARC_ID da tabela COBRANCA.PARCELAMENTO e o tipo de débito
	 * (DBTP_ID) = 40) e caso o número de prestações do débito não seja igual ao
	 * número de prestações cobradas
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection obterDebitoACobrarDoParcelamento(Integer idParcelamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac.id "
					+ " from DebitoACobrar dac "
					+ " inner join dac.debitoTipo debitoTipo "
					+ " inner join dac.parcelamento parcelamento "
					+ " where parcelamento.id = :idParcelamento "
					+ " and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ " and debitoTipo.id = :debitoTipo ";

			retorno = session.createQuery(consulta)
					.setInteger("debitoTipo", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [FS0028] Verifica se
	 * existeParcelas em atraso
	 * 
	 * verificar se existe parcelas em atraso, ou seja, verificar nas contas que
	 * irão fazer parte do parcelamento, se existe algum débito de parcelamento
	 * da RDIR_ID = RDIR_IDPARCELASEMATRASO
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasComParcelasEmAtrasoDoParcelamento(
			Integer idImovel, Integer refInicialInformada,
			Integer refFinalInformada) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// consulta =
			// "select c.cnta_id as idConta from faturamento.conta c "
			// +
			// " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada  "
			// +
			// " and exists (select dbcb_id from faturamento.debito_cobrado d "
			// + " 	        where d.cnta_id = c.cnta_id "
			// + " 		    and dbtp_id = :idDebitoTipo "
			// + " 		    and d.dbac_id in (select dbac_id "
			// + "								  from faturamento.debito_a_cobrar_historico h "
			// + "								  where h.parc_id = :idParcelamento) "
			// + " 		    ) ";

			// consulta =
			// " select c.cnta_id as idConta from faturamento.conta c "
			// +
			// " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada "
			// + " and current_timestamp > cnta_dtvencimentoconta "
			// +
			// " and cnta_id in(select cnta_id from faturamento.debito_cobrado d "
			// +
			// "                where dbtp_id = :idDebitoTipo and d.dbac_id in (select dbac_id  "
			// +
			// "                                                     from faturamento.debito_a_cobrar_historico h "
			// +
			// "                                                     where h.parc_id = :idParcelamento) )"
			// ;

			consulta = " select c.cnta_id as idConta from faturamento.conta c "
					+ " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada "
					+ " and current_timestamp > cnta_dtvencimentoconta "
					+ " and imov_id = :idImovel "
					+ " and cnta_id in(select cnta_id from faturamento.debito_cobrado d "
					+ "                where dbtp_id = :idDebitoTipo )";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.setInteger("refInicialInformada", refInicialInformada)
					.setInteger("refFinalInformada", refFinalInformada)
					.setInteger("idDebitoTipo", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0880] Gerar Movimento de Extensão de Contas em Cobrança por Empresa
	 * 
	 * Pesquisa as contas associadas ao imóvel
	 * 
	 * @author: Rômulo Aurélio
	 * @throws SQLException
	 * @date: 13/02/2009
	 */
	public void inserirMovimentoExtensaoContasEmCobranca(Integer idLocalidade,
			Integer idPerfil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		// Collection<Object[]> retorno = null;
		String consulta = null;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		SistemaParametro sistemaParametro = RepositorioUtilHBM.getInstancia()
				.pesquisarParametrosDoSistema();

		try {
			stmt = con.createStatement();
			String sequence = Util
					.obterNextValSequence("cobranca.seq_empresa_cobranca_conta");
			String dataAtualBanco = Util.obterSQLDataAtual();
			consulta = "INSERT into cobranca.empresa_cobranca_conta ( ecco_id,"
					+ "empr_id, " + "cnta_id, " + "ecco_vloriginalconta, "
					+ "ecco_pcempresaconta, " + "ecco_tmultimaalteracao, "
					+ "cecc_id, " + "ecco_icpagamentovalido, " + "ccce_id, "
					+ "imov_id," + "ecco_amreferenciaconta,"
					+ "ecco_dtenvioconta) " + "select "
					+ sequence
					+ ", "
					+ "aux.idEmpresa as idEmpresa, " // 1
					+ "cnta.cnta_id as idConta, " // 2
					+ "( coalesce( cnta.cnta_vlagua, 0 ) + "
					+ "coalesce( cnta.cnta_vlesgoto, 0 ) + "
					+ "coalesce( cnta.cnta_vldebitos, 0 ) - "
					+ "coalesce( cnta.cnta_vlcreditos, 0 ) - "
					+ "coalesce( cnta.cnta_vlimpostos, 0 ) "
					+ ") as valorConta, " // 3
					+ "aux.pcEmpresaConta as pcEmpresaConta, " // 4
					+ dataAtualBanco
					+ " as ultimaAlteracao, " // 5
					+ "aux.idComando as idComando, " // 6
					+ "1 as indicadorPagamentoValido, " // 7
					+ "aux.idExtensao as idExtensao, " // 8
					+ "aux.idImovel as idImovel," // 9
					+ "cnta.cnta_amreferenciaconta as referenciaConta, " // 10
					+ dataAtualBanco
					+ " as dataEnvioConta " // 11
					+ "from faturamento.conta cnta "
					+ "inner join (select DISTINCT ecco.imov_id as idImovel, "
					+ "ecco.empr_id as idEmpresa, "
					+ "ecco.ecco_pcempresaconta as pcEmpresaConta, "
					+ "ecco.cecc_id as idComando, "
					+ "ccce.ccce_id as idExtensao, "
					+ "ccce.ccce_amreferenciacontainicial as referencialInicialExtensao, "
					+ "ccce.ccce_amreferenciacontafinal as referencialFinalExtensao, "
					+ "coalesce(ccce.ccce_nndiasvencimentocontas, 0 )   AS numDiasVenContas "
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "inner join cobranca.empresa_cobranca_conta ecco on ecco.cecc_id = ccce.cecc_id "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "where imov.loca_id =  "
					+ idLocalidade
					+ " "
					+ "and ccce.ccce_dtexecucao is null ";

			if (idPerfil != null) {
				consulta = consulta + " and imov.iper_id <> " + idPerfil;
			}

			if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca() == 1) {

				consulta = consulta
						+ " and ("
						+ " ccce.ccce_nndiasvencimentocontas is null or"
						+ " exists("
						+ "		select cnta2.cnta_id from faturamento.conta cnta2 "
						+ "        where cnta2.cnta_dtvencimentooriginal <= to_date("
						+ dataAtualBanco
						+ ",'YYYY-MM-DD') - ccce.ccce_nndiasvencimentocontas "
						+ "        and cnta2.dcst_idatual in (0,1,2) "
						+ "        and NOT EXISTS (select pgmt.cnta_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta2.cnta_id) "
						+ "        and NOT EXISTS (select ecco.cnta_id from cobranca.empresa_cobranca_conta ecco where ecco.cnta_id = cnta2.cnta_id and ecco.ecco_dtretiradaconta is null) "
						+ "        and cnta2.cnta_amreferenciaconta between ccce.ccce_amreferenciacontainicial and ccce.ccce_amreferenciacontafinal"
						+ "        and cnta2.imov_id = ecco.imov_id  "
						+ " 	  ))";

			}

			consulta = consulta
					+ " ) aux "
					+ "on aux.idimovel = cnta.imov_id "
					+ "where  cnta.cnta_amreferenciaconta between aux.referencialInicialExtensao and aux.referencialFinalExtensao "
					+ "and cnta.dcst_idatual in (0,1,2) "
					+ "and NOT EXISTS (select pgmt.cnta_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta.cnta_id) "
					+ "and NOT EXISTS (select ecco.cnta_id from cobranca.empresa_cobranca_conta ecco where ecco.cnta_id = cnta.cnta_id and ecco.ecco_dtretiradaconta is null) "
					+ "and NOT EXISTS (select ircm.imov_id from cobranca.imovel_retirada_comando ircm where idComando = ircm.cecc_id and ircm.imov_id = cnta.imov_id) ";
			if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca() == 2) {
				consulta += " and cnta.cnta_dtvencimentooriginal <= to_date("
						+ dataAtualBanco
						+ ",'YYYY-MM-DD') - aux.numDiasVenContas ";
			}

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	public Collection obterUnidadeNegocioEmpresaCobrancaConta(Integer[] ids)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select loca.uneg_id as idUnidadeNegocio "
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "inner join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "where ecco.cecc_id in ( :ids ) "
					+ "group by loca.uneg_id  ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.setParameterList("ids", ids).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0891] Gerar Relatorio de Imóveis com Acordo
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioImoveisComAcordo(
			Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal, Integer idGerenciaRegional,
			Date dataInicialAcordo, Date dataFinalAcordo, Integer rotaInicial,
			Integer rotaFinal, Integer sequencialRotaInicial,
			Integer sequencialRotaFinal, Integer idSetorComercialInicial,
			Integer idSetorComercialFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select distinct imov.imov_id as idImovel, " // 0
					+ "rota.rota_cdrota as codigoRota, "// 1
					+ "imov.imov_nnsequencialrota as sequencialRota, " // 2
					+ "last.last_dsligacaoaguasituacao as situacaoLigacaoAgua, "// 3
					+ "lest.lest_dsligacaoesgotosituacao as situacaoLigacaoEsgoto, "// 4
					+ "cbsp.cbsp_dscobrancasituacaotipo as tipoSituacaoCobranca, " // 5
					+ "cbsh.cbsh_amcobrancasituacaoinicio as anoMesInicial, "// 6
					+ "cbsh.cbsh_amcobrancasituacaofim as anoMesFinal, " // 7
					+ "cbsh.cbsh_dtfimsituacao as dataFinalSituacao, "// 8
					+ "cbsh.cbsh_dsobservacaoinforma as observacao, "// 9
					+ "usur.usur_nmusuario as nomeUsuario "// 10
					+ "from cobranca.cobranca_situacao_hist cbsh "
					+ "left join cadastro.imovel imov on imov.imov_id = cbsh.imov_id "
					+ "left join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "left join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id  "
					+ "left join cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id  "
					+ "left join atendimentopublico.ligacao_agua_situacao last on last.last_id = imov.last_id "
					+ "left join atendimentopublico.ligacao_esgoto_situacao lest on lest.lest_id = imov.lest_id "
					+ "left join micromedicao.rota rota on rota.rota_id = qdra.rota_id  "
					+ "left join cobranca.cobranca_situacao_tipo cbsp on cbsp.cbsp_id = cbsh.cbsp_id "
					+ "left join seguranca.usuario usur on usur.usur_id = cbsh.usur_id  "
					+ "where cbsh.cbsh_amcobrancaretirada is null "
					+ "and cbsh.cbsh_dtfimsituacao between ('"
					+ Util.getSQLDate(dataInicialAcordo).toString()
					+ "') and ('"
					+ Util.getSQLDate(dataFinalAcordo).toString()
					+ "') ";

			if (idUnidadeNegocio != null) {
				consulta = consulta + "and loca.uneg_id = " + idUnidadeNegocio
						+ " ";
			}

			if (idGerenciaRegional != null) {
				consulta = consulta + "and greg.greg_id = "
						+ idGerenciaRegional + " ";
			}

			if (idLocalidadeInicial != null && idLocalidadeFinal != null) {

				consulta = consulta + "and loca.loca_id between (' "
						+ idLocalidadeInicial + "')" + " and ('"
						+ idLocalidadeFinal + "') ";

				if (idSetorComercialInicial != null
						&& idSetorComercialFinal != null) {
					consulta = consulta
							+ "and stcm.stcm_cdsetorcomercial  between (' "
							+ idSetorComercialInicial + "')" + " and ('"
							+ idSetorComercialFinal + "') ";
				}
				if (rotaInicial != null && rotaFinal != null) {
					consulta = consulta + "and rota.rota_id between (' "
							+ rotaInicial + "')" + " and ('" + rotaFinal
							+ "') ";
				}
				if (sequencialRotaInicial != null
						&& sequencialRotaFinal != null) {
					consulta = consulta
							+ "and imov.imov_nnsequencialrota between (' "
							+ sequencialRotaInicial + "')" + " and ('"
							+ sequencialRotaFinal + "') ";
				}

			}

			consulta = consulta
					+ " "
					+ "group by imov.imov_id,rota.rota_cdrota,imov.imov_nnsequencialrota,last.last_dsligacaoaguasituacao,lest.lest_dsligacaoesgotosituacao,cbsp.cbsp_dscobrancasituacaotipo,cbsh.cbsh_amcobrancasituacaoinicio,cbsh.cbsh_amcobrancasituacaofim,cbsh.cbsh_dtfimsituacao,cbsh.cbsh_dsobservacaoinforma,usur.usur_nmusuario ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("codigoRota", Hibernate.INTEGER)
					.addScalar("sequencialRota", Hibernate.INTEGER)
					.addScalar("situacaoLigacaoAgua", Hibernate.STRING)
					.addScalar("situacaoLigacaoAgua", Hibernate.STRING)
					.addScalar("tipoSituacaoCobranca", Hibernate.STRING)
					.addScalar("anoMesInicial", Hibernate.INTEGER)
					.addScalar("anoMesFinal", Hibernate.INTEGER)
					.addScalar("dataFinalSituacao", Hibernate.DATE)
					.addScalar("observacao", Hibernate.STRING)
					.addScalar("nomeUsuario", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer pesquisarDadosGerarRelatorioImoveisComAcordoCount(
			Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal, Integer idGerenciaRegional,
			Date dataInicialAcordo, Date dataFinalAcordo, Integer rotaInicial,
			Integer rotaFinal, Integer sequencialRotaInicial,
			Integer sequencialRotaFinal, Integer idSetorComercialInicial,
			Integer idSetorComercialFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(distinct imov.imov_id) as qtde "
					+ "from cobranca.cobranca_situacao_hist cbsh "
					+ "left join cadastro.imovel imov on imov.imov_id = cbsh.imov_id "
					+ "left join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "left join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id  "
					+ "left join cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id  "
					+ "left join atendimentopublico.ligacao_agua_situacao last on last.last_id = imov.last_id "
					+ "left join atendimentopublico.ligacao_esgoto_situacao lest on lest.lest_id = imov.lest_id "
					+ "left join micromedicao.rota rota on rota.rota_id = qdra.rota_id  "
					+ "left join cobranca.cobranca_situacao_tipo cbsp on cbsp.cbsp_id = cbsh.cbsp_id "
					+ "left join seguranca.usuario usur on usur.usur_id = cbsh.usur_id  "
					+ "where cbsh.cbsh_amcobrancaretirada is null "
					+ "and cbsh.cbsh_dtfimsituacao between (' "
					+ Util.getSQLDate(dataInicialAcordo).toString()
					+ "') and ('" + Util.getSQLDate(dataFinalAcordo).toString()
					+ "') ";

			if (idUnidadeNegocio != null) {
				consulta = consulta + "and loca.uneg_id = " + idUnidadeNegocio
						+ " ";
			}

			if (idGerenciaRegional != null) {
				consulta = consulta + "and greg.greg_id = "
						+ idGerenciaRegional + " ";
			}

			if (idLocalidadeInicial != null && idLocalidadeFinal != null) {
				consulta = consulta + "and loca.loca_id between (' "
						+ idLocalidadeInicial + "')" + " and ('"
						+ idLocalidadeFinal + "') ";

				if (idSetorComercialInicial != null
						&& idSetorComercialFinal != null) {
					consulta = consulta
							+ "and stcm.stcm_cdsetorcomercial between (' "
							+ idSetorComercialInicial + "')" + " and ('"
							+ idSetorComercialFinal + "') ";
				}
				if (rotaInicial != null && rotaFinal != null) {
					consulta = consulta + "and rota.rota_id between (' "
							+ rotaInicial + "')" + " and ('" + rotaFinal
							+ "') ";
				}
				if (sequencialRotaInicial != null
						&& sequencialRotaFinal != null) {
					consulta = consulta
							+ "and imov.imov_nnsequencialrota between (' "
							+ sequencialRotaInicial + "')" + " and ('"
							+ sequencialRotaFinal + "') ";
				}

			}

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("qtde", Hibernate.INTEGER).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public CicloMetaGrupo pesquisarCicloMetaGrupoPorGrupoLocalidade(
			int idCicloMeta, int idGrupo, int idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		CicloMetaGrupo retorno = null;
		String consulta = null;

		try {

			consulta = "select cmg " + "from gcom.cobranca.CicloMetaGrupo cmg "
					+ "where cmg.cobrancaGrupo.id = :idCobGrupo "
					+ "and cmg.cicloMeta.id = :idCicloMeta "
					+ "and cmg.localidade.id = :idLocalidade ";

			retorno = (CicloMetaGrupo) session.createQuery(consulta)
					.setInteger("idCobGrupo", idGrupo)
					.setInteger("idCicloMeta", idCicloMeta)
					.setInteger("idLocalidade", idLocalidade).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public CicloMeta pesquisarMetaCiclo(int anoMes, int idCobrancaAcao)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		CicloMeta retorno = null;
		String consulta = null;

		try {

			consulta = "select cm " + "from gcom.cobranca.CicloMeta cm "
					+ "where cm.cobrancaAcao.id = :idCobAcao "
					+ "and cm.anoMesReferencia = :anoMes ";

			retorno = (CicloMeta) session.createQuery(consulta)
					.setInteger("idCobAcao", idCobrancaAcao)
					.setInteger("anoMes", anoMes).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarQuantidadeDocumentosGeradosAcimaValorLimite(
			Integer idCAAC, Integer idCACM, Integer idLocalidade,
			BigDecimal valorLimite) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(cd.id) "
					+ "from gcom.cobranca.CobrancaDocumento cd where ";
			if (idCAAC != null) {
				consulta += " cd.cobrancaAcaoAtividadeCronograma.id = "
						+ idCAAC;
			} else if (idCACM != null) {
				consulta += " cd.cobrancaAcaoAtividadeComando.id = " + idCACM;
			}
			if (idLocalidade != null) {
				consulta += " and cd.localidade.id = " + idLocalidade;
			}

			consulta += " and cd.valorDocumento >= :valorLimite ";

			retorno = (Integer) session.createQuery(consulta)
					.setBigDecimal("valorLimite", valorLimite).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarQuantidadeDocumentosGerados(Integer idCAAC,
			Integer idCACM, Integer idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(cd.id) "
					+ "from gcom.cobranca.CobrancaDocumento cd where ";
			if (idCAAC != null) {
				consulta += " cd.cobrancaAcaoAtividadeCronograma.id = "
						+ idCAAC;
			} else if (idCACM != null) {
				consulta += " cd.cobrancaAcaoAtividadeComando.id = " + idCACM;
			}
			if (idLocalidade != null) {
				consulta += " and cd.localidade.id = " + idLocalidade;
			}

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarDocumentosCobrancaExcedentes(Integer idCAAC,
			Integer idCACM, int quantidadeParaRemover, Integer idLocalidade)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String queryConsulta = null;
		Collection documentos = null;

		try {

			queryConsulta = "select cbdo_id as id, cbdo_vldocumento as valor from cobranca.Cobranca_Documento cd where ";
			if (idCAAC != null) {
				queryConsulta += " cd.caac_id = " + idCAAC;
			} else if (idCACM != null) {
				queryConsulta += " cd.cacm_id = " + idCACM;
			}
			if (idLocalidade != null) {
				queryConsulta += " and cd.loca_id = " + idLocalidade;
			}
			queryConsulta += " and ROWNUM <= " + quantidadeParaRemover
					+ " order by cd.cbdo_vldocumento";

			documentos = session.createSQLQuery(queryConsulta)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("valor", Hibernate.BIG_DECIMAL).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return documentos;
	}

	public void adicionarMetaCicloLocalidade(int idMetaCiclo, int idGrupo,
			int idLocalidade, int quantidadeASerAdicionada)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String query = null;

		try {

			query = "update gcom.cobranca.CicloMetaGrupo set clmg_qtmetaajustada = (clmg_qtmetaajustada + "
					+ quantidadeASerAdicionada
					+ "), clmg_ultimaalteracao = :data where "
					+ " clmt_id = "
					+ idMetaCiclo
					+ " and loca_id = "
					+ idLocalidade
					+ " and cbgr_id = "
					+ "(SELECT min(cm.cobrancaGrupo.id) FROM gcom.cobranca.CicloMetaGrupo cm where "
					+ " cm.cicloMeta.id = "
					+ idMetaCiclo
					+ " and cm.localidade.id = "
					+ idLocalidade
					+ " and cm.cobrancaGrupo.id > "
					+ idGrupo
					+ " and cm.quantidadeDocumentosRestantes is null)";

			session.createQuery(query).setTimestamp("data", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<CicloMetaGrupo> pesquisarCicloMetaGrupoPorCicloMeta(
			Integer idCicloMeta, Integer idGrupo)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String queryConsulta = null;
		List<CicloMetaGrupo> idsMetas = null;

		try {

			queryConsulta = "select cmg from gcom.cobranca.CicloMetaGrupo cmg where "
					+ " cmg.cicloMeta.id = "
					+ idCicloMeta
					+ " and cmg.cobrancaGrupo.id = "
					+ idGrupo
					+ " order by cmg.localidade.id ";

			idsMetas = (List) session.createQuery(queryConsulta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return idsMetas;
	}

	/**
	 * 
	 * [UC0000] - Gerar Metas do Cilo Pesquisar a quantidade de imoveis em cada
	 * grupo/localidade
	 * 
	 * @author Francisco do Nascimento
	 * @date 23/04/2009
	 * 
	 * @param idsLast
	 *            Colecao de ids de situacao de ligação de água
	 * @return Colecao no formato [idGrupo, idLocalidade, qtdImoveis]
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarQuantidadeImoveisPorGrupoLocalidade(
			Collection idsLast) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Collection colecao = null;

		try {
			query = "SELECT r.cbgr_id as idGrupo, l.loca_id as idLocalidade, "
					+ "count(imov_id) as QtdImoveis FROM micromedicao.rota r "
					+ "join cadastro.quadra q on r.rota_id = q.rota_id "
					+ "join cadastro.setor_comercial sc on sc.stcm_id = q.stcm_id "
					+ "join cadastro.localidade l on sc.loca_id = l.loca_id "
					+ "join cadastro.imovel i on i.qdra_id = q.qdra_id "
					+ "where i.last_id in (:idsLast) "
					+ "group by r.cbgr_id, l.loca_id "
					+ "order by r.cbgr_id, l.loca_id ";

			colecao = (List) session.createSQLQuery(query)
					.addScalar("idGrupo", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setParameterList("idsLast", idsLast).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return colecao;

	}

	/**
	 * [UC0216] Calcular Acrescimo por Impontualidade
	 * 
	 * Caso o imóvel tenha débito automático e o recebimento, mesmo em atraso,
	 * tenha sido através de débito automático, o sistema não calcula os
	 * acréscimos de impontualidade
	 * 
	 * (ARMV_DSIDENTIFICACAOSERVICO da tabela ARRECADADOR_MOVIMENTO com valor
	 * igual a "DEBITO AUTOMATICO" com ARMV_ID = ARMV_ID da tabela
	 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_ID = AMIT_ID da tabela PAGAMENTO com
	 * CNTA_ID = CNTA_ID recebido)
	 * 
	 * @author Raphael Rossiter
	 * @date 12/05/2009
	 * 
	 * @param idConta
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoDeContaPorDebitoAutomatico(Integer idConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT COUNT(*) FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.contaGeral cntaGeral "
					+ "INNER JOIN cntaGeral.conta cnta "
					+ "INNER JOIN pgmt.arrecadadorMovimentoItem amit "
					+ "INNER JOIN amit.arrecadadorMovimento armv "
					+ "WHERE cnta.id = :idConta AND armv.descricaoIdentificacaoServico = :debitoAutomatico ";

			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setString("debitoAutomatico",
							ConstantesSistema.DEBITO_AUTOMATICO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0868] Gerar Relatorio de Pagamentos das Contas em Cobranca por Empresa
	 * 
	 * @author: Rômulo Aurélio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioPagamentosContasCobrancaEmpresaOpcaoTotalizacao(
			RelatorioPagamentosContasCobrancaEmpresaHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select im.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnta.cnta_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 5
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 6
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 7
					+ "lc.loca_id as idLocalidade," // 8
					+ "lc.loca_nmlocalidade as nomeLocalidade, " // 9
					+ "gr.greg_id as idGerenciaRegional, " // 10
					+ "gr.greg_nmregional as nomeGerenciaRegional, " // 11
					+ "un.uneg_id as idUnidadeNegocio, " // 12
					+ "un.uneg_nmunidadenegocio as nomeUnidadeNegocio, " // 13
					+ "rt.rota_cdrota as idRota, " // 14
					+ "eccp_ictipopagamento as indicadorTipoPagamento," // 15
					+ "eccp_nnparcelaatual as numeroParcelaAtual, " // 16
					+ "eccp_nntotalparcelas as numeroTotalParcelas, "// 17
					+ "min(ccp.dbtp_id) as debitoTipo "// 18
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta  cnta "
					+ "on cnta.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id ";

			if (helper.getReferenciaPagamentoInicial() != helper
					.getReferenciaPagamentoFinal()) {
				consulta = consulta + "where eccp_ampagamento between "
						+ helper.getReferenciaPagamentoInicial() + " and "
						+ helper.getReferenciaPagamentoFinal() + " ";
			} else {
				consulta = consulta + "where eccp_ampagamento = "
						+ helper.getReferenciaPagamentoInicial() + " ";
			}

			if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegional")) {

				consulta = consulta + " and gr.greg_id = "
						+ helper.getCodigoGerencia();

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegionalLocalidade")) {

				consulta = consulta + " and gr.greg_id = "
						+ helper.getCodigoGerencia();

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"localidade")) {

				consulta = consulta + " and lc.loca_id = "
						+ helper.getCodigoLocalidade();
			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"unidadeNegocio")) {

				consulta = consulta + "and un.uneg_id = "
						+ helper.getUnidadeNegocio();

			}

			consulta = consulta
					+ "group by im.imov_id, clie_nmcliente, cnta.cnta_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, cc.ecco_pcempresaconta, lc.loca_id, lc.loca_nmlocalidade, gr.greg_id, gr.greg_nmregional, un.uneg_id, un.uneg_nmunidadenegocio, rt.rota_cdrota, eccp_ictipopagamento, eccp_nnparcelaatual,eccp_nntotalparcelas ";

			consulta = consulta
					+ "UNION "
					+ "select im.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnhi.cnhi_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 5
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 6
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 7
					+ "lc.loca_id as idLocalidade," // 8
					+ "lc.loca_nmlocalidade as nomeLocalidade, " // 9
					+ "gr.greg_id as idGerenciaRegional, " // 10
					+ "gr.greg_nmregional as nomeGerenciaRegional, " // 11
					+ "un.uneg_id as idUnidadeNegocio, " // 12
					+ "un.uneg_nmunidadenegocio as nomeUnidadeNegocio, " // 13
					+ "rt.rota_cdrota as idRota, " // 14
					+ "eccp_ictipopagamento as indicadorTipoPagamento," // 15
					+ "eccp_nnparcelaatual as numeroParcelaAtual, " // 16
					+ "eccp_nntotalparcelas as numeroTotalParcelas, "// 17
					+ "min(ccp.dbtp_id) as debitoTipo "// 18
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta_historico cnhi "
					+ "on cnhi.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id ";

			if (helper.getReferenciaPagamentoInicial() != helper
					.getReferenciaPagamentoFinal()) {
				consulta = consulta + "where eccp_ampagamento between "
						+ helper.getReferenciaPagamentoInicial() + " and "
						+ helper.getReferenciaPagamentoFinal() + " ";
			} else {
				consulta = consulta + "where eccp_ampagamento = "
						+ helper.getReferenciaPagamentoInicial() + " ";
			}

			if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegional")) {

				consulta = consulta + " and gr.greg_id = "
						+ helper.getCodigoGerencia();

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegionalLocalidade")) {

				consulta = consulta + " and gr.greg_id = "
						+ helper.getCodigoGerencia();

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"localidade")) {

				consulta = consulta + " and lc.loca_id = "
						+ helper.getCodigoLocalidade();
			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"unidadeNegocio")) {

				consulta = consulta + "and un.uneg_id = "
						+ helper.getUnidadeNegocio();

			}

			consulta = consulta
					+ "group by im.imov_id, clie_nmcliente, cnhi.cnhi_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, cc.ecco_pcempresaconta, lc.loca_id, lc.loca_nmlocalidade, gr.greg_id, gr.greg_nmregional, un.uneg_id, un.uneg_nmunidadenegocio, rt.rota_cdrota, eccp_ictipopagamento, eccp_nnparcelaatual,eccp_nntotalparcelas ";

			if (helper.getOpcaoTotalizacao().equalsIgnoreCase("estadoGerencia")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";
			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"estadoLocalidade")) {

				consulta = consulta
						+ " order by idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegional")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegionalLocalidade")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"localidade")) {

				consulta = consulta
						+ " order by idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"estadoUnidadeNegocio")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"unidadeNegocio")) {

				consulta = consulta
						+ " order by idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";

			}

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER)
					.addScalar("valorPrincipal", Hibernate.BIG_DECIMAL)
					.addScalar("valorEncargos", Hibernate.BIG_DECIMAL)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("indicadorTipoPagamento", Hibernate.SHORT)
					.addScalar("numeroParcelaAtual", Hibernate.INTEGER)
					.addScalar("numeroTotalParcelas", Hibernate.INTEGER)
					.addScalar("debitoTipo", Hibernate.INTEGER)
					.setInteger("idEmpresa", helper.getEmpresa().getId())
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos Author: Vivianne Sousa Data:
	 * 13/05/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Coleção de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarParcelamento(Integer idParcelamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join dac.parcelamento parcelamento "
					+ "inner join dac.debitoTipo debitoTipo "
					+ "where parcelamento.id = :idParcelamento "
					+ "and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id) "
					+ "and debitoTipo.id in (:jurosSobreParc, :parcContas, :parcAcrescimos) ";

			retorno = session
					.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("jurosSobreParc",
							DebitoTipo.JUROS_SOBRE_PARCELAMENTO)
					.setInteger("parcContas", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("parcAcrescimos",
							DebitoTipo.PARCELAMENTO_ACRESCIMOS_IMPONTUALIDADE)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos Author: Vivianne Sousa Data:
	 * 13/05/2009
	 * 
	 * @param idImovel
	 * @param referencia
	 * 
	 * @return idParcelamento
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdParcelamentoNormal(Integer idImovel,
			Integer referencia) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select max(p.parc_id) as idParcelamento "
					+ " from cobranca.parcelamento p "
					+ " where imov_id = :idImovel "
					+ " and p.pcst_id = :normal "
					+ " and p.parc_id in(select pi.parc_id "
					+ " from cobranca.parcelamento_item pi "
					+ " inner join faturamento.conta_historico cnta on pi.cnta_id = cnta.cnta_id "
					+ " where "
					+ " cnta.cnhi_amreferenciaconta <= :referencia and "
					+ " p.parc_id = pi.parc_id )";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("normal", ParcelamentoSituacao.NORMAL)
					.setInteger("referencia", referencia).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos Author: Vivianne Sousa Data:
	 * 18/05/2009
	 */
	public BigDecimal pesquisarValorDebitoCobradoParcelamentoConta(
			Integer idConta) throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT sum(dbcb.valorPrestacao) "
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.financiamentoTipo fntp "
					+ "WHERE dbcb.conta.id = :idConta "
					+ "and (fntp.id = :parcAgua or "
					+ "fntp.id = :parcEsgoto or fntp.id = :parcServico or "
					+ "fntp.id = :jurosParc)";

			retorno = (BigDecimal) session
					.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setInteger("parcAgua",
							FinanciamentoTipo.PARCELAMENTO_AGUA.intValue())
					.setInteger("parcEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO.intValue())
					.setInteger("parcServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO.intValue())
					.setInteger("jurosParc",
							FinanciamentoTipo.JUROS_PARCELAMENTO.intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0878] Gerar Relação de Parcelamento - Visão Analitica
	 * 
	 * @author Bruno Barros
	 * 
	 * @date 05/06/2009
	 */
	public Integer pesquisarQuantidadeContasNaoPagasParcelamento(
			Integer idParcelamento, Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select \n"
					+ "  count( distinct cnta.cnta_id ) as quantidade \n"
					+ "from \n"
					+ "  cobranca.parcelamento parc \n"
					+ "  inner join faturamento.conta cnta on ( cnta.imov_id = parc.imov_id and cnta.cnta_amreferenciaconta > parc.parc_amreferenciafaturamento ) \n"
					+ "  inner join faturamento.debito_cobrado deCo on ( deCo.cnta_id = cnta.cnta_id ) \n"
					+ "where \n"
					+ "  deCo.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) and \n"
					+ "  deCo.dbac_id = :idDebitoACobrar and \n"
					+

					"  not exists ( select 'a' from arrecadacao.pagamento pgto where pgto.cnta_id = cnta.cnta_id ) and \n"
					+ "  parc.parc_id = :idParcelamento \n";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idParcelamento", idParcelamento)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

			if (retorno == null) {
				retorno = 0;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * retorna id da ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 08/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarResolucaoDiretoriaComPercentualDoacao()
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd.id "
					+ "from ResolucaoDiretoria rd "
					+ "where rd.percentualDoacao is not null or rd.percentualDoacao > :zero ";

			retorno = (Integer) session.createQuery(consulta)
					.setBigDecimal("zero", new BigDecimal("0.00"))
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// //////////////////////////////////////////////////////////
	/**
	 * retorna coleção de ids de Rota de um Grupo de faturamento
	 * 
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 11/06/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarRotasPorGrupoFaturamento(
			Integer idGrupoFaturamento) throws ErroRepositorioException {

		Collection<Integer> rotas = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct(rota.id) " + "from Rota rota "
					+ "inner join rota.faturamentoGrupo ftgr "
					+ "where ftgr.id = :idFaturamentoGrupo ";
			// + "and rota.id = 3367";//apagar

			rotas = session.createQuery(consulta)
					.setInteger("idFaturamentoGrupo", idGrupoFaturamento)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return rotas;
	}

	/**
	 * retorna coleção de idImovel de uma Rota
	 * 
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 12/06/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImoveisPorRota(Integer idRota)
			throws ErroRepositorioException {

		Collection dados = new ArrayList();
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select "
					+ " imov.imov_id as idImovel, "
					+ " imov.loca_id as idLocalidade, "
					+ " imov.last_id as idLigacaoAguaSituacao,"
					+ " imov.lest_id as idLigacaoEsgotoSituacao,"
					+ " imov.iper_id as idImovelPerfil,"
					+ " setor.stcm_id as idSetor,"
					+ " setor.stcm_cdsetorcomercial as codigoSetor,"
					+ " qdra.qdra_id as idQuadra,"
					+ " qdra_nnquadra as numeroQuadra, "
					+ " imov.imov_nnreparcmtconsec as numeroReparcelCons "
					+ " from cadastro.imovel imov"
					+ " left join cadastro.setor_comercial setor on imov.stcm_id= setor.stcm_id"
					+ " left join cadastro.quadra qdra on imov.qdra_id= qdra.qdra_id"
					+ " left join micromedicao.rota rota on qdra.rota_id= rota.rota_id"
					+ " where rota.rota_id =  :idRota "
					+ " and imov_icexclusao = 2"
					+ " and ((imov.last_id in (:emFiscalizacao, :cortado, :suprimido, :suprimidoParc, :suprimidoParcPedido))"
					+ " or (imov.lest_id= :ligado and imov.last_id in (:potencial , :factivel))) ";

			dados = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("numeroReparcelCons", Hibernate.SHORT)
					.setInteger("idRota", idRota)
					.setInteger("emFiscalizacao",
							LigacaoAguaSituacao.EM_FISCALIZACAO)
					.setInteger("cortado", LigacaoAguaSituacao.CORTADO)
					.setInteger("suprimido", LigacaoAguaSituacao.SUPRIMIDO)
					.setInteger("suprimidoParc", LigacaoAguaSituacao.SUPR_PARC)
					.setInteger("suprimidoParcPedido",
							LigacaoAguaSituacao.SUPR_PARC_PEDIDO)
					.setInteger("potencial", LigacaoAguaSituacao.POTENCIAL)
					.setInteger("factivel", LigacaoAguaSituacao.FACTIVEL)
					.setInteger("ligado", LigacaoEsgotoSituacao.LIGADO).list();

			if (dados != null && !dados.isEmpty()) {
				retorno = new ArrayList();

				Iterator iter = dados.iterator();

				while (iter.hasNext()) {
					Object[] dadosImovel = (Object[]) iter.next();
					Imovel imovel = new Imovel();
					Localidade loca = new Localidade();
					LigacaoAguaSituacao last = new LigacaoAguaSituacao();
					LigacaoEsgotoSituacao lest = new LigacaoEsgotoSituacao();
					ImovelPerfil iper = new ImovelPerfil();
					SetorComercial setor = new SetorComercial();
					Quadra quadra = new Quadra();

					imovel.setId((Integer) dadosImovel[0]);

					loca.setId((Integer) dadosImovel[1]);
					imovel.setLocalidade(loca);

					last.setId((Integer) dadosImovel[2]);
					imovel.setLigacaoAguaSituacao(last);

					lest.setId((Integer) dadosImovel[3]);
					imovel.setLigacaoEsgotoSituacao(lest);

					iper.setId((Integer) dadosImovel[4]);
					imovel.setImovelPerfil(iper);

					setor.setId((Integer) dadosImovel[5]);
					setor.setCodigo((Integer) dadosImovel[6]);
					imovel.setSetorComercial(setor);

					quadra.setId((Integer) dadosImovel[7]);
					quadra.setNumeroQuadra((Integer) dadosImovel[8]);
					imovel.setQuadra(quadra);

					if (dadosImovel[9] != null) {
						imovel.setNumeroReparcelamentoConsecutivos((Short) dadosImovel[9]);
					}

					retorno.add(imovel);
				}

			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 17/06/2009
	 */
	public void deletarCobrancaDocumentoECobrancaDocumentoItem(Integer idRota,
			Integer documentoTipo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			Collection idsCobrancaDocumento = null;
			String consulta = " select distinct(cd.id) "
					+ " from CobrancaDocumento cd "
					+ " inner join cd.documentoTipo dt "
					+ " inner join cd.quadra qu "
					+ " inner join qu.rota rota "
					+ " where rota.id = :idRota "
					+ " and  dt.id = :documentoTipo "
					+ " and not exists (select id from Pagamento p where p.cobrancaDocumento.id = cd.id ) ";

			idsCobrancaDocumento = session.createQuery(consulta)
					.setInteger("idRota", idRota)
					.setInteger("documentoTipo", documentoTipo).list();

			if (idsCobrancaDocumento != null && !idsCobrancaDocumento.isEmpty()) {

				// deleta os itens dos documentos de cobrança
				String delete = "delete CobrancaDocumentoItem cdi "
						+ "where cdi.cobrancaDocumento.id in (:idsCobrancaDocumento) ";

				session.createQuery(delete)
						.setParameterList("idsCobrancaDocumento",
								idsCobrancaDocumento).executeUpdate();

				// deleta os documentos de cobrança
				String delete2 = "delete CobrancaDocumento cd "
						+ "where cd.id in (:idsCobrancaDocumento) ";

				session.createQuery(delete2)
						.setParameterList("idsCobrancaDocumento",
								idsCobrancaDocumento).executeUpdate();

			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da criança para
	 * Negociação a Vista
	 * 
	 * O sistema ordena a lista de documentos de cobrança por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Vivianne Sousa
	 * @data 17/06/2009
	 * 
	 * @param idRota
	 *            , idDocumentoTipo
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitir(
			Integer idRota, Integer idDocumentoTipo)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			// consulta = "SELECT cbdo "
			// + "FROM CobrancaDocumento as cbdo "
			// + "LEFT JOIN fetch cbdo.empresa as empr "
			// + "LEFT JOIN fetch cbdo.localidade as loca "
			// + "LEFT JOIN fetch cbdo.imovel as imov "
			// + "LEFT JOIN fetch cbdo.quadra qdr "
			// + "LEFT JOIN fetch qdr.rota rot "
			// + "LEFT JOIN cbdo.documentoTipo as docTipo "
			// + "WHERE "
			// + "rot.id = :idRota and docTipo = :idDocumentoTipo "
			// +
			// "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
			// + "imov.lote, imov.subLote, cbdo.id";

			consulta = "SELECT cbdo " + "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.empresa empr "
					+ "LEFT JOIN cbdo.localidade loca "
					+ "LEFT JOIN fetch cbdo.imovel imov "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN cbdo.documentoTipo docTipo "
					+ "WHERE rot.id = :idRota AND "
					+ "cbdo.documentoTipo = :idDocumentoTipo ";

			retorno = session.createQuery(consulta)
					.setInteger("idRota", idRota)
					.setInteger("idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os itens do documento de cobrança correspondentes a debito a
	 * cobrar
	 * 
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @data 17/06/2009
	 */
	public BigDecimal selecionarValorTotalCobrancaDocumentoItemReferenteDebito(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT sum(cdit.valorItemCobrado) "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN cdit.debitoACobrarGeral debitoGeral "
					+ "LEFT JOIN debitoGeral.debitoACobrar  debito "
					+ "LEFT JOIN debito.debitoCreditoSituacaoAtual "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "debito.id IS NOT NULL ";

			retorno = (BigDecimal) session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna a Data de Vencimento da Rota (FACR_DTCONTAVENCIMENTO da tabela
	 * FATURAMENTO_ATIV_CRON_ROTA com ROTA_ID = ROTA_ID já pesquisado antes e
	 * FTAC_ID = FTAC_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA e FTAT_ID =
	 * 5 e FTCM_ID = FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com
	 * FTGR_ID = ao grupo informado e FTCM_AMREFERENCIA = anoMesFaturamento da
	 * tabela SISTEMA_PARAMETROS )
	 * 
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da criança para
	 * Negociação a Vista
	 * 
	 * @author Vivianne Sousa
	 * @data 22/06/2009
	 */
	public Date pesquisarDataVencimentoRota(Integer idRota,
			Integer anoMesFaturamento, Integer grupoFaturamento)
			throws ErroRepositorioException {

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = " select facr.facr_dtcontavencimento as vencimento "
					+ " from faturamento.fatur_ativ_cron_rota facr "
					+ " inner join faturamento.fatur_ativ_cronograma fac on facr.ftac_id = fac.ftac_id "
					+ " inner join faturamento.fatur_grupo_crg_mensal ftcm on fac.ftcm_id = ftcm.ftcm_id "
					+ " where facr.rota_id = :idRota "
					+ " and fac.ftat_id = 5 "
					+ " and ftcm.ftcm_amreferencia = :anoMesFaturamento "
					+ " and ftcm.ftgr_id = :grupoFaturamento ";

			retorno = (Date) session.createSQLQuery(consulta)
					.addScalar("vencimento", Hibernate.DATE)
					.setInteger("idRota", idRota)
					.setInteger("anoMesFaturamento", anoMesFaturamento)
					.setInteger("grupoFaturamento", grupoFaturamento)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Esse metodo pesquisa as faturas de um cliente responsável federal, de
	 * acordo com o Mes/Ano, e de acordo com o id do Cliente de acordo com o
	 * RELATORIO SINTETICO DO UC0919
	 * 
	 * Se os dois parametros tiverem sido passados, procura usando os dois
	 * parametros, senão usa apenas o parametro anoMes que é obrigatorio
	 * 
	 * @author Jose Guilherme Macedo Vieira
	 * @date 08/07/2009
	 * 
	 * @param Integer
	 *            anoMes
	 * @param Integer
	 *            clienteID
	 * @return Collection - uma colecao de objetos Fatura
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaFaturaClienteResponsavelFederal(Integer anoMes,
			Integer clienteID) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT fatura " + "FROM Fatura fatura "
					+ "INNER JOIN fetch fatura.cliente cliente "
					+ "INNER JOIN fetch cliente.clienteTipo clienteTipo "
					+ "INNER JOIN fetch clienteTipo.esferaPoder esferaPoder "
					+ "WHERE  fatura.anoMesReferencia = :anoMes "
					+ "AND  esferaPoder.id = :idEsferaPoder ";

			if (clienteID != null) {
				consulta += " and cliente.id = :clienteID ";
				consulta += " ORDER BY fatura.id";

				retorno = (Collection) session.createQuery(consulta)
						.setInteger("clienteID", clienteID)
						.setInteger("anoMes", anoMes)
						.setInteger("idEsferaPoder", EsferaPoder.FEDERAL)
						.list();
			} else {
				consulta += " ORDER BY fatura.id";
				retorno = (Collection) session.createQuery(consulta)
						.setInteger("anoMes", anoMes)
						.setInteger("idEsferaPoder", EsferaPoder.FEDERAL)
						.list();
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * Pesquisa por todos os impostos a partir de uma fatura de um cliente
	 * responsavel federal e/ou de um imovel.
	 * 
	 * A fatura é obrigatória.
	 * 
	 * OBS: O id da fatura passado tem que ser de uma fatura de um cliente
	 * responsavel federal
	 * 
	 * @author Jose Guilherme Macedo Vieira, Fernando Fontelles Filho
	 * @date 08/07/2009, 28/09/2010
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaImpostoFaturaClienteResponsavelFederal(
			Integer anoMesInicial, Integer anoMesFinal, Integer idCliente)	throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		// Pesquisa pela fatura se o período é referente a um mês
		boolean fatura = anoMesInicial.equals(anoMesFinal);

		try {
			Query query = null;

			consulta = "SELECT "
					+ " impostoTipo 		AS impostoTipo,"
					+ " descricaoImposto 	AS descricaoImposto,"
					+ " percAliquota		AS percAliquota,"
					+ " sum(valorImposto) 	AS valorImposto,"
					+ " cliente				AS cliente,"
					+ " nomeCliente			AS nomeCliente,"
					+ " sum(valorFatura) 	AS valorFatura,"
					+ " cnpj				AS cnpj,"
					+ " sum(baseCalculo)  	AS baseCalculo,"
					+ " idFatura			AS idFatura"
					+ " FROM(  " 
					+ " SELECT imtp.imtp_id     		AS impostoTipo, "
					+ " imtp.imtp_dsimposto      		AS descricaoImposto," 
					+ " cnid.cnid_pcaliquota     		AS percAliquota, "
					+ " Sum(cnid.cnid_vlimposto) 		AS valorImposto, "
					+ " clie.clie_id             		AS cliente, "
					+ " clie_nmcliente          		AS nomeCliente," 
					+ " Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos ) - ( cnta.cnta_vlcreditos + cnta.cnta_vlimpostos ) )) AS valorFatura," 
					+ " clie.clie_nncnpj         		AS cnpj," 
					+ " Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos ) - ( cnta.cnta_vlcreditos ) )) AS baseCalculo ";

			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id					AS idFatura";
			} else {
				consulta = consulta 
					+ " ,null							AS idFatura";
			}

			consulta = consulta 
					+ " FROM   faturamento.conta_impostos_deduzidos cnid" 
					+ " INNER JOIN faturamento.conta cnta 	 		ON ( cnid.cnta_id = cnta.cnta_id )" 
					+ " INNER JOIN cadastro.cliente_conta clct 		ON ( cnta.cnta_id = clct.cnta_id AND clct.crtp_id = :cliRelacaoTipo )" 
					+ " INNER JOIN cadastro.cliente clie 	 		ON ( clct.clie_id = clie.clie_id )" 
					+ " INNER JOIN cadastro.cliente_tipo cltp 	 	ON ( clie.cltp_id = cltp.cltp_id )" 
					+ " INNER JOIN faturamento.imposto_tipo imtp 	ON ( cnid.imtp_id = imtp.imtp_id )" ;
			if (fatura) {
				consulta = consulta 
					+ " LEFT JOIN faturamento.fatura fatu			ON ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnta.cnta_amreferenciaconta)";
			}
			
			consulta = consulta    
					+ " WHERE  cnta.cnta_id IN (SELECT idconta FROM"   
					+ " 								(SELECT imovel, referencia, Max(cnta_id) AS idconta FROM"   
					+ " 										(SELECT conta.imov_id AS imovel, conta.cnta_amreferenciaconta AS referencia, conta.cnta_id FROM   faturamento.conta conta" 
					+ " 												WHERE  conta.cnta_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal" 
					+ " 										 UNION ALL" 
					+ " 										 SELECT contaHist.imov_id AS imovel, contaHist.cnhi_amreferenciaconta AS referencia, contaHist.cnta_id FROM  faturamento.conta_historico contaHist" 
					+ " 												WHERE  contaHist.cnhi_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal) a  GROUP  BY imovel," 
					+ " 								referencia)" 
					+ " 						b)"; 
					
			if (idCliente != null) {
				consulta = consulta
					+ " AND clct.clie_id = " + idCliente;
			}

			consulta = consulta 
					+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj " ;
			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id ";
			}

			consulta = consulta				
					+ " UNION ALL"
					+ " SELECT imtp.imtp_id 			AS impostoTipo," 
					+ " imtp.imtp_dsimposto             AS descricaoImposto," 
					+ " cidh.cidh_pcaliquota            AS percAliquota," 
					+ " Sum(cidh.cidh_vlimposto)        AS valorImposto," 
					+ " clie.clie_id                    AS cliente," 
					+ " clie_nmcliente                  AS nomeCliente," 
					+ " Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos ) - ( cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos ) )) AS valorFatura," 
					+ " clie.clie_nncnpj                AS cnpj," 
					+ " Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos ) - ( cnhi.cnhi_vlcreditos ) )) AS baseCalculo ";

			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id					AS idFatura";
			} else {
				consulta = consulta 
					+ " ,null							AS idFatura";
			}

			consulta = consulta 
					+ " FROM   faturamento.conta_impostos_dedz_hist cidh" 
					+ " INNER JOIN faturamento.conta_historico cnhi 		ON ( cidh.cnta_id = cnhi.cnta_id )" 
					+ " INNER JOIN cadastro.cliente_conta_historico clch 	ON ( cnhi.cnta_id = clch.cnta_id AND clch.crtp_id = :cliRelacaoTipo )" 
					+ " INNER JOIN cadastro.cliente clie 					ON ( clch.clie_id = clie.clie_id )" 
					+ " INNER JOIN cadastro.cliente_tipo cltp 				ON ( clie.cltp_id = cltp.cltp_id )" 
					+ " INNER JOIN faturamento.imposto_tipo imtp 			ON ( cidh.imtp_id = imtp.imtp_id )" ;
			if (fatura) {
				consulta = consulta
					+ " LEFT JOIN faturamento.fatura fatu		   			ON ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnhi.cnhi_amreferenciaconta)"	;						
			}
			consulta = consulta 
					+ "  WHERE  cnhi.cnta_id IN (SELECT idconta FROM "   
					+ " 								(SELECT imovel, referencia, Max(cnta_id) AS idconta FROM "   
					+ " 										(SELECT conta.imov_id AS imovel, conta.cnta_amreferenciaconta AS referencia, conta.cnta_id FROM   faturamento.conta conta" 
					+ " 												WHERE  conta.cnta_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal " 
					+ " 										 UNION ALL" 
					+ " 										 SELECT contaHist.imov_id AS imovel, contaHist.cnhi_amreferenciaconta AS referencia, contaHist.cnta_id FROM  faturamento.conta_historico contaHist" 
					+ " 												WHERE  contaHist.cnhi_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal) a  GROUP  BY imovel," 
					+ " 								referencia)" 
					+ " 						b)" ;
			if (idCliente != null) {
				consulta = consulta
					+ " AND clch.clie_id = " + idCliente;
			}

			consulta = consulta
					+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj ";					
			if (fatura) {
				consulta = consulta
					+ " ,fatu.fatu_id ";
			}
			consulta = consulta	
					+ " ORDER  BY cliente, impostotipo "
					+ " ) t "
					+ " GROUP BY impostoTipo,descricaoImposto,percAliquota,cliente,nomeCliente,cnpj,idFatura " 
					+ " ORDER  BY cliente, impostotipo";

			query = session
					.createSQLQuery(consulta)
					.addScalar("impostoTipo", Hibernate.INTEGER)
					.addScalar("descricaoImposto", Hibernate.STRING)
					.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
					.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
					.addScalar("cliente", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("baseCalculo", Hibernate.BIG_DECIMAL)
					.addScalar("idFatura", Hibernate.INTEGER)
					.setShort("cliRelacaoTipo",ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("anoMesReferenciaInicial", anoMesInicial)
					.setInteger("anoMesReferenciaFinal", anoMesFinal);

			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Pesquisa por todos os impostos arrecadados a partir de um mês de
	 * referência de um determinado cliente federal ou de TODOS os clientes
	 * federais.
	 * 
	 * @author Diogo Peixoto
	 * @date 23/03/2011
	 * 
	 * @param Integer
	 *            anoMesFerencia
	 * @param Integer
	 *            idCliente
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImpostosArrecadacaoClienteResponsavelFederal(
			Integer anoMesInicial, Integer anoMesFinal, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		// Pesquisa pela fatura se o período é referente a um mês
		boolean fatura = anoMesInicial.equals(anoMesFinal);
		try {

			Query query = null;

			consulta =
				  " select imtp.imtp_id 		as impostoTipo,  "
				+ " imtp.imtp_dsimposto 		as descricaoImposto, "
				+ " cnid.cnid_pcaliquota 		as percAliquota, "
				+ " sum(cnid.cnid_vlimposto) 	as valorImposto, "
				+ " clie.clie_id 				as cliente,  "
				+ " clie_nmcliente 				as nomeCliente,  "
				+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura,  "
				+ " clie.clie_nncnpj 			as cnpj,  "
				+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos))) as baseCalculo  ";
			if (fatura) {
				consulta = consulta 
				+ " ,fatu.fatu_id				as idFatura"
				+ " ,fatu.fatu_amreferencia 	as referenciaFatura ";
			} else {
				consulta = consulta 
				+ " ,null						as idFatura"
				+ " ,null					 	as referenciaFatura ";
			}
			consulta = consulta
				+ " from	faturamento.conta_impostos_deduzidos cnid  "
				+ " inner join faturamento.conta cnta 					on (cnid.cnta_id = cnta.cnta_id) "
				+ " inner join arrecadacao.pagamento pgmt 				on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null and (pgmt.pgst_idatual = :pagamentoClassificado or (pgmt.pgst_idatual in (:pagamentoABaixar, :duplicidadeExcessoDevolvido) and (pgmt.pgst_idanterior is null or pgmt.pgst_idanterior <> :pagamentoDuplicidade))))  "
				+ " inner join cadastro.cliente_conta clct 				on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = :cliRelacaoTipo)  "
				+ " inner join cadastro.cliente clie 					on (clct.clie_id = clie.clie_id) "
				+ " inner join cadastro.cliente_tipo cltp 				on (clie.cltp_id = cltp.cltp_id) "
				+ " inner join faturamento.imposto_tipo imtp 			on (cnid.imtp_id = imtp.imtp_id) ";
			if (fatura) {
				consulta = consulta 
				+ " left  join faturamento.fatura fatu					on ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnta.cnta_amreferenciaconta) ";
			}
			consulta = consulta 
				+ " where pgmt.pgmt_amreferenciaarrecadacao BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal ";
			if(idCliente != null){
				consulta = consulta
				+ " and clie.clie_id = " + idCliente;
			}	
			if (fatura) {
				consulta = consulta 
				+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj,fatu.fatu_id,fatu.fatu_amreferencia ";
			}else{
				consulta = consulta 
				+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj ";
			}
			consulta = consulta
				+ " union all  "
				+ " select imtp.imtp_id 		as impostoTipo,  "
				+ " imtp.imtp_dsimposto 		as descricaoImposto,  "
				+ " cidh.cidh_pcaliquota 		as percAliquota,  "
				+ " sum(cidh.cidh_vlimposto) 	as valorImposto,  "
				+ " clie.clie_id 				as cliente,  "
				+ " clie_nmcliente 				as nomeCliente,  "
				+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura,  "
				+ " clie.clie_nncnpj 			as cnpj,  "
				+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos)))as baseCalculo  ";
			if (fatura) {
				consulta = consulta 
				+ " ,fatu.fatu_id				as idFatura"
				+ " ,fatu.fatu_amreferencia 	as referenciaFatura ";
			} else {
				consulta = consulta 
				+ " ,null						as idFatura"
				+ " ,null					 	as referenciaFatura ";
			}
			consulta = consulta
				+ " from	faturamento.conta_impostos_dedz_hist cidh  "
				+ " inner join faturamento.conta_historico cnhi 		on (cidh.cnta_id = cnhi.cnta_id)  "
				+ " inner join cadastro.cliente_conta_historico clch 	on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = :cliRelacaoTipo)  "
				+ " inner join arrecadacao.pagamento_historico pgmth 	on (clch.cnta_id = pgmth.cnta_id and (pgmth.pgst_idatual = :pagamentoClassificado or (pgmth.pgst_idatual in (:pagamentoABaixar, :duplicidadeExcessoDevolvido) and (pgmth.pgst_idanterior is null or pgmth.pgst_idanterior <> :pagamentoDuplicidade))))  "
				+ " inner join cadastro.cliente clie 					on (clch.clie_id = clie.clie_id)  "
				+ " inner join cadastro.cliente_tipo cltp 				on (clie.cltp_id = cltp.cltp_id )   "
				+ " inner join faturamento.imposto_tipo imtp 			on (cidh.imtp_id = imtp.imtp_id)  ";
			if (fatura) {
				consulta = consulta 
				+ " left  join faturamento.fatura fatu					on ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnhi.cnhi_amreferenciaconta)  ";
			}
			consulta = consulta
				+ " where pgmth.pghi_amreferenciahistorico  BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal  ";
			if (idCliente != null) {
				consulta = consulta 
				+ " and clie.clie_id = " + idCliente;
			}	
			if (fatura) {
				consulta = consulta 
				+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj ,fatu.fatu_id,fatu.fatu_amreferencia "
				+ " ORDER BY cliente, idFatura,impostoTipo  ";
			}else{
				consulta = consulta 
				+ " GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj  "
				+ " ORDER BY cliente, impostoTipo  ";
			}
				
			query = session
					.createSQLQuery(consulta.toString())
					.addScalar("impostoTipo", Hibernate.INTEGER)
					.addScalar("descricaoImposto", Hibernate.STRING)
					.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
					.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
					.addScalar("cliente", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("baseCalculo", Hibernate.BIG_DECIMAL)
					.addScalar("idFatura", Hibernate.INTEGER)
					.addScalar("referenciaFatura", Hibernate.INTEGER)
					.setInteger("anoMesReferenciaInicial", anoMesInicial)
					.setInteger("anoMesReferenciaFinal", anoMesFinal)
					.setInteger("pagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("pagamentoABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("duplicidadeExcessoDevolvido",PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO)
					.setInteger("pagamentoDuplicidade",PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE)
					.setInteger("cliRelacaoTipo",ClienteRelacaoTipo.RESPONSAVEL);

			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Pesquisa por todos os impostos arrecadados a partir de um mês de
	 * referência de um determinado cliente federal ou de TODOS os clientes
	 * federais.
	 * 
	 * @author Diogo Peixoto
	 * @date 24/03/2011
	 * 
	 * @param Integer
	 *            anoMesFerencia
	 * @param Integer
	 *            idCliente
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImpostosArrecadacaoClienteResponsavelFederalAnalitico(
			Integer anoMesInicial, Integer anoMesFinal, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		// Pesquisa pela fatura se o período é referente a um mês
		boolean fatura = anoMesInicial.equals(anoMesFinal);

		try {
			Query query = null;
			
			consulta = "select	imtp.imtp_id 		as impostoTipo ,"
					+ " imtp.imtp_dsimposto 		as descricaoImposto ," 
					+ " cnid.cnid_pcaliquota 		as percAliquota," 
					+ " sum(cnid.cnid_vlimposto) 	as valorImposto," 
					+ " clie.clie_id 				as cliente," 
					+ " clie_nmcliente 				as nomeCliente," 
					+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura," 
					+ " cnta.imov_id 				as imovel," 
					+ " clie.clie_nncnpj 			as cnpj," 
					+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos))) as baseCalculo," 
					+ " cnta.cnta_id 				as conta," 
					+ " cnta.cnta_amreferenciaconta as anoMesReferecia";
			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id					AS idFatura";
			} else {
				consulta = consulta 
					+ " ,null							AS idFatura";
			}
			consulta = consulta		
					+ " from	faturamento.conta_impostos_deduzidos cnid" 
					+ " inner join faturamento.conta cnta 				on (cnid.cnta_id = cnta.cnta_id)" 
					+ " inner join arrecadacao.pagamento pgmt 			on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null and (pgmt.pgst_idatual = :pagamentoClassificado or (pgmt.pgst_idatual in (:pagamentoABaixar, :duplicidadeExcessoDevolvido) and (pgmt.pgst_idanterior is null or pgmt.pgst_idanterior <> :pagamentoDuplicidade)))) " 
					+ " inner join cadastro.cliente_conta clct 			on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = :cliRelacaoTipo) "
					+ " inner join cadastro.cliente clie 				on (clct.clie_id = clie.clie_id) "
					+ " inner join cadastro.cliente_tipo cltp 			on (clie.cltp_id = cltp.cltp_id) " 
					+ " inner join faturamento.imposto_tipo imtp 		on (cnid.imtp_id = imtp.imtp_id) " ;
			if(fatura){
					consulta = consulta
					+ " left  join faturamento.fatura fatu				on ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnta.cnta_amreferenciaconta)";
			}	
			consulta = consulta
					+ " where pgmt.pgmt_amreferenciaarrecadacao BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal";
			if (idCliente != null) {
				consulta = consulta
					+ " and		clct.clie_id = " + idCliente;
			}
			if(fatura){
				consulta = consulta 
					+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, cnta.cnta_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj, cnta.cnta_amreferenciaconta ,fatu.fatu_id";
			}else{
				consulta = consulta 
					+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, cnta.cnta_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj, cnta.cnta_amreferenciaconta ";
			}
			consulta = consulta 
					+ " union all " 
					+ " select	imtp.imtp_id 		as impostoTipo ,"
					+ " imtp.imtp_dsimposto 		as descricaoImposto ," 
					+ " cidh.cidh_pcaliquota 		as percAliquota," 
					+ " sum(cidh.cidh_vlimposto) 	as valorImposto," 
					+ " clie.clie_id 				as cliente," 
					+ " clie_nmcliente 				as nomeCliente," 
					+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura," 
					+ " cnhi.imov_id 				as imovel, "
					+ " clie.clie_nncnpj 			as cnpj," 
					+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos)))as baseCalculo," 
					+ " cnhi.cnta_id 				as conta," 
					+ " cnhi.cnhi_amreferenciaconta as anoMesReferecia";
			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id					AS idFatura";
			} else {
				consulta = consulta 
					+ " ,null							AS idFatura";
			}
			consulta = consulta
					+ " from	faturamento.conta_impostos_dedz_hist cidh" 
					+ " inner join faturamento.conta_historico cnhi 		on (cidh.cnta_id = cnhi.cnta_id)" 
					+ " inner join cadastro.cliente_conta_historico clch 	on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = :cliRelacaoTipo)" 
					+ " inner join arrecadacao.pagamento_historico pgmth 	on (clch.cnta_id = pgmth.cnta_id and (pgmth.pgst_idatual = :pagamentoClassificado or (pgmth.pgst_idatual in (:pagamentoABaixar, :duplicidadeExcessoDevolvido) and (pgmth.pgst_idanterior is null or pgmth.pgst_idanterior <> :pagamentoDuplicidade)))) " 
					+ " inner join cadastro.cliente clie 					on (clch.clie_id = clie.clie_id)" 
					+ " inner join cadastro.cliente_tipo cltp 				on (clie.cltp_id = cltp.cltp_id ) "
					+ " inner join faturamento.imposto_tipo imtp 			on (cidh.imtp_id = imtp.imtp_id)" ;
			if(fatura){
				consulta = consulta
					+ " left  join faturamento.fatura fatu					on ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnhi.cnhi_amreferenciaconta)";
			}
			consulta = consulta
					+ " where pgmth.pghi_amreferenciahistorico BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal ";
			if (idCliente != null) {
				consulta = consulta
					+ " and		clch.clie_id = " + idCliente ;
			}
			if(fatura){
				consulta = consulta
					+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id,  cnhi.cnta_id,imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj,clie_nncnpj,  cnhi.cnhi_amreferenciaconta ,fatu.fatu_id"
					+ " ORDER BY cliente, idFatura, imovel,anoMesReferecia, impostoTipo ";
			}else{
				consulta = consulta
					+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id,  cnhi.cnta_id,imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj,clie_nncnpj,  cnhi.cnhi_amreferenciaconta "
					+ " ORDER BY cliente, imovel,anoMesReferecia, impostoTipo ";
			}

			query = session
					.createSQLQuery(consulta)
					.addScalar("impostoTipo", Hibernate.INTEGER)
					.addScalar("descricaoImposto", Hibernate.STRING)
					.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
					.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
					.addScalar("cliente", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("baseCalculo", Hibernate.BIG_DECIMAL)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("anoMesReferecia", Hibernate.STRING)
					.addScalar("idFatura", Hibernate.INTEGER)
					.setInteger("anoMesReferenciaInicial", anoMesInicial)
					.setInteger("anoMesReferenciaFinal", anoMesFinal)
					.setInteger("pagamentoClassificado",PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("pagamentoABaixar",PagamentoSituacao.VALOR_A_BAIXAR)
					.setInteger("duplicidadeExcessoDevolvido",PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO)
					.setInteger("pagamentoDuplicidade",PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE)
					.setInteger("cliRelacaoTipo",ClienteRelacaoTipo.RESPONSAVEL);
			
			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Esse método está de acordo com o UC0919 - Gerar Relatório de Impostos Por
	 * Cliente Responsável, no caso do Relatório Analítico o qual necessita
	 * recuperar os Imóveis que estão associados a uma Fatura (cujo id é passado
	 * como parâmetro Integer), a partir da tabela fatura_item.
	 * 
	 * @author Jose Guilherme Macedo Vieira
	 * @date 13/07/2009
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection<Imovel> - a colecao de imoveis associadas a uma fatura
	 * @throws ErroRepositorioException
	 */
	public Collection<Imovel> pesquisarImoveisFaturaClienteResponsavel(
			Integer idFatura) throws ErroRepositorioException {

		Collection<Imovel> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT imo " + "FROM FaturaItem fatIt "
					+ "INNER JOIN fatIt.imovel imo  "
					+ "INNER JOIN imo.clienteImoveis cliImo with "
					+ "(cliImo.clienteRelacaoTipo.id = 2 and "
					+ "cliImo.dataFimRelacao = null)"
					+ "INNER JOIN fetch fatIt.fatura.cliente cli "
					+ "WHERE  fatIt.fatura.id = :idFatura ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idFatura", idFatura).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * Atualizar total de documentos, itens e valores realizados nos comandos de
	 * acao de cobranca
	 * 
	 * Data: 28/07/2009
	 * 
	 * @author Francisco do Nascimento
	 * 
	 * @param idCAAC
	 *            Identificador de CobrancaAcaoAtividadeCronograma
	 * @return Array de objetos com valores de 0 - quantidade de itens cobrados
	 *         1 - valor total dos documentos 2 - quantidade de documentos
	 */
	public Object[] calcularTotaisCronogramaAcaoCobranca(Integer idCAAC)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object[] retorno = new Object[3];

		try {

			Date dataAtual = new Date();

			// usou-se a condicao ultimaAlteracao > xxxxxx para melhorar o tempo
			// da query
			String consulta = "SELECT count(cdi.id) FROM CobrancaDocumentoItem cdi where "
					+ "cdi.ultimaAlteracao > :dataGeracaoItem "
					+ " and cdi.cobrancaDocumento.id in "
					+ "(select cd.id from CobrancaDocumento cd where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC) ";

			// quantidade de itens cobrados
			retorno[0] = (Integer) session
					.createQuery(consulta)
					.setInteger("idCAAC", idCAAC)
					.setDate("dataGeracaoItem",
							Util.subtrairNumeroDiasDeUmaData(dataAtual, 2))
					.uniqueResult();

			consulta = "SELECT sum(cd.valorDocumento) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC ";

			// valor total dos documentos
			retorno[1] = (BigDecimal) session.createQuery(consulta)
					.setInteger("idCAAC", idCAAC).uniqueResult();

			consulta = "SELECT count(cd.id) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC ";

			// quantidade de documentos
			retorno[2] = (Integer) session.createQuery(consulta)
					.setInteger("idCAAC", idCAAC).uniqueResult();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Pesquisa todas as localidades do cicloMeta agrupando por localidade,
	 * unidade e gerencia.
	 * 
	 * 
	 * @author Genival Barbosa
	 * @date 03/08/2009
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public List consultarColecaoCicloMetaGrupoRelatorio(Integer idCicloMeta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select  ger.id, "
					+ "ger.nome, "
					+ "uni.id, "
					+ "uni.nome, "
					+ "loc.id, "
					+ "loc.descricao, "
					+ "sum(cmg.metaCalculada) as metaCalculada, "
					+ "sum(cmg.metaAjustada) as metaAjustada, "
					+ "sum(cmg.quantidadeImoveisSituacaoAgua) as quantidadeImoveis, "
					+ "sum(cmg.quantidadeRealizada) as quantidadeRealizada, "
					+ "sum(cmg.valorRealizado) as valorRealizado, "
					+ "sum(cmg.quantidadeDocumentosRestantes) as quantidadeDocumentosRestantes, "
					+ "sum(cmg.valorTotalDocumentosRestantes) as valorTotalDocumentosRestantes "
					+ "from CicloMetaGrupo cmg "
					+ "inner join cmg.cicloMeta cme "
					+ "inner join cmg.localidade loc "
					+ "inner join loc.gerenciaRegional ger "
					+ "inner join loc.unidadeNegocio uni "
					+ "where cmg.cicloMeta = :idCicloMeta "
					+ "group by loc.id ,uni.id,ger.id ,ger.nome, uni.nome, loc.descricao "
					+ "order by ger.nome, uni.nome, loc.descricao ";

			retorno = session.createQuery(consulta)
					.setInteger("idCicloMeta", idCicloMeta).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa
	 * 
	 * - Pesquisa dados da cobrança
	 * 
	 * @author Hugo Amorim
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobranca(Integer idComando,
			Date dateInicial, Date dateFinal) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " ecc.ecco_vloriginalconta as valor"
					+ " from cobranca.empresa_cobranca_conta ecc"
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ecc.cecc_id = cecc.cecc_id"
					+ " inner join faturamento.conta conta on ecc.cnta_id = conta.cnta_id "
					+ " where cecc.cecc_id = :idComando "
					+ " and ecc.ecco_cdincluido is null "
					+ " and not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=ecc.cnta_id)"
					+ " and (conta.dcst_idatual in " + "("
					+ DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.RETIFICADA + ", "
					+ DebitoCreditoSituacao.INCLUIDA + " )) ";

			if (dateInicial != null && !dateInicial.equals("")
					&& dateFinal != null && !dateFinal.equals("")) {

				consulta += " and (cecc.cecc_dtexecucao between :dateInicial and :dateFinal)";

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando)
						.setDate("dateInicial", dateInicial)
						.setDate("dateFinal", dateFinal).list();

			} else {

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa
	 * 
	 * - Pesquisa dados da cobrança criterio
	 * 
	 * @author Hugo Amorim
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaCriterio(Integer idComando,
			Date dateInicial, Date dateFinal) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " ecc.ecco_vloriginalconta as valor"
					+ " from cobranca.empresa_cobranca_conta ecc"
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ecc.cecc_id = cecc.cecc_id"
					+ " inner join faturamento.conta conta on ecc.cnta_id = conta.cnta_id "
					+ " where cecc.cecc_id = :idComando"
					+ " and ecc.ecco_cdincluido is null "
					+ " and not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=ecc.cnta_id) "
					+ " and ecc.ecco_icpagamentovalido = 1"
					+ " and (conta.dcst_idatual in " + " ("
					+ DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.RETIFICADA + ", "
					+ DebitoCreditoSituacao.INCLUIDA + " )) ";

			if (dateInicial != null && !dateInicial.equals("")
					&& dateFinal != null && !dateFinal.equals("")) {

				consulta += " and (cecc.cecc_dtexecucao between :dateInicial and :dateFinal)";

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando)
						.setDate("dateInicial", dateInicial)
						.setDate("dateFinal", dateFinal).list();

			} else {

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE DÉBITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel,
			BigDecimal valorPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id " // 15
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.imovel imov "
					+ "WHERE cd.valorDocumento = :valorDocumento AND "
					+ "imovel.id = :idImovel";

			retorno = session.createQuery(consulta)
					.setBigDecimal("valorDocumento", valorPagamento)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa -
	 * Pesquisa dados do popup da cobrança
	 * 
	 * @author Hugo Amorim
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosPopup(Integer idComando)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "empre.empr_nmempresa as empresa, "// 0
					+ "cecc.cecc_dtexecucao as dataExecucao, "// 1
					+ "cecc.cecc_amreferenciacontainicial as dataContaInicial, "// 2
					+ "cecc.cecc_amreferenciacontafinal as dataContaFinal, "// 3
					+ "cecc.cecc_dtvencimentocontainicial as vencimentoIncial, "// 4
					+ "cecc.cecc_dtvencimentocontainicial as vencimentoFinal, "// 5
					+ "cecc_vlminimoconta as vlMinino, "// 6
					+ "cecc_vlmaximoconta as vlMaximo, "// 7
					+ "imov_id as imovel, "// 8
					+ "cli.clie_nmcliente as cliente, "// 9
					+ "uneg.uneg_id as idUneg, "// 10
					+ "uneg.uneg_nmunidadenegocio as nomeUneg, "// 11
					+ "loca_idinicial as locaIncial, "// 12
					+ "loca_idfinal as locaFinal, "// 13
					+ "cecc_cdsetorcomercialinicial as setorInicial, "// 14
					+ "cecc_cdsetorcomercialfinal as setorFinal, "// 15
					+ "iper.iper_id as idImovelPerfil, "// 16
					+ "iper.iper_dsimovelperfil as dsImovelPerfil, "// 17
					+ "greg.greg_id as idGerenciaRegional, "// 18
					+ "greg.greg_nmregional as dsGerenciaRegional, "// 19
					+ "cecc_nnquadrainicial as idQuadraInicial, "// 20
					+ "cecc_nnquadrafinal as idQuadraFinal "// 21
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "inner join cadastro.empresa empre on cecc.empr_id = empre.empr_id "
					+ "left join cadastro.cliente cli on cli.clie_id = cecc.clie_id "
					+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = cecc.uneg_id "
					+ "left join cadastro.imovel_perfil iper on iper.iper_id = cecc.iper_id "
					+ "left join cadastro.gerencia_regional greg on cecc.greg_id = greg.greg_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("empresa", Hibernate.STRING)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("dataContaInicial", Hibernate.INTEGER)
					.addScalar("dataContaFinal", Hibernate.INTEGER)
					.addScalar("vencimentoIncial", Hibernate.DATE)
					.addScalar("vencimentoFinal", Hibernate.DATE)
					.addScalar("vlMinino", Hibernate.BIG_DECIMAL)
					.addScalar("vlMaximo", Hibernate.BIG_DECIMAL)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("cliente", Hibernate.STRING)
					.addScalar("idUneg", Hibernate.INTEGER)
					.addScalar("nomeUneg", Hibernate.STRING)
					.addScalar("locaIncial", Hibernate.INTEGER)
					.addScalar("locaFinal", Hibernate.INTEGER)
					.addScalar("setorInicial", Hibernate.INTEGER)
					.addScalar("setorFinal", Hibernate.INTEGER)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("dsImovelPerfil", Hibernate.STRING)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("dsGerenciaRegional", Hibernate.STRING)
					.addScalar("idQuadraInicial", Hibernate.INTEGER)
					.addScalar("idQuadraFinal", Hibernate.INTEGER)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * UC0905 - Gerar Relatorio Acompanhamento Acao Cobrança
	 * 
	 * @author Genival Barbosa
	 * @date 26/08/2009
	 * 
	 * @param RelatorioAcompanhamentoAcoesCobrancaHelper
	 *            helper
	 * 
	 * @return Lista de acoes de cobranca
	 */
	public List consultarColecaoAcaoCobranca(
			RelatorioAcompanhamentoAcoesCobrancaHelper helper)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();

		String idCobrancaAcao = helper.getIdCobrancaAcao();
		String dataInicial = helper.getDataInicial() + " 00:00:00";
		String dataFinal = helper.getDataFinal() + " 23:59:59";
		String idGerenciaRegional = helper.getIdGerenciaRegional();
		String idUnidadeNegocio = helper.getIdUnidadeNegocio();
		String idLocalidade = helper.getIdLocalidade();
		String idEmpresa = helper.getIdEmpresa();

		String consulta;
		String groupBy;

		try {
			// consulta = "select ger.id, "
			//
			// + "ger.nome, "
			// + "uni.id, "
			// + "uni.nome, "
			// + "loc.id, "
			// + "loc.descricao, "
			// + "cas.id, "
			// + "cas.descricao, "
			// + "count(cod.id) as quantidadeSituacao, "
			// + "sum(cod.valorDocumento) as valorSituacao, ";
			//
			// // ainda falta resolver o problema da empresa
			// if(!idEmpresa.trim().equals("-1"))
			// {
			//
			// consulta = consulta +"empr.id, empr.descricao, ";
			// }
			//
			// consulta = consulta
			// + "coa.id, "
			// + "coa.descricaoCobrancaAcao "
			// + "from CobrancaDocumento cod "
			// + "inner join cod.cobrancaAcaoSituacao cas "
			// + "inner join cod.localidade loc "
			// + "inner join loc.gerenciaRegional ger "
			// + "inner join loc.unidadeNegocio uni "
			// + "inner join cod.empresa empr "
			// + "inner join cod.cobrancaAcao coa "
			// + "where coa.id = " + idCobrancaAcao + " and "
			// + "cod.emissao >= :dataInicial and "
			// + "cod.emissao <= :dataFinal ";
			//
			// if(!idGerenciaRegional.trim().equals("-1")) {
			// consulta = consulta + "and ger.id = " + idGerenciaRegional + " ";
			// }
			// if(!idUnidadeNegocio.trim().equals("-1")) {
			// consulta = consulta + "and uni.id = " + idUnidadeNegocio + " ";
			// }
			// if(!idLocalidade.trim().equals("-1"))
			// {
			// consulta = consulta + "and loc.id = " + idLocalidade + " ";
			// }
			//
			// // ainda falta resolver o problema da empresa
			// if(!idEmpresa.trim().equals("-1"))
			// {
			// consulta = consulta + "and cod.empresa = " + idEmpresa + " ";
			// consulta = consulta
			// +
			// "group by cas.id, loc.id, uni.id, ger.id , empr.descricao, coa.id, ger.nome, uni.nome, loc.descricao, cas.descricao, empr.id , coa.descricaoCobrancaAcao ";
			// }else {
			// consulta = consulta
			// +
			// "group by cas.id, loc.id, uni.id, ger.id , coa.id, ger.nome, uni.nome, loc.descricao, cas.descricao, coa.descricaoCobrancaAcao ";
			// }
			// consulta = consulta +
			// "order by ger.nome, uni.nome, loc.descricao, cas.id ";

			// alterado por Vivianne Sousa/Rafael Correa - 06/02/2014

			consulta = "select ";

			if (!idLocalidade.trim().equals("-1")
					|| !idUnidadeNegocio.trim().equals("-1")
					|| !idGerenciaRegional.trim().equals("-1")) {
				consulta = consulta + "greg.greg_id, greg.greg_nmregional, ";
			} else {
				consulta = consulta + "0 as greg_id, 0 as greg_nmregional, ";
			}

			if (!idLocalidade.trim().equals("-1")
					|| !idUnidadeNegocio.trim().equals("-1")) {
				consulta = consulta
						+ "uneg.uneg_id, uneg.uneg_nmunidadenegocio, ";
			} else {
				consulta = consulta
						+ "0 as uneg_id, 0 as uneg_nmunidadenegocio, ";
			}

			if (!idLocalidade.trim().equals("-1")) {
				consulta = consulta + "loca.loca_id, loca.loca_nmlocalidade, ";
			} else {
				consulta = consulta + "0 as loca_id,0 as loca_nmlocalidade, ";
			}

			consulta = consulta
					+ "cas.cast_id, "
					+ "cas.cast_dssituacaoacao, "
					+ "count(cbdo.cbdo_id) as quantidadeSituacao, "
					+ "coalesce(sum(cbdo.cbdo_vldocumento),0) as valorSituacao, ";

			if (!idEmpresa.trim().equals("-1")) {
				consulta = consulta + "empr.empr_id, empr.empr_nmempresa, ";
			}

			consulta = consulta
					+ "cbac.cbac_id, "
					+ "cbac.cbac_dscobrancaacao "
					+ "from cadastro.localidade loca "
					+ "inner join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "inner join cadastro.unidade_negocio uneg on uneg.uneg_id = loca.uneg_id "
					+ "inner join cobranca.cobranca_acao_situacao cas on cas.cast_id in (1,2,3,4,5,6) "
					+ "inner join cobranca.cobranca_acao cbac on cbac.cbac_id = "
					+ idCobrancaAcao
					+ "inner join cobranca.cobranca_documento cbdo on cbdo.cast_id = cas.cast_id and cbdo.cbac_id = cbac.cbac_id and cbdo.loca_id = loca.loca_id "
					+ "and cbdo.cbdo_tmemissao between :dataInicial and :dataFinal "
					+ "inner join cadastro.empresa empr on empr.empr_id = cbdo.empr_id ";

			consulta = consulta
					+ "where loca.loca_id in (select cd.loca_id from cobranca.cobranca_documento cd where cd.cbac_id = cbac.cbac_id and cd.cbdo_tmemissao between :dataInicial and :dataFinal) ";

			if (!idEmpresa.trim().equals("-1")) {
				consulta = consulta + " and cbdo.empr_id = " + idEmpresa + " ";
			}

			if (!idLocalidade.trim().equals("-1")) {
				consulta = consulta + "and loca.loca_id = " + idLocalidade
						+ " ";

				if (!idEmpresa.trim().equals("-1")) {
					groupBy = "group by cas.cast_id, loca.loca_id, uneg.uneg_id, greg.greg_id, empr.empr_nmempresa, cbac.cbac_id, greg.greg_nmregional, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, cas.cast_dssituacaoacao, empr.empr_id , cbac.cbac_dscobrancaacao ";
				} else {
					groupBy = "group by cas.cast_id, loca.loca_id, uneg.uneg_id, greg.greg_id, cbac.cbac_id, greg.greg_nmregional, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, cas.cast_dssituacaoacao, cbac.cbac_dscobrancaacao ";
				}
				consulta = consulta
						+ groupBy
						+ "order by greg.greg_nmregional, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, cas.cast_id ";

			} else if (!idGerenciaRegional.trim().equals("-1")) {
				consulta = consulta + "and greg.greg_id = "
						+ idGerenciaRegional + " ";

				if (!idEmpresa.trim().equals("-1")) {
					groupBy = "group by cas.cast_id, greg.greg_id, empr.empr_nmempresa, cbac.cbac_id, greg.greg_nmregional,  cas.cast_dssituacaoacao, empr.empr_id , cbac.cbac_dscobrancaacao ";
				} else {
					groupBy = "group by cas.cast_id, greg.greg_id, cbac.cbac_id, greg.greg_nmregional, cas.cast_dssituacaoacao, cbac.cbac_dscobrancaacao ";
				}
				consulta = consulta + groupBy
						+ "order by greg.greg_nmregional, cas.cast_id ";

			} else if (!idUnidadeNegocio.trim().equals("-1")) {
				consulta = consulta + "and uneg.uneg_id = " + idUnidadeNegocio
						+ " ";

				if (!idEmpresa.trim().equals("-1")) {
					groupBy = "group by cas.cast_id, uneg.uneg_id, greg.greg_id, empr.empr_nmempresa, cbac.cbac_id, greg.greg_nmregional, uneg.uneg_nmunidadenegocio, cas.cast_dssituacaoacao, empr.empr_id , cbac.cbac_dscobrancaacao ";
				} else {
					groupBy = "group by cas.cast_id,  uneg.uneg_id, greg.greg_id, cbac.cbac_id, greg.greg_nmregional, uneg.uneg_nmunidadenegocio, cas.cast_dssituacaoacao, cbac.cbac_dscobrancaacao ";
				}

				consulta = consulta
						+ groupBy
						+ "order by greg.greg_nmregional, uneg.uneg_nmunidadenegocio,  cas.cast_id ";
			} else {

				if (!idEmpresa.trim().equals("-1")) {
					groupBy = "group by cas.cast_id, empr.empr_nmempresa, cbac.cbac_id, cas.cast_dssituacaoacao, empr.empr_id , cbac.cbac_dscobrancaacao ";
				} else {
					groupBy = "group by cas.cast_id, cbac.cbac_id, cas.cast_dssituacaoacao, cbac.cbac_dscobrancaacao ";
				}
				consulta = consulta + groupBy + "order by cas.cast_id ";
			}

			Query query = null;

			if (!idEmpresa.trim().equals("-1")) {
				query = session
						.createSQLQuery(consulta)
						.addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("uneg_id", Hibernate.INTEGER)
						.addScalar("uneg_nmunidadenegocio", Hibernate.STRING)
						.addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("cast_id", Hibernate.INTEGER)
						.addScalar("cast_dssituacaoacao", Hibernate.STRING)
						.addScalar("quantidadeSituacao", Hibernate.INTEGER)
						.addScalar("valorSituacao", Hibernate.BIG_DECIMAL)
						.addScalar("empr_id", Hibernate.INTEGER)
						.addScalar("empr_nmempresa", Hibernate.STRING)
						.addScalar("cbac_id", Hibernate.INTEGER)
						.addScalar("cbac_dscobrancaacao", Hibernate.STRING)
						.setDate("dataInicial",
								Util.converteStringParaDateHora(dataInicial))
						.setDate("dataFinal",
								Util.converteStringParaDateHora(dataFinal));
				retorno = query.list();
			} else {
				query = session
						.createSQLQuery(consulta)
						.addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("uneg_id", Hibernate.INTEGER)
						.addScalar("uneg_nmunidadenegocio", Hibernate.STRING)
						.addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("cast_id", Hibernate.INTEGER)
						.addScalar("cast_dssituacaoacao", Hibernate.STRING)
						.addScalar("quantidadeSituacao", Hibernate.INTEGER)
						.addScalar("valorSituacao", Hibernate.BIG_DECIMAL)
						.addScalar("cbac_id", Hibernate.INTEGER)
						.addScalar("cbac_dscobrancaacao", Hibernate.STRING)
						.setDate("dataInicial",
								Util.converteStringParaDateHora(dataInicial))
						.setDate("dataFinal",
								Util.converteStringParaDateHora(dataFinal));
				retorno = query.list();
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Esse método está de acordo com o UC0258 - Filtrar Documentos de Cobrança,
	 * retorna conjunto de CAAC_ID(ações do ciclo) selecionados
	 * 
	 * @author Anderson Italo
	 * @date 03/08/2009
	 * 
	 * @param Collection
	 *            <Integer> idsAcao
	 * @param Integer
	 *            anoMesReferencia
	 * @return Collection<CobrancaAcaoAtividadeCronograma> - a colecao de
	 *         cobrancaAcaoAtividadeCronograma associados as acoes e
	 *         anoMesReferencia Informados
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarAcoesCiclo(
			Collection idsAcao, Integer anoMesReferencia)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select caac.id "
					+ "from gcom.cobranca.CobrancaAcaoAtividadeCronograma caac "
					+ "inner join fetch caac.cobrancaAcaoCronograma cacr "
					+ "inner join cacr.cobrancaGrupoCronogramaMes cgcm "
					+ "where cgcm.anoMesReferencia = :anoMesReferencia "
					+ "and cacr.cobrancaAcao.id in (:ids) "
					+ "and caac.cobrancaAtividade.id = 2";

			retorno = session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setParameterList("ids", idsAcao).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o UC[0258]Filtrar Documento de Cobranca, é
	 * utilizado pelo relatório filtrar documentos de cobrança
	 * 
	 * @author Anderson Italo
	 * @date 19/08/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List filtrarCobrancaDocumento(FiltrarDocumentoCobrancaHelper filtro)
			throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emissão cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2
							|| filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, "
						+ "a.imov_id as idImovel, "
						+ "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, "
						+ "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, "
						+ "a.imov_nnsublote as subLote, "
						+ "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, "
						+ "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, "
						+ "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join cadastro.imovel a "
						+ "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b "
						+ "on a.loca_id = b.loca_id "
						+ "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id "
						+ "inner join cadastro.quadra d "
						+ "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null "
						+ "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id "
						+ "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id "
						+ "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id "
						+ "inner join cadastro.imovel_perfil i "
						+ "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j "
						+ "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k "
						+ "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l "
						+ "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id="
							+ filtro.getIdsDocumentoEmissaoForma()[0]
									.toString() + " and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissao
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a união dos 2 selects o primeiro trata apenas ações de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += " union ";

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, "
						+ "a.imov_id as idImovel, "
						+ "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, "
						+ "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, "
						+ "a.imov_nnsublote as subLote, "
						+ "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, "
						+ "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, "
						+ "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join cadastro.imovel a "
						+ "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b "
						+ "on a.loca_id = b.loca_id "
						+ "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id "
						+ "inner join cadastro.quadra d "
						+ "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null "
						+ "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id "
						+ "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id "
						+ "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id "
						+ "inner join cadastro.imovel_perfil i "
						+ "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j "
						+ "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k "
						+ "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l "
						+ "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i]
								.equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			} else {
				consulta += " select "
						+ "doc.cbdo_id as idDocumento, "
						+ "a.imov_id as idImovel, "
						+ "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, "
						+ "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, "
						+ "a.imov_nnsublote as subLote, "
						+ "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, "
						+ "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, "
						+ "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join cadastro.imovel a "
						+ "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b "
						+ "on a.loca_id = b.loca_id "
						+ "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id "
						+ "inner join cadastro.quadra d "
						+ "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null "
						+ "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id "
						+ "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id "
						+ "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id "
						+ "inner join cadastro.imovel_perfil i "
						+ "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j "
						+ "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k "
						+ "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l "
						+ "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta)
					.addScalar("idDocumento", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("codSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("lote", Hibernate.INTEGER)
					.addScalar("subLote", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("descricaoLigAguaSituacao", Hibernate.STRING)
					.addScalar("descricaoLigEsgotoSituacao", Hibernate.STRING)
					.addScalar("descricaoImovelPerfil", Hibernate.STRING)
					.addScalar("descricaoCategoria", Hibernate.STRING)
					.addScalar("data_emissao", Hibernate.TIMESTAMP)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("descricaoSituacaoAcao", Hibernate.STRING)
					.addScalar("descricaoSituacaoDebito", Hibernate.STRING);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o UC[0258]Filtrar Documento de Cobranca, é
	 * utilizado pelo relatório filtrar documentos de cobrança para totalizar os
	 * registros filtrados
	 * 
	 * @author Anderson Italo
	 * @date 19/08/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarCobrancaDocumentoCount(
			FiltrarDocumentoCobrancaHelper filtro)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emissão cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2
							|| filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select (select "
						+ " count(doc.cbdo_id) "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id="
							+ filtro.getIdsDocumentoEmissaoForma()[0]
									.toString() + " and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissao
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a união dos 2 selects o primeiro trata apenas ações de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += ") + ";

				consulta += " (select "
						+ "count(doc.cbdo_id) "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i]
								.equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += ") as totalDocumentos";

			} else {
				consulta += " select "
						+ "count(doc.cbdo_id) as totalDocumentos "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}
			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta).addScalar(
					"totalDocumentos", Hibernate.INTEGER);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o [UC0906] Gerar Relatório de
	 * Acompanhamento das Supressões, Religações e Reestabelecimentos. É
	 * utilizado pelo relatório filtrar os registros do relatorio
	 * 
	 * @author Anderson Italo
	 * @date 28/08/2009
	 * 
	 * @param FiltroSupressoesReligacoesReestabelecimentoHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List filtrarSupressoesReligacoesReestabelecimentos(
			FiltroSupressoesReligacoesReestabelecimentoHelper filtro)
			throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataInicial = Util.converteStringParaDateHora(filtro
				.getDataEmissaoInicio() + " 00:00:00");
		Date dataFinal = Util.converteStringParaDateHora(filtro
				.getDataEmissaoFim() + " 23:59:59");
		Integer limiteReligacaoCorteDias = new Integer(
				filtro.getLimititeReligacaoPosCorte());

		try {

			consulta = "select d.nomeAbreviado, d.nome, e.nome, b.descricao, "
					+ "sum(case when ((la.dataReligacao - la.dataCorte) < :limiteReligacaoCorteDias) "
					+ "and  (la.dataReligacao >= :dataInicial "
					+ "and la.dataReligacao <= :dataFinal)then 1 else 0 end) as religacaoMenosDeLimiteDias, "

					+ "sum(case when ((la.dataReligacao - la.dataCorte) >= :limiteReligacaoCorteDias) "
					+ "and  (la.dataReligacao >= :dataInicial "
					+ "and la.dataReligacao <= :dataFinal) then 1 else 0 end) as religacaoMaiorDeLimiteDias, "

					+ "sum(case when ((la.dataSupressao is not null) "
					+ "and (la.dataSupressao >= :dataInicial "
					+ "and la.dataSupressao <= :dataFinal)) then 1 else 0 end) as supressao, "

					+ "sum(case when ((la.dataRestabelecimentoAgua is not null) "
					+ "and (la.dataRestabelecimentoAgua >= :dataInicial "
					+ "and la.dataRestabelecimentoAgua <= :dataFinal)) then 1 else 0 end) as reestabelecimento, "

					+ "sum(case when ((la.dataCorte is not null) "
					+ "and (la.dataCorte >= :dataInicial "
					+ "and la.dataCorte <= :dataFinal) "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao in (48))) then 1 else 0 end) as cortes "

					+ "from gcom.atendimentopublico.ligacaoagua.LigacaoAgua la, "
					+ "gcom.cadastro.imovel.Imovel im, "
					+ "gcom.cadastro.localidade.Localidade b, "
					+ "gcom.cadastro.empresa.Empresa c, "
					+ "gcom.cadastro.localidade.GerenciaRegional d, "
					+ "gcom.cadastro.localidade.UnidadeNegocio e, "
					+ "gcom.atendimentopublico.ordemservico.OrdemServico f, "
					+ "gcom.atendimentopublico.ordemservico.OrdemServicoUnidade g, "
					+ "gcom.seguranca.acesso.usuario.Usuario h "
					+ "where la.id = im.id "
					+ "and im.localidade.id = b.id "
					+ "and b.gerenciaRegional.id = d.id "
					+ "and b.unidadeNegocio.id = e.id "
					+ "and im.id = f.imovel.id "
					+ "and f.atendimentoMotivoEncerramento.id = 2 "
					+ "and f.id = g.ordemServico.id "
					+ "and g.atendimentoRelacaoTipo.id = 3 "
					+ "and g.usuario.id = h.id "
					+ "and h.empresa.id = c.id "
					+ "and  ((la.dataReligacao = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataReligacao >= :dataInicial "
					+ "and   la.dataReligacao <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao = 50)"
					+ ") "
					+ "or    (la.dataSupressao = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataSupressao >= :dataInicial "
					+ "and   la.dataSupressao <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao = 685)"
					+ ") "
					+ "or    (la.dataRestabelecimentoAgua = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataRestabelecimentoAgua >= :dataInicial "
					+ "and   la.dataRestabelecimentoAgua <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao in (51,879))"
					+ ")"
					+ "or    (la.dataCorte = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataCorte >= :dataInicial "
					+ "and   la.dataCorte <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao in (48))" + ")" + ") "
					+ "and ";

			// idGerenciaRegional
			if (filtro.getIdGerenciaRegional() != null
					&& !filtro.getIdGerenciaRegional().equals("")) {
				consulta += "d.id = " + filtro.getIdGerenciaRegional()
						+ " and ";
			}

			// unidadeNegocio
			if (filtro.getIdUnidadeNegocio() != null
					&& !filtro.getIdUnidadeNegocio().equals("")) {
				consulta += "e.id = " + filtro.getIdUnidadeNegocio() + " and ";
			}

			// Localidade
			if (filtro.getIdLocalidade() != null
					&& !filtro.getIdLocalidade().equals("")) {
				consulta += "b.id = " + filtro.getIdLocalidade() + " and ";
			}

			// Empresa
			if (filtro.getIdEmpresa() != null
					&& !filtro.getIdEmpresa().equals("")) {
				consulta += "c.id = " + filtro.getIdEmpresa() + " and ";
			}

			// retira o and do final se houver
			if (consulta.substring(consulta.length() - 4, consulta.length())
					.equals("and ")) {
				consulta = consulta.substring(0, consulta.length() - 4);
			}

			consulta += " group by " + "d.nomeAbreviado, d.nome, "
					+ "e.nome, b.descricao " + "order by "
					+ "d.nomeAbreviado, d.nome, " + "e.nome, b.descricao";

			retorno = session
					.createQuery(consulta)
					.setParameter("limiteReligacaoCorteDias",
							limiteReligacaoCorteDias)
					.setParameter("dataInicial", dataInicial)
					.setParameter("dataFinal", dataFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o UC[0258]Filtrar Documento de Cobranca
	 * 
	 * @author Anderson Italo
	 * @date 16/09/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List consultarDocumentosCobranca(
			FiltrarDocumentoCobrancaHelper filtro)
			throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emissão cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2
							|| filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, "
						+ "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id="
							+ filtro.getIdsDocumentoEmissaoForma()[0]
									.toString() + " and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissao
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a união dos 2 selects o primeiro trata apenas ações de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += " union ";

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, "
						+ "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i]
								.equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			} else {
				consulta += " select "
						+ "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, "
						+ "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscrição
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emissão
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// ação de cobrança
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação da ação
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situação do débito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo não entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o parêntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o parêntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// período emissão
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta)
					.addScalar("idDocumento", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idCobrancaAcao", Hibernate.INTEGER)
					.addScalar("descricaoCobrancaAcao", Hibernate.STRING)
					.addScalar("data_emissao", Hibernate.TIMESTAMP)
					.addScalar("idEmissaoForma", Hibernate.INTEGER)
					.addScalar("descricaoEmissaoForma", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER)
					.addScalar("descricaoDocumentoTipo", Hibernate.STRING)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("nomeEmpresa", Hibernate.STRING)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0959] Gerar Arquivo Texto de Pagamentos das Contas em Cobrança por
	 * Empresa
	 * 
	 * @author: Hugo Amorim
	 * @date: 05/10/2009
	 */
	public Collection pesquisarDadosArquivoTextoPagamentosContasCobrancaEmpresa(
			Integer idEmpresa, Integer referenciaInicial,
			Integer referenciaFinal, Integer quantidadeRegistros,
			Integer numeroIndice, Integer idUnidadeNegocio)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select cc.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnhi.cnhi_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ " eccp_ictipopagamento as tipoPagamento," // 5
					+ " eccp_nnparcelaatual as numParcelas," // 6
					+ " eccp_nntotalparcelas as numParcelasTotal," // 7
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 8
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 9
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 10
					+ " lc.uneg_id as idUnidadeNegocio, "// 11
					+ " un.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 12
					+ " im.loca_id as idLocalidade, "// 13
					+ " lc.loca_nmlocalidade as nomeLocalidade, "// 14
					+ " qd.qdra_nnquadra as quadra, "// 15
					+ " im.imov_nnlote as lote, "// 16
					+ " im.imov_nnsublote as sublote, "// 17
					+ " rt.rota_cdrota as codigoRota, "// 18
					+ " im.imov_nnsequencialrota as sequenciaRota, "// 19
					+ " cnhi.cnhi_cdsetorcomercial as codSetor, "// 20
					+ " ccp.eccp_dtpagamento as dataPagamento " // 21
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta_historico  cnhi "
					+ "on cnhi.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id "
					+ "where un.uneg_id = :idUnidadeNegocio ";

			if (referenciaInicial != null && referenciaFinal != null
					&& referenciaInicial != referenciaFinal) {
				consulta = consulta + "and (eccp_ampagamento between "
						+ referenciaInicial + " and " + referenciaFinal + ") ";
			} else {
				consulta = consulta + "and eccp_ampagamento = "
						+ referenciaFinal + " ";
			}

			consulta = consulta
					+ "group by cc.imov_id, clie_nmcliente, cnhi.cnhi_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, eccp_ictipopagamento,eccp_nnparcelaatual, eccp_nntotalparcelas,cc.ecco_pcempresaconta,lc.uneg_id,un.uneg_nmunidadenegocio,im.loca_id,lc.loca_nmlocalidade,qd.qdra_nnquadra,im.imov_nnlote,im.imov_nnsublote,rt.rota_cdrota,im.imov_nnsequencialrota,cnhi.cnhi_cdsetorcomercial,ccp.eccp_dtpagamento ";
			// consulta = consulta + "order by 12, 14, 1,3 ";

			consulta = consulta
					+ " UNION "
					+ "select cc.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnta.cnta_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ " eccp_ictipopagamento as tipoPagamento," // 5
					+ " eccp_nnparcelaatual as numParcelas," // 6
					+ " eccp_nntotalparcelas as numParcelasTotal," // 7
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 8
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 9
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 10
					+ " lc.uneg_id as idUnidadeNegocio, "// 11
					+ " un.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 12
					+ " im.loca_id as idLocalidade, "// 13
					+ " lc.loca_nmlocalidade as nomeLocalidade, "// 14
					+ " qd.qdra_nnquadra as quadra, "// 15
					+ " im.imov_nnlote as lote, "// 16
					+ " im.imov_nnsublote as sublote, "// 17
					+ " rt.rota_cdrota as codigoRota, "// 18
					+ " im.imov_nnsequencialrota as sequenciaRota, "// 19
					+ " cnta.cnta_cdsetorcomercial as codSetor, "// 20
					+ " ccp.eccp_dtpagamento as dataPagamento " // 21
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta  cnta "
					+ "on cnta.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id "
					+ "where un.uneg_id = :idUnidadeNegocio ";

			if (referenciaInicial != null && referenciaFinal != null
					&& referenciaInicial != referenciaFinal) {
				consulta = consulta + "and (eccp_ampagamento between "
						+ referenciaInicial + " and " + referenciaFinal + ") ";
			} else {
				consulta = consulta + "and eccp_ampagamento = "
						+ referenciaFinal + " ";
			}

			consulta = consulta
					+ "group by cc.imov_id, clie_nmcliente, cnta.cnta_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, eccp_ictipopagamento,eccp_nnparcelaatual, eccp_nntotalparcelas,cc.ecco_pcempresaconta,lc.uneg_id,un.uneg_nmunidadenegocio,im.loca_id,lc.loca_nmlocalidade,qd.qdra_nnquadra,im.imov_nnlote,im.imov_nnsublote,rt.rota_cdrota,im.imov_nnsequencialrota,cnta.cnta_cdsetorcomercial,ccp.eccp_dtpagamento ";
			consulta = consulta + "order by 12, 14, 1,3 ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER)
					.addScalar("tipoPagamento", Hibernate.INTEGER)
					.addScalar("numParcelas", Hibernate.INTEGER)
					.addScalar("numParcelasTotal", Hibernate.INTEGER)
					.addScalar("valorPrincipal", Hibernate.BIG_DECIMAL)
					.addScalar("valorEncargos", Hibernate.BIG_DECIMAL)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("quadra", Hibernate.INTEGER)
					.addScalar("lote", Hibernate.INTEGER)
					.addScalar("sublote", Hibernate.INTEGER)
					.addScalar("codigoRota", Hibernate.INTEGER)
					.addScalar("sequenciaRota", Hibernate.INTEGER)
					.addScalar("codSetor", Hibernate.INTEGER)
					.addScalar("dataPagamento", Hibernate.DATE)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("idUnidadeNegocio", idUnidadeNegocio)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		System.out.println(retorno.size());
		return retorno;

	}

	public Collection obterUnidadeNegocioPagamentosEmpresaCobrancaConta()
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct loca.uneg_id as idUnidadeNegocio "
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "inner join cadastro.localidade loca on loca.loca_id = imov.loca_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] Gerar Arquivo Texto para Faturamento
	 * 
	 * @author Sávio Luiz
	 */
	public CobrancaDocumento pesquisarCobrancaDocumentoImpressaoSimultanea(
			Date dataEmissao, Integer idImovel) throws ErroRepositorioException {

		CobrancaDocumento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.localidade loca "
					+ "WHERE cbdo.imovel.id = :idImovel AND "
					+ "cbdo.documentoTipo.id = :idDocumentoTipo AND "
					+ "cbdo.cobrancaDebitoSituacao.id = :idCobrancaDebitoSituacao AND "
					+ "cbdo.emissao >= :dataEmissao "
					+ "order by cbdo.emissao desc ";

			retorno = (CobrancaDocumento) session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", DocumentoTipo.AVISO_CORTE)
					.setInteger("idCobrancaDebitoSituacao",
							CobrancaDebitoSituacao.PENDENTE)
					.setTimestamp("dataEmissao", dataEmissao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC????] Relatorio Comando Documento Cobranca Alterado para verificar
	 * tipo da ação a partir da tabela documento_tipo
	 * 
	 * @author Rômulo Aurélio, Anderson Italo
	 * 
	 * @data 20/10/2009, 04/05/2010
	 */
	public DocumentoTipo pesquisarTipoAcaoCobrancaParaRelatorio(
			Integer cobrancaAcaoAtividadeComando,
			Integer cobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		DocumentoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT DISTINCT cobrancaDocumento.documentoTipo "
					+ "FROM CobrancaDocumento cobrancaDocumento ";

			if (cobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id =  "
						+ cobrancaAcaoAtividadeCronograma + " ";
			} else if (cobrancaAcaoAtividadeComando != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeComando.id = "
						+ cobrancaAcaoAtividadeComando + " ";
			}

			retorno = (DocumentoTipo) session.createQuery(consulta)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<CobrancaDocumento> pesquisarDocumentoCobrancaParaRelatorio(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento cbdo "
					+ "INNER JOIN FETCH cbdo.imovel imov "
					+ "INNER JOIN FETCH imov.quadra qdra "
					+ "INNER JOIN FETCH qdra.rota "
					+ "INNER JOIN FETCH cbdo.ligacaoAguaSituacao "
					+ "INNER JOIN FETCH cbdo.ligacaoEsgotoSituacao " + "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			} else if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}

			consulta = consulta
					+ " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ "imov.lote, imov.subLote, cbdo.id";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer obterOrdemServicoAssociadaDocumentoCobranca(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select orse_id as idOrdemServico "
					// + "from cobranca.cobranca_documento cbdo "
					+ "from atendimentopublico.ordem_servico "
					+ "where cbdo_id  = " + idCobrancaDocumento + " ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * @author Rômulo Aurélio
	 * @date 20/10/2009
	 * 
	 * @param idCobrancaDocumento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public CobrancaDocumento pesquisarCobrancaDocumento(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		CobrancaDocumento retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento  "
					+ "FROM cobrancaDocumento cd "
					+ "inner join fetch cd.cobrancaAcao "
					+ "WHERE cd.id = :idCobrancaDocumento ";

			retorno = (CobrancaDocumento) session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este método está de acordo com o [UC0901] Gerar Metas do Ciclo
	 * 
	 * @author Anderson Italo
	 * @date 21/09/2009
	 * 
	 * @param Integer
	 *            idCicloMeta
	 * @throws ErroRepositorioException
	 */
	public void removerCicloMetaGrupo(Integer idCicloMeta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "delete CicloMetaGrupo c "
					+ "where c.cicloMeta.id = :idCicloMeta ";

			session.createQuery(consulta)
					.setInteger("idCicloMeta",
							new Integer(idCicloMeta).intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * retorna coleção de idEmpresaCobranca de uma Rota
	 * 
	 * @author Arthur Carvalho
	 * @date 06/11/2009
	 * 
	 * @param id
	 *            da localidade
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarEmpresaCobrancaDaRota(
			Integer idLocalidade) throws ErroRepositorioException {

		Collection<Integer> idEmpresaCobranca = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(rota.empr_idcobranca) as idCobranca "
					+ " FROM micromedicao.rota rota "
					+ " INNER JOIN cadastro.setor_comercial setor "
					+ " ON setor.stcm_id = rota.stcm_id "
					+ " WHERE setor.loca_id = " + idLocalidade + " ";

			idEmpresaCobranca = session.createSQLQuery(consulta)
					.addScalar("idCobranca", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return idEmpresaCobranca;
	}

	/**
	 * [UC0630] - Solicitar Emissão do Extrato de Débitos Author: Rômulo Aurélio
	 * Data: 05/11/2009
	 * 
	 * Obtem os débitos a cobrar que estejam com PARC_ID = NULL, com SITUACAO
	 * NORMAL E FINANCIAMENTO_TIPO = 2
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarParceladoComIDNulo(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(dbac) "
					+ "FROM DebitoACobrar dbac "
					+ "inner join fetch dbac.debitoTipo debitoTipo "
					+ "where dbac.imovel.id = :idImovel  "
					+ "AND dbac.financiamentoTipo = 2 "
					+ "AND dbac.parcelamento is null "
					+ "AND dbac.numeroPrestacaoCobradas < (dbac.numeroPrestacaoDebito - coalesce(dbac.numeroParcelaBonus,0)) "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * atualiza o valor do documento e o valor de desconto do documento de
	 * cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorDocumentoEValorDescontoCobrancaDocumento(
			Integer idCobrancaDocumento, BigDecimal valorDocumento,
			BigDecimal valorDesconto) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String consulta = "update gcom.cobranca.CobrancaDocumento "
					+ "set cbdo_vldocumento = :valorDocumento , "
					+ "cbdo_vldesconto = :valorDesconto , "
					+ "cbdo_tmultimaalteracao = :dataAtual "
					+ "where cbdo_id = :idCobrancaDocumento ";

			session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setBigDecimal("valorDocumento", valorDocumento)
					.setBigDecimal("valorDesconto", valorDesconto)
					.setDate("dataAtual", new Date()).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * pesquisa o documento de cobranca do imovel e do documento tipo passado
	 * como parametro
	 * 
	 * @author Vivianne Sousa
	 * @date 19/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoDoImovel(
			Integer idImovel, Integer idDocumentoTipo)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo "
					+ "LEFT JOIN cbdo.imovel as imov "
					+ "LEFT JOIN cbdo.documentoTipo as docTipo " + "WHERE "
					+ "imov.id = :idImovel and docTipo = :idDocumentoTipo ";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Criança para
	 * Negociação a Vista
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos das cartas
	 * de fim de ano
	 * 
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirCartaFinalAno(Integer idCobrancaGrupo,
			Integer idEmpresa, Integer idLocalidade, Integer codigoSetor,
			Integer numeroQuadra, Integer lote, Integer subLote,
			Integer sequencial, String txt_parte1, String txt_parte2,
			Integer idRota) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into public.carta_final_ano values ("
					+ idCobrancaGrupo + "," + idEmpresa + "," + idLocalidade
					+ "," + codigoSetor + "," + numeroQuadra + "," + lote + ","
					+ subLote + "," + sequencial + "," + "'" + txt_parte1
					+ "'," + "'" + txt_parte2 + "'," + idRota + ")";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [0968] - Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCartaFinalAnoGrupo(Integer idCobrancaGrupo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		Collection retorno = new ArrayList();

		try {
			stmt = con.createStatement();

			consulta = " select txt_parte1  as parte1 , txt_parte2 as parte2 "
					+ " from carta_final_ano "
					+ " where cbgr_id = "
					+ idCobrancaGrupo
					+ " order by  empr_id,loca_id,stcm_cdsetorcomercial, qdra_nnqdra,imon_nnlote ,imov_nnsublote, sequencial";

			ResultSet set = stmt.executeQuery(consulta);

			while (set.next()) {
				Object[] objs = new Object[2];
				objs[0] = set.getString("parte1");
				objs[1] = set.getString("parte2");
				retorno.add(objs);
			}

			return retorno;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarCartaFinalAno(Integer idRota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "delete from carta_final_ano where  rota_id = " + idRota;

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Anderson Italo
	 * @date 26/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeImoveisPorGrupoCobranca(
			Integer idCobrancaGrupo, Integer gerencia, Integer unidade,
			Integer localidade, Integer setorComercial, Integer quadra)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;

		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis"
					+ " FROM cadastro.imovel i"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
					+ " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id"
					+ " where r.cbgr_id = :idCobrancaGrupo "
					+ " and i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session.createSQLQuery(query)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo)
					.setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;

	}

	/**
	 * @author Anderson Italo
	 * @date 30/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeImoveisPorComandoEventual(
			Integer idCobrancaAcaoAtividadeComando, Integer gerencia,
			Integer unidade, Integer localidade, Integer setorComercial,
			Integer quadra) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;

		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis"
					+ " FROM cadastro.imovel i"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
					+ " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id"
					+ " join cobranca.cobranca_ativ_cmd_rota c on c.rota_id = r.rota_id"
					+ " where c.cacm_id = :idCobrancaAcaoAtividadeComando "
					+ " and i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session
					.createSQLQuery(query)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setInteger("idCobrancaAcaoAtividadeComando",
							idCobrancaAcaoAtividadeComando)
					.setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;

	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * [FS0008] - Verificar validade da data
	 * 
	 * @author Raphael Rossiter
	 * @date 07/01/2010
	 * 
	 * @param idCliente
	 * @param idArrecadacaoForma
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short pesquisarNumeroDiasFloatCartao(Integer idCliente,
			Integer idArrecadacaoForma) throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT actf.numeroDiaFloat "
					+ "FROM ArrecadadorContratoTarifa actf "
					+ "INNER JOIN actf.arrecadadorContrato arct "
					+ "INNER JOIN arct.arrecadador arrc "
					+ "INNER JOIN arrc.cliente clie "
					+ "INNER JOIN actf.arrecadacaoForma arfm "
					+ "WHERE clie.id = :idCliente AND arfm.id = :idFormaArrecadacao";

			retorno = (Short) session.createQuery(consulta)
					.setInteger("idCliente", idCliente)
					.setInteger("idFormaArrecadacao", idArrecadacaoForma)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 11/01/2010
	 * 
	 * @param idCliente
	 * @param dataVencimento
	 * @return GuiaPagamento
	 * @throws ErroRepositorioException
	 */
	public GuiaPagamento pesquisarGuiaPagamentoCartaoCredito(Integer idCliente,
			Date dataVencimento) throws ErroRepositorioException {

		GuiaPagamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gpag "
					+ "FROM GuiaPagamento gpag "
					+ "INNER JOIN FETCH gpag.cliente clie "
					+ "INNER JOIN FETCH gpag.debitoTipo dbtp "
					+ "INNER JOIN FETCH gpag.localidade loca "
					+ "WHERE clie.id = :idCliente AND gpag.dataVencimento = :dataVencimento";

			retorno = (GuiaPagamento) session.createQuery(consulta)
					.setInteger("idCliente", idCliente)
					.setDate("dataVencimento", dataVencimento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @param guiaPagamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarGuiaPagamentoCartaoCredito(GuiaPagamento guiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaValorGuiaPagamento;

		try {

			// GUIA DE PAGAMENTO
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set gpag_vldebito = :valorDebito, gpag_tmultimaalteracao = :ultimaAlteracao, "
					+ "usur_id = :usuarioLogado where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento)
					.setInteger("idGuiaPagamento",
							guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito",
							guiaPagamento.getValorDebito())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("usuarioLogado",
							guiaPagamento.getUsuario().getId().intValue())
					.executeUpdate();

			// GUIA DE PAGAMENTO ITEM
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamentoItem "
					+ "set gpai_vldebito = :valorDebito, gpai_tmultimaalteracao = :ultimaAlteracao "
					+ "where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento)
					.setInteger("idGuiaPagamento",
							guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito",
							guiaPagamento.getValorDebito())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

			// GUIA DE PAGAMENTO CATEGORIA
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamentoCategoria "
					+ "set gpcg_vlcategoria = :valorDebito, gpcg_tmultimaalteracao = :ultimaAlteracao "
					+ "where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento)
					.setInteger("idGuiaPagamento",
							guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito",
							guiaPagamento.getValorDebito())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @return Localidade
	 * @throws ErroRepositorioException
	 */
	public Localidade pesquisarLocalidadeSede() throws ErroRepositorioException {

		Localidade retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT loca "
					+ "FROM Localidade loca WHERE loca.indicadorLocalidadeSede = :indicadorAtivo";

			retorno = (Localidade) session
					.createQuery(consulta)
					.setShort("indicadorAtivo",
							ConstantesSistema.INDICADOR_USO_ATIVO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @return DebitoTipo
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo pesquisarDebitoTipoCartaoCredito()
			throws ErroRepositorioException {

		DebitoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT dbtp "
					+ "FROM DebitoTipo dbtp WHERE dbtp.indicadorDebitoCartaoCredito = :indicadorAtivo";

			retorno = (DebitoTipo) session
					.createQuery(consulta)
					.setShort("indicadorAtivo",
							ConstantesSistema.INDICADOR_USO_ATIVO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004] - Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 18/01/2010
	 * 
	 * @param idArrecadador
	 * @param dataLancamento
	 * @return AvisoBancario
	 * @throws ErroRepositorioException
	 */
	public AvisoBancario pesquisarAvisoBancario(Integer idArrecadador,
			Date dataLancamento) throws ErroRepositorioException {

		AvisoBancario retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT avbc " 
					+ "FROM AvisoBancario avbc "
					+ "INNER JOIN FETCH avbc.arrecadador arrc "
					+ "WHERE arrc.id = :idArrecadador "
					+ "AND avbc.dataLancamento = :dataLancamento";

			retorno = (AvisoBancario) session.createQuery(consulta)
					.setInteger("idArrecadador", idArrecadador)
					.setDate("dataLancamento", dataLancamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0005 - Calcular Valor da Dedução]
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idArrecadador
	 * @param idArrecadacaoForma
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ArrecadadorContratoTarifa pesquisarArrecadadorContratoTarifa(
			Integer idArrecadador, Integer idArrecadacaoForma)
			throws ErroRepositorioException {

		ArrecadadorContratoTarifa retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT actf "
					+ "FROM ArrecadadorContratoTarifa actf "
					+ "INNER JOIN FETCH actf.arrecadadorContrato arct "
					+ "INNER JOIN arct.arrecadador arrc "
					+ "INNER JOIN actf.arrecadacaoForma arfm "
					+ "WHERE arrc.id = :idArrecadador AND arfm.id = :idFormaArrecadacao";

			retorno = (ArrecadadorContratoTarifa) session.createQuery(consulta)
					.setInteger("idArrecadador", idArrecadador)
					.setInteger("idFormaArrecadacao", idArrecadacaoForma)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004] - Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 28/04/2010
	 * 
	 * @param avisoBancario
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorAvisoBancario(AvisoBancario avisoBancario)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarValorAvisoBancario;

		try {

			atualizarValorAvisoBancario = "update gcom.arrecadacao.aviso.AvisoBancario "
					+ "set avbc_vlrealizado = :valorRealizado, "
					+ "avbc_vlarrecadacaoinformado = :valorArrecadacaoInformado, "
					+ "avbc_vldevolucaocalculado = :valorDevolucaoCalculado, "
					+ "avbc_tmultimaalteracao = :ultimaAlteracao "
					+ "where avbc_id = :idAvisoBancario";

			session.createQuery(atualizarValorAvisoBancario)
					.setInteger("idAvisoBancario", avisoBancario.getId())
					.setBigDecimal("valorRealizado",
							avisoBancario.getValorRealizado())
					.setBigDecimal("valorArrecadacaoInformado",
							avisoBancario.getValorArrecadacaoInformado())
					.setBigDecimal("valorDevolucaoCalculado",
							avisoBancario.getValorDevolucaoCalculado())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004] - Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public AvisoDeducoes pesquisarAvisoDeducoes(Integer idAvisoBancario)
			throws ErroRepositorioException {

		AvisoDeducoes retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT avdd " + "FROM AvisoDeducoes avdd "
					+ "INNER JOIN avdd.avisoBancario avbc "
					+ "WHERE avbc.id = :idAvisoBancario ";

			retorno = (AvisoDeducoes) session.createQuery(consulta)
					.setInteger("idAvisoBancario", idAvisoBancario)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * 
	 * [SB0004] - Incluir Dados da Confirmação dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idAvisoBancario
	 * @param valorTotalAvisoDeducoes
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorAvisoDeducoes(Integer idAvisoBancario,
			BigDecimal valorTotalAvisoDeducoes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarValorAvisoDeducoes;

		try {

			atualizarValorAvisoDeducoes = "update gcom.arrecadacao.aviso.AvisoDeducoes "
					+ "set avdd_vldeducao = :valorTotalAvisoDeducoes, "
					+ "avdd_tmultimaalteracao = :ultimaAlteracao "
					+ "where avbc_id = :idAvisoBancario";

			session.createQuery(atualizarValorAvisoDeducoes)
					.setInteger("idAvisoBancario", idAvisoBancario)
					.setBigDecimal("valorTotalAvisoDeducoes",
							valorTotalAvisoDeducoes)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	// /////////////////////////////////////////////////////////////
	/**
	 * [UC0349] Emitir Documento de Cobrança - Aviso de Corte
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos do aviso de
	 * corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirDocumentoCobrancaImpressao(Integer idCobrancaDocumento,
			String linhaTxt, Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer sequencialImpressao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into cobranca.cobranca_documento_impr values ("
					+ idCobrancaDocumento + "," + "'" + linhaTxt + "',"
					+ idCobrancaAcaoAtividadeComando + ","
					+ idCobrancaAcaoAtividadeCronograma + ","
					+ sequencialImpressao + "," + Util.obterSQLDataAtual()
					+ ", null )";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança - Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDocumentoCobrancaImpressao(
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdim.linhaTxt "
					+ "FROM CobrancaDocumentoImpressao cdim ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeComando cacm "
						+ " WHERE  cacm.id = " + idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeCronograma caac "
						+ " WHERE  caac.id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			consulta = consulta + " order by cdim.sequencialImpressao ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança - Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDocumentoCobrancaImpressao(
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "delete from cobranca.cobranca_documento_impr where ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " cacm_id = "
						+ idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " caac_id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			int teste = stmt.executeUpdate(consulta);

			System.out.println("teste " + teste);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança - Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDocumentoCobrancaImpressao(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumentoImpressao "
					+ "WHERE id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC0987] Inserir Faixa de Dias Vencidos para Documentos a Receber
	 * 
	 * Verificar se existe Faixa inicial já cadastrada.
	 * 
	 * @author Hugo Leonardo
	 * @param valorInicialFaixa
	 * @throws ControladorException
	 * @data 22/02/2010
	 * 
	 * @return Boolean
	 * @throws ErroRepositorioException
	 */
	public String verificarExistenciaFaixaInicial(Integer valorInicialFaixa)
			throws ErroRepositorioException {

		String retorno = "";

		Session session = HibernateUtil.getSession();

		String consulta = "";

		consulta += " select drfx_dsfaixa as cont "
				+ " from cobranca.docs_a_rec_fx_dias_vcdos "
				+ " where (drfx_vlfaixainicio <= " + valorInicialFaixa
				+ " and drfx_vlfaixafim >= " + valorInicialFaixa + " )";
		try {
			retorno = (String) session.createSQLQuery(consulta)
					.addScalar("cont", Hibernate.STRING).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0987] Inserir Faixa de Dias Vencidos para Documentos a Receber
	 * 
	 * Verificar se existe Faixa final já cadastrada.
	 * 
	 * @author Hugo Leonardo
	 * @param valorFinalFaixa
	 * @throws ControladorException
	 * @data 22/02/2010
	 * 
	 * @return Boolean
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaFaixaFinal(Integer valorFinalFaixa)
			throws ErroRepositorioException {

		int retorno = 0;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		consulta += " select count(drfx_id) as cont "
				+ " from cobranca.docs_a_rec_fx_dias_vcdos "
				+ " where (drfx_vlfaixainicio <= " + valorFinalFaixa
				+ " and drfx_vlfaixafim >= " + valorFinalFaixa + " )";
		try {
			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("cont", Hibernate.INTEGER).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC990] Gerar Relatório de Documentos a Receber
	 * 
	 * @author Hugo Amorim
	 * @date 22/02/2010
	 * 
	 */
	public Collection pesquisarRelatorioDocumentosAReceber(
			FiltroRelatorioDocumentosAReceberHelper helper,
			String tipoTotalizacao, int quantidadeInicio, int quantidadeMaxima)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		Query query = null;

		Map parameters = new HashMap();

		try {

			consulta += " SELECT " + " dar.catg_id as idCat, "
					+ " cat.catg_dscategoria as dsCat, ";

			if (tipoTotalizacao.equals("LOCALIDADE")) {
				consulta += " dar.greg_id as idGer, "
						+ " gr.greg_nmregional as dsGer, "
						+ " dar.uneg_id as idUn , "
						+ " un.uneg_nmunidadenegocio as dsUn, "
						+ " dar.loca_id as idLoca, "
						+ " loc.loca_nmlocalidade as dsLoca,  ";
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				consulta += " dar.greg_id as idGer, "
						+ " gr.greg_nmregional as dsGer, "
						+ " dar.uneg_id as idUn , "
						+ " un.uneg_nmunidadenegocio as dsUn, ";
			} else if (tipoTotalizacao.equals("GERENCIA")) {
				consulta += " dar.greg_id as idGer, "
						+ " gr.greg_nmregional as dsGer, ";
			}

			consulta += " dar.dotp_id as idDt, "
					+ " dt.dotp_dsdocumentotipo as dsDt, "
					+ " drrs_icsituacaodocumentos as icSit, "
					+ "  case drrs_icsituacaodocumentos "
					+ "    when 1 then 'A VENCER' "
					+ "    when 2 then 'VENCIDOS' "
					+ "  end as dsSit,  "
					+ " drrs_qtdiasvencidos as faixa, "
					+ " sum(drrs_qtdocumentos) as qtDoc,  "
					+ " sum(drrs_vldocumentos) as vlDoc "
					+ " FROM financeiro.docs_a_rec_resumo dar "
					+ " INNER JOIN cobranca.documento_tipo dt on dt.dotp_id = dar.dotp_id "
					+ " INNER JOIN cadastro.categoria cat on cat.catg_id = dar.catg_id "
					+ " LEFT JOIN cadastro.categoria_tipo catTipo on catTipo.cgtp_id = cat.cgtp_id "
					+ " INNER JOIN cadastro.gerencia_regional gr on gr.greg_id = dar.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio un on un.uneg_id = dar.uneg_id "
					+ " INNER JOIN cadastro.localidade loc on loc.loca_id = dar.loca_id "
					// +" LEFT JOIN cobranca.documentos_a_receber_faixa_dias_vencidos faixa on faixa.drfx_icuso = 1 "
					+ " WHERE drrs_amreferenciarecebimentos = :anoMes and ";

			parameters.put("anoMes", helper.getMesAno());

			if (helper.getIdCategoriaTipo() != null
					&& !helper.getIdCategoriaTipo().equals("-1")) {
				consulta += " catTipo.cgtp_id in(:idCategoriaTipo) and ";
				parameters.put("idCategoriaTipo", helper.getIdCategoriaTipo());

			}

			if (helper.getIdsCategoria() != null
					&& helper.getIdsCategoria().length != 0) {

				Collection idsCategorias = new ArrayList();
				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					String idCategoria = helper.getIdsCategoria()[i];
					if (!idCategoria.equals("-1")) {
						idsCategorias.add(new Integer(idCategoria));
					}
				}
				if (idsCategorias.size() > 0) {
					consulta += " dar.catg_id in(:idsCategorias) and ";
					parameters.put("idsCategorias", idsCategorias);
				}
			}

			if (helper.getIdsPerfilImovel() != null
					&& helper.getIdsPerfilImovel().length != 0) {

				Collection idsPerfis = new ArrayList();
				for (int i = 0; i < helper.getIdsPerfilImovel().length; i++) {
					String idPerfil = helper.getIdsPerfilImovel()[i];
					if (!idPerfil.equals("-1")) {
						idsPerfis.add(new Integer(idPerfil));
					}
				}
				if (idsPerfis.size() > 0) {
					consulta += " dar.iper_id in(:idsPerfis) and ";
					parameters.put("idsPerfis", idsPerfis);
				}
			}

			if (helper.getIdsEsferaPoder() != null
					&& helper.getIdsEsferaPoder().length != 0) {

				Collection idsEsferas = new ArrayList();
				for (int i = 0; i < helper.getIdsEsferaPoder().length; i++) {
					String idsEsfera = helper.getIdsEsferaPoder()[i];
					if (!idsEsfera.equals("-1")) {
						idsEsferas.add(new Integer(idsEsfera));
					}
				}
				if (idsEsferas.size() > 0) {
					consulta += " dar.epod_id in(:idsEsferas) and ";
					parameters.put("idsEsferas", idsEsferas);
				}
			}

			if (helper.getIdGerencia() != null
					&& !helper.getIdGerencia().equals("-1")) {
				consulta += " dar.greg_id = :idGerencia and ";
				parameters.put("idGerencia", helper.getIdGerencia());
			}
			if (helper.getIdUnidade() != null
					&& !helper.getIdUnidade().equals("-1")) {
				consulta += " dar.uneg_id = :idUnidade and ";
				parameters.put("idUnidade", helper.getIdUnidade());
			}
			if (helper.getIdLocalidade() != null
					&& !helper.getIdLocalidade().equals("")) {
				consulta += " dar.loca_id = :idLocalidade and ";
				parameters.put("idLocalidade", helper.getIdLocalidade());
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			// INCLUI FAIXAS
			consulta += " and (drrs_qtdiasvencidos = 0 or ";
			for (Iterator iterator = helper.getColecaoFaixas().iterator(); iterator
					.hasNext();) {
				FaixaHelper faixaHelper = (FaixaHelper) iterator.next();

				consulta += " drrs_qtdiasvencidos between "
						+ faixaHelper.getValorInicial() + " and "
						+ faixaHelper.getValorFinal() + " or ";

			}
			consulta = Util.removerUltimosCaracteres(consulta, 3);
			consulta += ")";
			// FIM INCLUSÃO DAS FAIXAS

			// AGRUPAMENTO POR TIPO DE TOTALIZAÇÃO
			String orderBy = " order by";
			String groupBy = " group by";

			if (tipoTotalizacao.equals("LOCALIDADE")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,dar.uneg_id,un.uneg_nmunidadenegocio,dar.loca_id,loc.loca_nmlocalidade,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,dar.uneg_id,dar.loca_id,drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id   ";
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,dar.uneg_id,un.uneg_nmunidadenegocio,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,dar.uneg_id,drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			} else if (tipoTotalizacao.equals("GERENCIA")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,drrs_icsituacaodocumentos ,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			} else if (tipoTotalizacao.equals("ESTADO")) {
				groupBy += " drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			}
			// FIM DO AGRUPAMENTO

			consulta = consulta + groupBy + orderBy;

			if (tipoTotalizacao.equals("LOCALIDADE")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idGer", Hibernate.INTEGER)
						.addScalar("dsGer", Hibernate.STRING)
						.addScalar("idUn", Hibernate.INTEGER)
						.addScalar("dsUn", Hibernate.STRING)
						.addScalar("idLoca", Hibernate.INTEGER)
						.addScalar("dsLoca", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idGer", Hibernate.INTEGER)
						.addScalar("dsGer", Hibernate.STRING)
						.addScalar("idUn", Hibernate.INTEGER)
						.addScalar("dsUn", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			} else if (tipoTotalizacao.equals("GERENCIA")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idGer", Hibernate.INTEGER)
						.addScalar("dsGer", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			} else if (tipoTotalizacao.equals("ESTADO")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			}

			// ITERA OS PARAMETROS E COLOCA
			// OS MESMOS NA QUERY
			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			// REALIZA A PESQUISA
			retorno = query.setFirstResult(quantidadeInicio)
					.setMaxResults(quantidadeMaxima).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC990] Count Relatório de Documentos a Receber
	 * 
	 * @author Hugo Amorim
	 * @date 22/02/2010
	 * 
	 */
	public Integer countRelatorioDocumentosAReceber(
			FiltroRelatorioDocumentosAReceberHelper helper)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		Query query = null;

		Map parameters = new HashMap();

		try {

			consulta += " SELECT "
					+ " count(*) as contador "
					+ " FROM financeiro.docs_a_rec_resumo dar "
					+ " INNER JOIN cobranca.documento_tipo dt on dt.dotp_id = dar.dotp_id "
					+ " INNER JOIN cadastro.categoria cat on cat.catg_id = dar.catg_id "
					+ " LEFT JOIN cadastro.categoria_tipo catTipo on catTipo.cgtp_id = cat.cgtp_id "
					+ " INNER JOIN cadastro.gerencia_regional gr on gr.greg_id = dar.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio un on un.uneg_id = dar.uneg_id "
					+ " INNER JOIN cadastro.localidade loc on loc.loca_id = dar.loca_id "
					+ " WHERE drrs_amreferenciarecebimentos = :anoMes and ";

			parameters.put("anoMes", helper.getMesAno());

			if (helper.getIdCategoriaTipo() != null
					&& !helper.getIdCategoriaTipo().equals("-1")) {
				consulta += " catTipo.cgtp_id in(:idCategoriaTipo) and ";
				parameters.put("idCategoriaTipo", helper.getIdCategoriaTipo());

			}

			if (helper.getIdsCategoria() != null
					&& helper.getIdsCategoria().length != 0) {

				Collection idsCategorias = new ArrayList();
				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					String idCategoria = helper.getIdsCategoria()[i];
					if (!idCategoria.equals("-1")) {
						idsCategorias.add(new Integer(idCategoria));
					}
				}
				if (idsCategorias.size() > 0) {
					consulta += " dar.catg_id in(:idsCategorias) and ";
					parameters.put("idsCategorias", idsCategorias);
				}
			}

			if (helper.getIdsPerfilImovel() != null
					&& helper.getIdsPerfilImovel().length != 0) {

				Collection idsPerfis = new ArrayList();
				for (int i = 0; i < helper.getIdsPerfilImovel().length; i++) {
					String idPerfil = helper.getIdsPerfilImovel()[i];
					if (!idPerfil.equals("-1")) {
						idsPerfis.add(new Integer(idPerfil));
					}
				}
				if (idsPerfis.size() > 0) {
					consulta += " dar.iper_id in(:idsPerfis) and ";
					parameters.put("idsPerfis", idsPerfis);
				}
			}

			if (helper.getIdsEsferaPoder() != null
					&& helper.getIdsEsferaPoder().length != 0) {

				Collection idsEsferas = new ArrayList();
				for (int i = 0; i < helper.getIdsEsferaPoder().length; i++) {
					String idsEsfera = helper.getIdsEsferaPoder()[i];
					if (!idsEsfera.equals("-1")) {
						idsEsferas.add(new Integer(idsEsfera));
					}
				}
				if (idsEsferas.size() > 0) {
					consulta += " dar.epod_id in(:idsEsferas) and ";
					parameters.put("idsEsferas", idsEsferas);
				}
			}

			if (helper.getIdGerencia() != null
					&& !helper.getIdGerencia().equals("-1")) {
				consulta += " dar.greg_id = :idGerencia and ";
				parameters.put("idGerencia", helper.getIdGerencia());
			}
			if (helper.getIdUnidade() != null
					&& !helper.getIdUnidade().equals("-1")) {
				consulta += " dar.uneg_id = :idUnidade and ";
				parameters.put("idUnidade", helper.getIdUnidade());
			}
			if (helper.getIdLocalidade() != null
					&& !helper.getIdLocalidade().equals("")) {
				consulta += " dar.loca_id = :idLocalidade and ";
				parameters.put("idLocalidade", helper.getIdLocalidade());
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			// INCLUI FAIXAS
			consulta += " and (drrs_qtdiasvencidos = 0 or ";
			for (Iterator iterator = helper.getColecaoFaixas().iterator(); iterator
					.hasNext();) {
				FaixaHelper faixaHelper = (FaixaHelper) iterator.next();

				consulta += " drrs_qtdiasvencidos between "
						+ faixaHelper.getValorInicial() + " and "
						+ faixaHelper.getValorFinal() + " or ";

			}
			consulta = Util.removerUltimosCaracteres(consulta, 3);
			consulta += ")";
			// FIM INCLUSÃO DAS FAIXAS

			query = session.createSQLQuery(consulta).addScalar("contador",
					Hibernate.INTEGER);

			// ITERA OS PARAMETROS E COLOCA
			// OS MESMOS NA QUERY
			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			// REALIZA A PESQUISA
			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// ////////////////////////////////////////////////////////////////////
	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarQuantidadeCobrancaDocumento(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ? + (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumento);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(3, Util.getSQLTimesTemp(new Date()));
			st.setInt(4, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();
			session.flush();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSomar(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ? + (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_qtcobrancadocumentoitem = ? + (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_vltotaldoccob = ? + (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumento);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setInt(3, quantidadeCobrancaDocumentoItem);
			st.setInt(4, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(5, valorTotalCobrancaDocumento);
			st.setInt(6, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(7, Util.getSQLTimesTemp(new Date()));
			st.setInt(8, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public Integer pesquisarQuantidadeCobrancaDocumento(
			Integer idCobrancaDocumentoControleGeracao)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {

			String hql = " select cdcg.quantidadeCobrancaDocumento "
					+ " from gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao cdcg "
					+ " where cdcg.id = :idCobrancaDocumentoControleGeracao ";

			retorno = (Integer) session
					.createQuery(hql)
					.setInteger("idCobrancaDocumentoControleGeracao",
							idCobrancaDocumentoControleGeracao).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSomar(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumentoitem = ? + (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_vltotaldoccob = ? + (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumentoItem);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(3, valorTotalCobrancaDocumento);
			st.setInt(4, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(5, Util.getSQLTimesTemp(new Date()));
			st.setInt(6, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public CobrancaDocumentoControleGeracao pesquisarCobrancaDocumentoControleGeracao(
			Integer idCobrancaDocumentoControleGeracao)
			throws ErroRepositorioException {

		CobrancaDocumentoControleGeracao retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String hql = " select cdcg "
					+ " from gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao cdcg "
					+ " where cdcg.id = :idCobrancaDocumentoControleGeracao ";

			retorno = (CobrancaDocumentoControleGeracao) session
					.createQuery(hql)
					.setInteger("idCobrancaDocumentoControleGeracao",
							idCobrancaDocumentoControleGeracao).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 19/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSubtrair(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_qtcobrancadocumentoitem = (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_vltotaldoccob = (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, idCobrancaDocumentoControleGeracao);
			st.setInt(2, quantidadeCobrancaDocumento);
			st.setInt(3, idCobrancaDocumentoControleGeracao);
			st.setInt(4, quantidadeCobrancaDocumentoItem);
			st.setInt(5, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(6, valorTotalCobrancaDocumento);
			st.setTimestamp(7, Util.getSQLTimesTemp(new Date()));
			st.setInt(8, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 19/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracao(
			Integer quantidadeCobrancaDocumento,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento,
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ?,"
					+ " cdcg_qtcobrancadocumentoitem = ?,"
					+ " cdcg_vltotaldoccob = ?,"
					+ " cdcg_tmultimaalteracao =  ?" + " where ";

			if (idCobrancaAcaoAtividadeComando != null) {
				consulta = consulta + " cacm_id = ? ";

				st = jdbcCon.prepareStatement(consulta);
				st.setInt(1, quantidadeCobrancaDocumento);
				st.setInt(2, quantidadeCobrancaDocumentoItem);
				st.setBigDecimal(3, valorTotalCobrancaDocumento);
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, idCobrancaAcaoAtividadeComando);

			} else if (idCobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta + " caac_id = ? ";

				st = jdbcCon.prepareStatement(consulta);
				st.setInt(1, quantidadeCobrancaDocumento);
				st.setInt(2, quantidadeCobrancaDocumentoItem);
				st.setBigDecimal(3, valorTotalCobrancaDocumento);
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, idCobrancaAcaoAtividadeCronograma);
			}

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Vivianne Sousa
	 * @date 29/04/2010
	 */
	public Collection pesquisarImovelCobrancaSituacaoPorImovel(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		Session session = HibernateUtil.getSession();

		try {
			String hql = " select ics"
					+ " from gcom.cadastro.imovel.ImovelCobrancaSituacao ics"
					+ " inner join fetch ics.cobrancaSituacao as cbst "
					+ " where ics.imovel.id = :idImovel "
					+ " and ics.dataRetiradaCobranca is null "
					+ " order by ics.dataImplantacaoCobranca desc ";

			retorno = (List) session.createQuery(hql)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 03/05/2010
	 */
	public Collection pesquisarDadosImovelCobrancaSituacaoPorImovel(
			Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String hql = " select cbst.descricao, ics.anoMesReferenciaInicio, "
					+ " ics.anoMesReferenciaFinal, ics.dataImplantacaoCobranca, "
					+ " ics.dataRetiradaCobranca , ics.cliente.id  "
					+ " ,escritorio.nome, advogado.nome "
					+ " from gcom.cadastro.imovel.ImovelCobrancaSituacao ics"
					+ " inner join ics.cobrancaSituacao as cbst "
					+ " left join ics.escritorio as escritorio "
					+ " left join ics.advogado as advogado "
					+ " where ics.imovel.id = :idImovel "
					+ " order by ics.dataImplantacaoCobranca desc ";

			retorno = session.createQuery(hql).setInteger("idImovel", idImovel)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Atualiza valores do Documento de Cobrança de cartas.
	 * 
	 * @author Hugo Amorim
	 * @data 29/04/2010
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarValoresDocumentoCobrancaCartas(Integer id,
			BigDecimal descontoTotalPagamentoAVista,
			BigDecimal valorTotalImpostosConta) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update cobranca.cobranca_documento set "
					+ " cbdo_vldocumento = ? ," + " cbdo_vldesconto = ? ,"
					+ " cbdo_tmultimaalteracao =  " + new Date()
					+ " where cbdo_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setBigDecimal(1, descontoTotalPagamentoAVista);
			st.setBigDecimal(2, valorTotalImpostosConta);
			st.setInt(3, id);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC????] Relatorio Comando Documento Cobranca Retorna a ação de cobrança
	 * para exibição de parametros do relatório
	 * 
	 * @author Anderson Italo
	 * @data 04/05/2010
	 */
	public CobrancaAcao pesquisarAcaoCobrancaParaRelatorio(
			Integer cobrancaAcaoAtividadeComando,
			Integer cobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		CobrancaAcao retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento.cobrancaAcao "
					+ "FROM CobrancaDocumento cobrancaDocumento ";

			if (cobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id =  "
						+ cobrancaAcaoAtividadeCronograma + " ";
			} else if (cobrancaAcaoAtividadeComando != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeComando.id = "
						+ cobrancaAcaoAtividadeComando + " ";
			}

			retorno = (CobrancaAcao) session.createQuery(consulta)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Parcelamentos por Entrada Não Paga Author: Arthur Carvalho
	 * Paiva Data: 17/05/2010
	 * 
	 * Obtem os parcelamentos de débitos efetuados que estejam com situação
	 * normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarTodosParcelamentosSituacaoNormal(
			String parcelamentoSituacao) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct parc.id, parc.parcelamento, imov.id  "
					+ "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "WHERE parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND parc.cobrancaForma = :cobrancaEmConta "
					+ "AND (parc.valorEntrada IS NOT NULL AND parc.valorEntrada > 0) "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("parcelamentoSituacao",
							new Integer(parcelamentoSituacao))
					.setInteger("cobrancaEmConta",
							CobrancaForma.COBRANCA_EM_CONTA)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0998] Gerar Relação de Parcelamento - Visão Cartão de Crédito
	 * 
	 * Bean que preencherá o relatorio
	 * 
	 * @author Hugo Amorim
	 * @date 11/06/2010
	 * 
	 */
	public Collection<Object[]> filtrarRelacaoParcelamentoCartaoCredito(
			FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		SQLQuery query = null;
		String consulta = null;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados()
						.isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( loca.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id, \n  muni.muni_nmmunicipio ";
			orderBy += " muni.muni_nmmunicipio, ";
		}

		try {

			consulta = "select "
					+ " distinct \n"
					+ " parc.parc_id, \n"
					+ " loca.loca_id, \n"
					+ " loca.loca_nmlocalidade, \n"
					+ " geRe.greg_id, \n"
					+ " geRe.greg_nmregional, \n"
					+ " clie.clie_nmcliente, \n"
					+ " parc.imov_id, \n"
					+ " parc.parc_nnprestacoes * parc.parc_vlprestacao as debitoParcelado, \n"
					+ " parc.parc_vlprestacao as valorParcela, \n"
					+ " parc.parc_tmultimaalteracao as dataParcelamento, \n"
					+ " parc.parc_nnprestacoes as qtdParcelas, \n"
					+ " ar.clie_id as clienteArrecadador, \n"
					+ " u.usur_nmusuario as nomeUsuarioConfirmacao, \n"
					+ " pcc.pacc_dtconfirmacao as dtConfirmacao, \n"
					+ " pacc_dtconfirmadooperadora as dtConfirmadooperadora, \n"
					+ " pacc_vlconfirmadooperadora as valorConfirmado \n"
					+ selectMunicipio
					+ " from \n"
					+ "     cobranca.parcelamento parc \n"
					+ "     inner join cadastro.localidade loca on ( loca.loca_id = parc.loca_id ) \n"
					+ joinMunicipio
					+ "     inner join cadastro.gerencia_regional geRe on ( geRe.greg_id = loca.greg_id ) \n"
					+ "     inner join cadastro.unidade_negocio unNe on ( loca.uneg_id = unNe.uneg_id ) \n"
					+ "     inner join cadastro.cliente clie on ( clie.clie_id = parc.clie_id ) \n"
					+ "     inner join cadastro.imovel imo on ( imo.imov_id = parc.imov_id ) \n"
					+ "     inner join cadastro.quadra qua on ( qua.qdra_id = imo.qdra_id ) \n"
					+ "     inner join cobranca.parcel_pagto_cartao_cred pcc on (pcc.parc_id = parc.parc_id) \n"
					+ "     inner join arrecadacao.arrecadador ar on (ar.arrc_id  = pcc.arrc_id) \n"
					+ "     inner join seguranca.usuario u on (u.usur_id = pcc.usur_idconfirmacao) \n"
					+ "     left join cadastro.unidade_organizacional unid ON u.unid_id = unid.unid_id \n"
					+ " where \n" + "  parc.pcst_id = :parcelamentoSituacao";

			// Verificamos quais os filtros informados
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				consulta += " and geRe.greg_id = :idGerenciaRegional \n";
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				consulta += " and unNe.uneg_id = :idUnidadeNegocio \n";
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				consulta += " and loca.loca_cdelo = :idElo \n";
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and parc.loca_id = :idLocalidade ";
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and loca.muni_idprincipal IN ( :idMunicipios )";
				if (!temLocalidade) {
					consulta += " and parc.loca_id = loca.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				consulta += " and parc.parc_cdsetorcomercial = :cdSetorComercial \n";
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and qua.qdra_nnquadra = :numeroQuadra \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				consulta += " and parc.usur_id = :idUsuario \n";
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				consulta += " and parc.parc_tmparcelamento between :dataInicial and :dataFinal \n";
			}

			if (filtrarRelacaoParcelamento.getAnoMesReferenciaContabil() != null) {

				consulta += " and parc.parc_amreferenciafaturamento = :anoMesReferenciaContabil ";

			}

			if (filtrarRelacaoParcelamento.getPeriodoContabil() != null) {

				consulta += " and parc.parc_amreferenciafaturamento like :periodoContabil";
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoFinal().equals(""))) {
				consulta += " and pcc.pacc_dtconfirmacao between :dataConfirmacaoIncial and :dataConfirmacaoFinal \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioConfirmacao() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioConfirmacao()
							.equals("")) {
				consulta += " and pcc.usur_idconfirmacao = :idUsuarioConfirmacao \n";
			}

			if (filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora() != null
					&& !filtrarRelacaoParcelamento
							.getIndicadorConfirmacaoOperadora().equals("")) {
				consulta += " and pcc.pacc_icconfirmadooperadora = :indicadorConfirmacaoOperadora \n";
			}

			if ((filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial().equals(""))
					&& (filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal().equals(""))) {
				consulta += " and pcc.pacc_dtconfirmadooperadora between :dataConfirmacaoOperadoraIncial and :dataConfirmacaoOperadoraFinal \n";
			}

			// Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional \n";

			}

			consulta += orderBy + "  loca_id, \n" + "  greg_id, \n"
					+ "  pcc.pacc_dtconfirmacao, \n" + "  clie_nmcliente \n";

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
					.getColecaoMunicipiosAssociados())) {
				query = session.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.STRING)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.STRING)
						.addScalar("clienteArrecadador", Hibernate.INTEGER)
						.addScalar("nomeUsuarioConfirmacao", Hibernate.STRING)
						.addScalar("dtConfirmacao", Hibernate.DATE)
						.addScalar("dtConfirmadooperadora", Hibernate.DATE)
						.addScalar("valorConfirmado", Hibernate.BIG_DECIMAL)
						.addScalar("muni_id", Hibernate.INTEGER)
						.addScalar("muni_nmmunicipio", Hibernate.STRING);
			} else {
				query = session.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.STRING)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.STRING)
						.addScalar("clienteArrecadador", Hibernate.INTEGER)
						.addScalar("nomeUsuarioConfirmacao", Hibernate.STRING)
						.addScalar("dtConfirmacao", Hibernate.DATE)
						.addScalar("dtConfirmadooperadora", Hibernate.DATE)
						.addScalar("valorConfirmado", Hibernate.BIG_DECIMAL);
			}
			query.setInteger("parcelamentoSituacao",
					ParcelamentoSituacao.NORMAL);

			// Adicionamos os parametros necessários
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				query.setInteger("idGerenciaRegional",
						filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				query.setInteger("idUnidadeNegocio",
						filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				query.setInteger("idLocalidade", filtrarRelacaoParcelamento
						.getParcelamento().getLocalidade().getId());
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				query.setParameterList("idMunicipios",
						filtrarRelacaoParcelamento
								.getColecaoMunicipiosAssociados());
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				query.setInteger("cdSetorComercial", filtrarRelacaoParcelamento
						.getParcelamento().getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				query.setInteger("numeroQuadra", filtrarRelacaoParcelamento
						.getParcelamento().getNumeroQuadra());
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				query.setTimestamp("dataInicial",
						filtrarRelacaoParcelamento.getDataParcelamentoInicial());
				query.setTimestamp("dataFinal",
						filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if (filtrarRelacaoParcelamento.getAnoMesReferenciaContabil() != null) {
				query.setInteger("anoMesReferenciaContabil",
						filtrarRelacaoParcelamento
								.getAnoMesReferenciaContabil());
			}

			if (filtrarRelacaoParcelamento.getPeriodoContabil() != null) {
				query.setString("periodoContabil",
						filtrarRelacaoParcelamento.getPeriodoContabil());
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoFinal().equals(""))) {
				query.setTimestamp("dataConfirmacaoIncial",
						filtrarRelacaoParcelamento.getDataConfirmacaoInicial());
				query.setTimestamp("dataConfirmacaoFinal",
						filtrarRelacaoParcelamento.getDataConfirmacaoFinal());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				query.setInteger("idUsuario",
						filtrarRelacaoParcelamento.getIdUsuarioResponsavel());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioConfirmacao() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioConfirmacao()
							.equals("")) {
				query.setInteger("idUsuarioConfirmacao",
						filtrarRelacaoParcelamento.getIdUsuarioConfirmacao());
			}

			if (filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora() != null
					&& !filtrarRelacaoParcelamento
							.getIndicadorConfirmacaoOperadora().equals("")) {
				query.setShort("indicadorConfirmacaoOperadora",
						filtrarRelacaoParcelamento
								.getIndicadorConfirmacaoOperadora());
			}

			if ((filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial().equals(""))
					&& (filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal().equals(""))) {
				query.setTimestamp("dataConfirmacaoOperadoraIncial",
						filtrarRelacaoParcelamento
								.getDataConfirmacaoOperadoraInicial());
				query.setTimestamp("dataConfirmacaoOperadoraFinal",
						filtrarRelacaoParcelamento
								.getDataConfirmacaoOperadoraFinal());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				query.setInteger("idUnidadeOrganizacional",
						filtrarRelacaoParcelamento.getIdUnidadeOrganizacional());
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC1038] Prescrever Débitos de Imóveis
	 * 
	 * @author Hugo Leonardo
	 * @date 07/07/2010
	 * 
	 * @param idFuncionalidadeIniciada
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void prescreverDebitosDeImoveis(Integer anoMesFaturamento,
			Integer anoMesPrescricao, Integer usuario,
			String idsCobrancaSituacao) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {

			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			// Atualiza Contas
			update = " update faturamento.conta c "
					+ " set 	dcst_idatual = 8, " + "       usur_id = "
					+ usuario.intValue()
					+ ", "
					+ " 		dcst_idanterior = NULL, "
					+ " 		cnta_dtcancelamento =  "
					+ Util.obterSQLDataAtual()
					+ " , "
					+ " 		cmcn_id = 99, "
					+ "       cnta_amreferenciacontabil = "
					+ anoMesFaturamento.intValue()
					+ ", "
					+ "       cnta_tmultimaalteracao = "
					+ Util.obterSQLDataAtual()
					+ " where c.cnta_amreferenciaconta < "
					+ anoMesPrescricao.intValue()
					+ " and   c.cnta_amreferenciacontabil < "
					+ anoMesFaturamento.intValue()
					+ " and   c.dcst_idatual in (0,1,2) "
					+ " and not exists (select cnta_id "
					+ " 				  from faturamento.conta_categoria g "
					+ " 				  where c.cnta_id=g.cnta_id "
					+ " 				  and catg_id = 4) "
					+ " and not exists (select ics.imov_id "
					+ " 				  from cadastro.imovel_cobranca_situacao ics "
					+ " 				  where c.imov_id = ics.imov_id "
					+ " 				  and iscb_dtretiradacobranca is null "
					+ " 				  and cbst_id in (" + idsCobrancaSituacao + ")) ";

			st = jdbcCon.prepareStatement(update);

			// executa o update
			st.executeUpdate();

			// erro no hibernate
		} catch (SQLException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC1038] Prescrever Débitos de Imóveis
	 * 
	 * @author Hugo Leonardo
	 * @date 07/07/2010
	 * 
	 * @param idFuncionalidadeIniciada
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection obterCobrancaSituacaoParaPrescreverDebitos()
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = " select cosi.id "
					+ " from gcom.cobranca.CobrancaSituacao cosi "
					+ " where cosi.indicadorPrescricaoImoveisParticulares = 2 ";

			retorno = (Collection) session.createQuery(consulta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC1038] Prescrever Débitos de Imóveis Pesquisa imoveis para execução do
	 * batch
	 * 
	 * @author Hugo Leonardo
	 * @date 19/07/2010
	 */
	public Collection obterContasPrescreverDebitosDeImoveis(
			Integer idLocalidade, Integer anoMesFaturamento,
			String idsCobrancaSituacao, int numeroIndice,
			int quantidadeRegistros) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = " SELECT  c.cnta_id idConta"
					+ " FROM faturamento.conta c " + " WHERE loca_id = "
					+ idLocalidade + " AND (" + anoMesFaturamento
					+ " - c.cnta_amreferenciaconta) > 1000"
					+ " AND c.cnta_amreferenciacontabil < " + anoMesFaturamento
					+ " AND dcst_idatual in ( 0,1,2 )" + " AND NOT EXISTS ( "
					+ " 	SELECT cnta_id "
					+ "  	FROM faturamento.conta_categoria g "
					+ "  	WHERE c.cnta_id = g.cnta_id " + " 	AND catg_id = 4 )"
					+ " AND NOT EXISTS ( " + "  	SELECT ics.imov_id "
					+ " 	FROM cadastro.imovel_cobranca_situacao ics "
					+ " 	WHERE c.imov_id = ics.imov_id "
					+ " 	AND iscb_dtretiradacobranca is null "
					+ " 	AND cbst_id in ( " + idsCobrancaSituacao + ") )";

			retorno = (Collection) session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0244] Manter Comando Ação de Cobrança
	 * 
	 * @author Hugo Amorim
	 * @created 14/07/2010
	 * 
	 * @exception ErroRepositorioException
	 * 
	 */
	public void removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao;

		try {
			removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao = "delete CobrancaAcaoAtividadeComandoFiscalizacaoSituacao "
					+ "where cobrancaAcaoAtividadeComando = :idComando ";

			session.createQuery(
					removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao)
					.setInteger("idComando", idComando).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Obtem os percentuais de desconto por tempo de inatividade a vista
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 20/07/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcDesctoInativVista obterPercentualDescontoInatividadeAVista(
			Integer idPerfilParc, int qtdeMeses)
			throws ErroRepositorioException {

		ParcDesctoInativVista retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pdin " + "FROM ParcDesctoInativVista pdin "
					+ "WHERE pdin.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND pdin.quantidadeMaximaMesesInatividade IN ("
					+ "SELECT max(p.quantidadeMaximaMesesInatividade)"
					+ "FROM ParcelamentoDescontoInatividade p "
					+ "WHERE p.quantidadeMaximaMesesInatividade <= :qtdeMeses)";

			retorno = (ParcDesctoInativVista) session.createQuery(consulta)
					.setInteger("idPerfilParc", idPerfilParc.intValue())
					.setInteger("qtdeMeses", qtdeMeses).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * Atualizar total de documentos, itens e valores realizados nos comandos de
	 * acao de cobranca
	 * 
	 * Data: 19/07/2010
	 * 
	 * @author Arthur Carvalho
	 * 
	 * @param idCACM
	 *            Identificador de CobrancaAcaoAtividadeComando
	 * @return Array de objetos com valores de 0 - quantidade de itens cobrados
	 *         1 - valor total dos documentos 2 - quantidade de documentos
	 */
	public Object[] calcularTotaisComandoAcaoCobranca(Integer idCACM)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object[] retorno = new Object[3];

		try {

			Date dataAtual = new Date();

			// usou-se a condicao ultimaAlteracao > xxxxxx para melhorar o tempo
			// da query
			String consulta = "SELECT count(cdi.id) FROM CobrancaDocumentoItem cdi where "
					+ "cdi.ultimaAlteracao > :dataGeracaoItem "
					+ " and cdi.cobrancaDocumento.id in "
					+ "(select cd.id from CobrancaDocumento cd where cd.cobrancaAcaoAtividadeComando.id = :idCACM) ";

			// quantidade de itens cobrados
			retorno[0] = (Integer) session
					.createQuery(consulta)
					.setInteger("idCACM", idCACM)
					.setDate("dataGeracaoItem",
							Util.subtrairNumeroDiasDeUmaData(dataAtual, 2))
					.uniqueResult();

			consulta = "SELECT sum(cd.valorDocumento) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeComando.id = :idCACM ";

			// valor total dos documentos
			retorno[1] = (BigDecimal) session.createQuery(consulta)
					.setInteger("idCACM", idCACM).uniqueResult();

			consulta = "SELECT count(cd.id) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeComando.id = :idCACM ";

			// quantidade de documentos
			retorno[2] = (Integer) session.createQuery(consulta)
					.setInteger("idCACM", idCACM).uniqueResult();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * atualiza a forma da emissão do documento de cobrança
	 * 
	 * @author Sávio Luiz
	 * @date 12/08/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarFormaEmissaoCobrancaDocumento(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String consulta = "update gcom.cobranca.CobrancaDocumento "
					+ "set demf_id = :formaEmissao , "
					+ "cbdo_tmultimaalteracao = :dataAtual "
					+ "where cbdo_id = :idCobrancaDocumento ";

			session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setInteger("formaEmissao",
							DocumentoEmissaoForma.IMPRESSAO_SIMULTANEA)
					.setDate("dataAtual", new Date()).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * Pesquisa Documentos de cobranças validos para imovel para determinado
	 * tipo de documento
	 * 
	 * @author Hugo Amorim
	 * @date 09/09/2010
	 */
	public Collection<CobrancaDocumento> pesquisarDadosCobrancaDocumentoValidoImovel(
			Integer idImovel, Integer idDocumentoTipo, Integer idAcaoCobranca)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT cd "
					+ " FROM CobrancaDocumento cd "
					+ " INNER JOIN FETCH cd.documentoTipo dt"
					+ " INNER JOIN FETCH cd.cobrancaAcao ca"
					+ " WHERE dt.id = :idDocumentoTipo AND"
					+ " cd.imovel.id = :idImovel AND"
					+ " ca.id = :idAcaoCobranca AND"
					+ " (TO_DATE (TO_CHAR (cd.emissao, 'YYYY-MON-DD HH24:MI:SS'), 'YYYY-MON-DD HH24:MI:SS') + ca.numeroDiasValidade) >= "
					+ Util.obterSQLDataAtual() + " ";

			retorno = session.createQuery(consulta)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setInteger("idImovel", idImovel)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					// .setDate("dataAtual", Util.obterSQLDataAtual())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0478] Gerar Resumo das Ações de Cobrança do Cronograma
	 * 
	 * Data: 16/09/2010
	 * 
	 * @author Vivianne Sousa
	 */
	public Integer pesquisarCobrancaDocumentoFisc(
			Integer idFiscalizacaoSituacao, Integer idOrdemServico,
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cdfz.id "
					+ "from CobrancaDocumentoFisc cdfz "
					+ "where "
					+ " cdfz.fiscalizacaoSituacao.id = :idFiscalizacaoSituacao "
					+ " and cdfz.ordemServico.id = :idOrdemServico "
					+ " and cdfz.cobrancaDocumento.id = :idCobrancaDocumento ";

			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("idFiscalizacaoSituacao",
							idFiscalizacaoSituacao)
					.setInteger("idOrdemServico", idOrdemServico)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0852] - Incluir Débito a Cobrar de Entrada de Parcelamento Não Paga
	 * 
	 * --- --- Pesquisa a guia de pagamento do parcelamento --- ---
	 * 
	 * @author Arthur Carvalho
	 * @date 22/09/2010
	 * @param parcelamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoDoParcelamentoPorEntradaNaoPaga(
			String parcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT gpag.id, gpag.dataVencimento  "
					+ "FROM GuiaPagamento gpag "
					+ "WHERE gpag.parcelamento = :parcelamento "
					+ "and gpag.debitoCreditoSituacaoAtual in (0,1,2) ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", new Integer(parcelamento))
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Pesquisa por todos os impostos a partir de uma fatura de um cliente
	 * responsavel federal e/ou de um imovel.
	 * 
	 * A fatura é obrigatória.
	 * 
	 * OBS: O id da fatura passado tem que ser de uma fatura de um cliente
	 * responsavel federal
	 * 
	 * @author Fernando Fontelles, Mariana Victor
	 * @date 24/09/2010, 24/02/2011
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaImpostoFaturaClienteResponsavelFederalAnalitico(
			Integer anoMesInicial, Integer anoMesFinal, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		// Pesquisa pela fatura se o período é referente a um mês
		boolean fatura = anoMesInicial.equals(anoMesFinal);
		
		try {
			Query query = null;

			consulta = "SELECT imtp.imtp_id          AS impostoTipo,  "    
					+ " imtp.imtp_dsimposto          AS descricaoImposto, "       
					+ " cnid.cnid_pcaliquota         AS percAliquota, "  
					+ " Sum(cnid.cnid_vlimposto)     AS valorImposto, "       
					+ " clie.clie_id                 AS cliente, "       
					+ " clie_nmcliente               AS nomeCliente, "       
					+ " Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto  + cnta.cnta_vldebitos ) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos) )) AS valorFatura,"        
					+ " cnta.imov_id                 AS imovel, "       
					+ " clie.clie_nncnpj             AS cnpj, "       
					+ " Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto  + cnta.cnta_vldebitos ) - ( cnta.cnta_vlcreditos ) )) AS baseCalculo ";

			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id					AS idFatura";
			} else {
				consulta = consulta 
					+ " ,null							AS idFatura";
			}

			consulta = consulta
					+ " FROM   faturamento.conta_impostos_deduzidos cnid "       
					+ " INNER JOIN faturamento.conta cnta               ON ( cnid.cnta_id = cnta.cnta_id )"        
					+ " INNER JOIN cadastro.cliente_conta clct          ON ( cnta.cnta_id = clct.cnta_id AND clct.crtp_id = :cliRelacaoTipo )"        
					+ " INNER JOIN cadastro.cliente clie                ON ( clct.clie_id = clie.clie_id )"        
					+ " INNER JOIN cadastro.cliente_tipo cltp           ON ( clie.cltp_id = cltp.cltp_id )"        
					+ " INNER JOIN faturamento.imposto_tipo imtp        ON ( cnid.imtp_id = imtp.imtp_id )" ;
			if (fatura) {
				consulta = consulta 
					+ " LEFT JOIN faturamento.fatura fatu				ON ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnta.cnta_amreferenciaconta)";
			}
			consulta = consulta
					+ " WHERE   "
					+ " cnta.cnta_id IN (SELECT idconta FROM"   
					+ " 			(SELECT imovel, referencia, Max(cnta_id) AS idconta  FROM"   
					+ " 				(SELECT conta.imov_id   AS imovel,conta.cnta_amreferenciaconta AS referencia, conta.cnta_id FROM  faturamento.conta conta"  
					+ " 				        WHERE  conta.cnta_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal "            
					+ " 				 UNION ALL            "
					+ " 				 SELECT contaHist.imov_id AS imovel,contaHist.cnhi_amreferenciaconta AS referencia,contaHist.cnta_id FROM   faturamento.conta_historico contaHist" 
					+ " 				        WHERE  contaHist.cnhi_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal) a    GROUP  BY imovel, "
					+ " 		         referencia)" 
					+ " 	         b)";
			if (idCliente != null) {
				consulta = consulta
					+ " AND clct.clie_id = " + idCliente;
			}

			consulta = consulta 
					+ "GROUP  BY clie.clie_id,clie_nmcliente,cnta.imov_id,imtp.imtp_id,imtp.imtp_dsimposto, cnid.cnid_pcaliquota,clie.clie_nncnpj ";
			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id ";
			}

			consulta = consulta
					+ " UNION ALL" 
					+ " SELECT imtp.imtp_id          AS impostoTipo,"        
					+ " imtp.imtp_dsimposto          AS descricaoImposto,"        
					+ " cidh.cidh_pcaliquota         AS percAliquota,"        
					+ " Sum(cidh.cidh_vlimposto)     AS valorImposto,"        
					+ " clie.clie_id                 AS cliente,"        
					+ " clie_nmcliente               AS nomeCliente,"        
					+ " Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos ) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos) ))  AS valorFatura,"        
					+ " cnhi.imov_id                 AS imovel,"        
					+ " clie.clie_nncnpj             AS cnpj,"        
					+ " Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos ) - ( cnhi.cnhi_vlcreditos ) ))AS baseCalculo ";

			if (fatura) {
				consulta = consulta 
					+ " ,fatu.fatu_id					AS idFatura";
			} else {
				consulta = consulta 
					+ " ,null							AS idFatura";
			}

			consulta = consulta
					+ " FROM   faturamento.conta_impostos_dedz_hist cidh"        
					+ " INNER JOIN faturamento.conta_historico cnhi        ON ( cidh.cnta_id = cnhi.cnta_id )"        
					+ " INNER JOIN cadastro.cliente_conta_historico clch   ON ( cnhi.cnta_id = clch.cnta_id AND clch.crtp_id = :cliRelacaoTipo )"        
					+ " INNER JOIN cadastro.cliente clie                   ON ( clch.clie_id = clie.clie_id )"        
					+ " INNER JOIN cadastro.cliente_tipo cltp              ON ( clie.cltp_id = cltp.cltp_id )"        
					+ " INNER JOIN faturamento.imposto_tipo imtp           ON ( cidh.imtp_id = imtp.imtp_id )" ;
			if (fatura) {
				consulta = consulta 
					+ " LEFT JOIN faturamento.fatura fatu		   		   ON ( fatu.clie_id = clie.clie_id AND fatu.fatu_amreferencia = cnhi.cnhi_amreferenciaconta)";
			}
			consulta = consulta
					+ " WHERE"   
					+ " cnhi.cnta_id IN (SELECT idconta FROM"   
					+ " 			(SELECT imovel, referencia, Max(cnta_id) AS idconta FROM"   
					+ " 				(SELECT conta.imov_id AS imovel, conta.cnta_amreferenciaconta AS referencia,conta.cnta_id FROM faturamento.conta conta"
					+ " 				        WHERE  conta.cnta_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal "            
					+ " 				 UNION ALL"            
					+ " 				 SELECT contaHist.imov_id AS imovel, contaHist.cnhi_amreferenciaconta AS referencia, contaHist.cnta_id FROM faturamento.conta_historico contaHist"  
					+ " 				        WHERE  contaHist.cnhi_amreferenciaconta BETWEEN :anoMesReferenciaInicial AND :anoMesReferenciaFinal) a    GROUP  BY imovel,"
					+ " 	                referencia)" 
					+ " 	         b)" ;
			if (idCliente != null) {
				consulta = consulta
					+ " AND clch.clie_id = " + idCliente;
			}

			consulta = consulta 
					+ " GROUP  BY clie.clie_id,clie_nmcliente,cnhi.imov_id,imtp.imtp_id,imtp.imtp_dsimposto,cidh.cidh_pcaliquota,clie.clie_nncnpj ";
			if (fatura) {
				consulta = consulta 
					+ "  ,fatu.fatu_id ";
			}

			consulta = consulta
					+ " ORDER BY cliente,imovel,impostotipo ";

			query = session
					.createSQLQuery(consulta)
					.addScalar("impostoTipo", Hibernate.INTEGER)
					.addScalar("descricaoImposto", Hibernate.STRING)
					.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
					.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
					.addScalar("cliente", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("baseCalculo", Hibernate.BIG_DECIMAL)
					.addScalar("idFatura", Hibernate.INTEGER)
					.setShort("cliRelacaoTipo", ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("anoMesReferenciaInicial", anoMesInicial)
					.setInteger("anoMesReferenciaFinal", anoMesFinal);

			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC676] Consultar Resumo Negativação
	 * 
	 * @author Ivan Sergio
	 * @date 14/01/2011
	 * 
	 * @param dadosConsultaNegativacaoHelper
	 * @param idSituacaoDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarNegativacaoLigacaoAguaPorSituacaoDebito(
			DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper,
			int idSituacaoDebito) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (last.id, last.descricao, "
					+ " sum(re.quantidadeInclusoes),sum(coalesce(re.valorDebito,0)), sum(coalesce(re.valorPendente,0)), "
					+ " sum(coalesce(re.valorPago,0)), sum(coalesce(re.valorParcelado,0)), sum(coalesce(re.valorCancelado,0))) "
					+ " from ResumoNegativacao re "
					+ " inner join re.negativador neg "
					+ " left outer join re.ligacaoAguaSituacao last "
					+ " where re.cobrancaDebitoSituacao.id = :idSituacaoDebito "
					+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
					+ " group by last.id, last.descricao "
					+ " order by last.id, last.descricao ";

			retorno = session.createQuery(consulta)
					.setInteger("idSituacaoDebito", idSituacaoDebito).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Serviço da Ação de Cobrança
	 * 
	 * @author Mariana Victor
	 * @created 02/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Integer> pesquisarOrdemServicoParaEncerrar(
			Integer idCobrancaAcaoCronograma) throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Integer> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caac.caac_id AS ativCronograma "
					+ "   FROM cobranca.cobranca_acao_ativ_crg caac "
					+ " WHERE caac.cbcr_id = :idCobrancaAcaoCronograma "
					+ " GROUP BY caac.caac_id " + " ORDER BY caac.caac_id ";

			// executa o hql
			Query query = session
					.createSQLQuery(consulta)
					.addScalar("ativCronograma", Hibernate.INTEGER)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma);
			retorno = (Collection<Integer>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Serviço da Ação de Cobrança
	 * 
	 * @author Mariana Victor
	 * @created 10/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarAtivCronogOrdemServicoParaEncerrar(
			Integer idAtividadeCronograma) throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caatcr.caac_id AS ativCronograma, caatcr.caac_tmcomando AS comando, "
					+ " caatcr.caac_dtprevista AS dataPrevista, os.orse_id AS ordemServico, cbat_id as idCobrancaAtividade "
					+ " FROM atendimentopublico.ordem_servico os "
					+ " INNER JOIN cobranca.cobranca_documento cd ON os.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao ca ON cd.cbac_id = ca.cbac_id "
					+ " INNER JOIN cobranca.cobranca_acao_ativ_crg caatcr ON caatcr.caac_id = cd.caac_id AND caatcr.caac_id = :idAtividadeCronograma"
					+ " WHERE os.orse_cdsituacao = 1 ";

			// executa o hql
			Query query = session.createSQLQuery(consulta)
					.addScalar("ativCronograma", Hibernate.INTEGER)
					.addScalar("comando", Hibernate.TIMESTAMP)
					.addScalar("dataPrevista", Hibernate.DATE)
					.addScalar("ordemServico", Hibernate.INTEGER)
					.addScalar("idCobrancaAtividade", Hibernate.INTEGER)
					.setInteger("idAtividadeCronograma", idAtividadeCronograma);
			retorno = (Collection) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Serviço da Ação de Cobrança
	 * 
	 * @author Mariana Victor
	 * @created 07/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarAtividadeCronograma(
			Integer idCobrancaAcao) throws ErroRepositorioException {
		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caatcr.caac_id AS atividadeCronograma "
					+ " FROM atendimentopublico.ordem_servico os "
					+ " INNER JOIN cobranca.cobranca_documento cd ON os.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao ca ON cd.cbac_id = ca.cbac_id AND ca.cbac_id = :idCobrancaAcao "
					+ " INNER JOIN cobranca.cobranca_acao_atividade_cronog caatcr ON caatcr.caac_id = cd.caac_id "
					+ " WHERE os.orse_cdsituacao = 1 "
					+ " GROUP BY caatcr.caac_id ";

			// executa o hql
			Query query = session.createSQLQuery(consulta)
					.addScalar("atividadeCronograma", Hibernate.INTEGER)
					.setInteger("idCobrancaAcao", idCobrancaAcao);
			retorno = (Collection) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	public Collection<Object[]> pesquisarLocalidade(int idOrdemServico)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select imv.loca_id AS idLocalidade "
					+ " from atendimentopublico.ordem_servico os "
					+ " INNER JOIN cadastro.imovel imv ON os.imov_id = imv.imov_id "
					+ " WHERE os.orse_id = :idOrdemServico ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idOrdemServico", idOrdemServico).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa / Diogo Luiz
	 * @created 22/12/2010 / 30/09/2014
	 **/
	public Collection pesquisarIdDocumentoCobrancaParaImovel(Integer idImovel,
			Integer idDocumentoTipo, CobrancaAcao acaoCobranca)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		if (acaoCobranca.getNumeroDiasMinimoCobranca() == null) {
			acaoCobranca.setNumeroDiasMinimoCobranca(new Integer("0"));
		}

		if (acaoCobranca.getNumeroDiasMaximoCobranca() == null) {
			acaoCobranca.setNumeroDiasMaximoCobranca(new Integer("360"));
		}

		Date dataLimiteMinimo = Util.subtrairNumeroDiasDeUmaData(new Date(),
				acaoCobranca.getNumeroDiasMaximoCobranca());
		Date dataLimiteMaximo = Util.subtrairNumeroDiasDeUmaData(new Date(),
				acaoCobranca.getNumeroDiasMinimoCobranca());

		try {
			consulta = "select cbdo.id "
					+ " from CobrancaDocumento cbdo "
					+ " where cbdo.imovel.id = :idImovel "
					+ " and cbdo.documentoTipo = :idDocumentoTipo "
					+ " and cbdo.emissao between :dataLimiteMinimo and :dataLimiteMaximo "
					+ " order by cbdo.id desc ";

			retorno = session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setDate("dataLimiteMinimo",
							Util.formatarDataFinal(dataLimiteMinimo))
					.setDate("dataLimiteMaximo",
							Util.formatarDataFinal(dataLimiteMaximo)).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Integer pesquisarQtdeDocumentoCobrancaItemConta(
			Collection idsCobrancaDocumento, Collection colecaoConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(new Date(), -20);
		try {

			consulta = "select count(cdit.id) "
					+ " from CobrancaDocumentoItem cdit "
					+ " where cdit.cobrancaDocumento.id in (:idsCobrancaDocumento) "
					+ " and cdit.contaGeral.id in (:colecaoConta) "
					+ " and cdit.cobrancaDocumento.emissao <= :dataLimite";

			retorno = (Integer) session
					.createQuery(consulta)
					.setParameterList("idsCobrancaDocumento",
							idsCobrancaDocumento)
					.setParameterList("colecaoConta", colecaoConta)
					.setDate("dataLimite", Util.formatarDataFinal(dataLimite))
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0003] Gerar Atividade de
	 * Ação de Cobrança para Imóvel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Integer pesquisarQtdeDocumentoCobrancaItemDebitoACobrar(
			Collection idsCobrancaDocumento, Collection colecaoDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(new Date(), -30);
		try {

			consulta = "select count(cdit.id) "
					+ " from CobrancaDocumentoItem cdit "
					+ " where cdit.cobrancaDocumento.id in (:idsCobrancaDocumento) "
					+ " and cdit.debitoACobrarGeral.id in (:colecaoDebitoACobrar) "
					+ " and cdit.cobrancaDocumento.emissao <= :dataLimite";

			retorno = (Integer) session
					.createQuery(consulta)
					.setParameterList("idsCobrancaDocumento",
							idsCobrancaDocumento)
					.setParameterList("colecaoDebitoACobrar",
							colecaoDebitoACobrar)
					.setDate("dataLimite", Util.formatarDataFinal(dataLimite))
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 20/01/2011
	 **/
	public Integer pesquisarQuantidadeContasDebito(Integer idCobrancaDocumento)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT count(conta) "
					+ " FROM CobrancaDocumentoItem cdit "
					+ " INNER JOIN cdit.contaGeral contaGeral "
					+ " INNER JOIN contaGeral.conta conta "
					+ " WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 20/01/2011
	 **/
	public List<String> pesquisarTipoDeCorte() throws ErroRepositorioException {

		List<String> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cotp_dscortetipo AS descricao "
					+ "FROM atendimentopublico.corte_tipo "
					+ "WHERE cotp_icform = 1 ORDER BY cotp_id ";

			retorno = (List<String>) session.createSQLQuery(consulta)
					.addScalar("descricao", Hibernate.STRING).setMaxResults(5)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 26/01/2011
	 **/
	public List<String> pesquisarOcorrenciasFiscalizacao()
			throws ErroRepositorioException {

		List<String> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT fzst_dsfiscalizacaosituacao AS descricao "
					+ " FROM atendimentopublico.fiscalizacao_situacao"
					+ " WHERE fzst_icform = 1 ORDER BY fzst_id ";

			retorno = (List<String>) session.createSQLQuery(consulta)
					.addScalar("descricao", Hibernate.STRING).setMaxResults(15)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobrança Em Lote
	 * 
	 * @author Rômulo Aurélio
	 * @created 17/02/2011
	 **/

	public void atualizarDataRealizacaoCobrancaAcaoAtivCronograma(
			Integer idCobAcaoAtivCron) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String hql = "";
		try {
			hql = "update gcom.cobranca.CobrancaAcaoAtividadeCronograma "
					+ "set realizacao = " + Util.obterSQLDataAtual()
					+ " where id = :id ";

			session.createQuery(hql).setInteger("id", idCobAcaoAtivCron)
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a guia
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteGuia(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.guiaPagamentoGeral guia "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "guia.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a débito à
	 * cobrar
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteDebitoACobrar(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.debitoACobrarGeral debitoACobrar "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "debitoACobrar.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobrança
	 * 
	 * Seleciona os itens do documento de cobrança correspondentes a credito à
	 * cobrar
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteCreditoACobrar(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.creditoARealizarGeral creditoACobrar "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "creditoACobrar.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0968] Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos do aviso de
	 * corte
	 * 
	 * @author Mariana Victor
	 * @date 17/03/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirDocumentoCobrancaImpressaoFichaCompensasao(
			Integer idCobrancaDocumento, String linhaTxt,
			String conteudoFichaCompensacao,
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer sequencialImpressao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into cobranca.cobranca_documento_impr values ("
					+ idCobrancaDocumento + "," + "'" + linhaTxt + "',"
					+ idCobrancaAcaoAtividadeComando + ","
					+ idCobrancaAcaoAtividadeCronograma + ","
					+ sequencialImpressao + "," + Util.obterSQLDataAtual()
					+ "," + "'" + conteudoFichaCompensacao + "')";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0968] Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * @author Mariana Victor
	 * @date 17/03/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDocumentoCobrancaImpressaoFichaCompensacao(
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdim.linhaTxt, cdim.conteudoFichaCompensacao "
					+ "FROM CobrancaDocumentoImpressao cdim ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeComando cacm "
						+ " WHERE  cacm.id = " + idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeCronograma caac "
						+ " WHERE  caac.id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			consulta = consulta + " order by cdim.sequencialImpressao ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 22/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarItemServicoContrato(Integer idGrupoCobranca,
			Integer idContrato) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT its.itse_cdconstantecalculo as cdConstante, "// 0
					+ "itsc.itsc_id as idItemServicoContrato, "// 1
					+ "itsc.itsc_vlitemservcontr as vlItemServicoContrato, "// 2
					+ "ces.cese_id as idContratoEmpresaServico, ";// 3
			if (idGrupoCobranca != null) {
				consulta = consulta + "cogr.cbgr_dsemail as emailResponsavel ";// 4
			} else {
				consulta = consulta + "emp.empr_dsemail as emailResponsavel ";// 4
			}
			consulta = consulta
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cadastro.empresa emp on emp.empr_id = ces.empr_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
						+ "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}

			consulta = consulta + " order by its.itse_cdconstantecalculo ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("cdConstante", Hibernate.INTEGER)
					.addScalar("idItemServicoContrato", Hibernate.INTEGER)
					.addScalar("vlItemServicoContrato", Hibernate.BIG_DECIMAL)
					.addScalar("idContratoEmpresaServico", Hibernate.INTEGER)
					.addScalar("emailResponsavel", Hibernate.STRING).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletim(Integer idGrupoCobranca,
			Integer idItemServicoContrato, Integer referencia,
			Integer idContrato) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			" SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (1,5) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and dc.cbdo_id = os.cbdo_id "
					+ "and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (1,5) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (1,5) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (1,5) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasNaoExecutadasPorBoletim(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			" SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 25 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao  and atmen.AMEN_ICVISITAREALIZADA = 1 and atmen.amen_icexecucao = 2 and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and dc.cbdo_id = os.cbdo_id "
					+ "and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 25 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.AMEN_ICVISITAREALIZADA = 1 and atmen.amen_icexecucao = 2) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasNaoExecutadasPorBoletimRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 25 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.AMEN_ICVISITAREALIZADA = 1 and atmen.amen_icexecucao = 2 and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 25 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.AMEN_ICVISITAREALIZADA = 1 and atmen.amen_icexecucao = 2) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimento(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (2,6) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (2,6) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimento3(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (4,8,10,12,14) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (4,8,10,12,14) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimento2(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (3,7,9,11,13) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (3, 7, 9, 11, 13) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorSemPavimentoSemCalcada(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 20 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_ICCALCADA = :indicadorCalcada "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 20 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_ICCALCADA = :indicadorCalcada "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", ConstantesSistema.NAO)
					.setShort("indicadorCalcada", ConstantesSistema.NAO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoAsfaltico(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 18 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 18 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("1")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoAsfalticoSemCalcada(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 23 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 2 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 23 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 2 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("1")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoAsfalticoComCalcada(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 24 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 1 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 24 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 1 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("1")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoParalelo(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 19 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 19 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("2")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoParaleloSemCalcada(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 21 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 2 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 21 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 2 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("2")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoParaleloComCalcada(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 22 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 1 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 22 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 1 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("2")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (2,6) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (2,6) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoRotaAlternativa3(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (4,8,10,12,14) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (4,8,10,12,14) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoRotaAlternativa2(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (3,7,9,11,13) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo in (3,7,9,11,13) "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorSemPavimentoSemCalcadaRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 20 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "osBo.orbo_iccalcada = :indicadorCalcada "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 20 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "osBo.orbo_iccalcada = :indicadorCalcada "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", ConstantesSistema.NAO)
					.setShort("indicadorCalcada", ConstantesSistema.NAO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoAsfalticoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 18 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 18 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("1")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoAsfalticoSemCalcadaRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 23 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 2 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 23 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento  and osBo.ORBO_ICCALCADA = 2 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("1")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoAsfalticoComCalcadaRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 24 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.ORBO_ICCALCADA = 1 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 24 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento  and osBo.ORBO_ICCALCADA = 1 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("1")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoParaleloRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 19 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 19 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("2")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoParaleloSemCalcadaRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 21 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.orbo_iccalcada = 2 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 21 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.orbo_iccalcada = 2 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("2")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Tiago Moreno
	 * @throws ControladorException
	 * @data 01/10/2014
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoParaleloComCalcadaRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 22 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.orbo_iccalcada = 1 "
					+ "and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 22 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null "
					+ "and osBo.ORBO_CDTIPOPAVIMENTO = :tipoPavimento and osBo.orbo_iccalcada = 1 "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia)
					.setInteger("tipoPavimento", new Integer("2")).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepAsfalto(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo =15 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo =15 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepAsfaltoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo =15 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo =15 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepParalalo(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 16 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 16 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepParalaloRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepparalelo as numeroRepParalelo "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 16 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepparalelo as numeroRepParalelo "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 16 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepParalelo", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepCalcada(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 17 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS,  "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 17 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null "
					+ "and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepCalcadaRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta =
			// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM CRONOGRAMA
			"SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepcalcada as numeroRepCalcada "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 17 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cbcr.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and dc.cbdo_id = os.cbdo_id and amea.amea_icgerapagamento = 1 "

					+ " UNION "

					// OBTENDO AS OSs QUE FORAM GERADAS A PARTIR DE UM RA OU
					// COMANDO EVENTUAL
					+ "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepcalcada as numeroRepCalcada "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id and its.itse_cdconstantecalculo = 17 "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id ";
			} else {
				consulta = consulta
						+ "INNER JOIN cobranca.cobranca_acao cbac on(cbac.svtp_id = itsc.svtp_id) "
						+ "INNER JOIN cobranca.cob_acao_grupo_contrato cagc on (cagc.cese_id = ces.cese_id and cagc.cbac_id = cbac.cbac_id) "
						+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cagc.cbgr_id ";
			}
			consulta = consulta
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id = :idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.cbdo_id = os.cbdo_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_cmd cmdEventual on dc.cacm_id = cmdEventual.cacm_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr ameaCmdEventual on ameaCmdEventual.amen_id = atmen.amen_id and ameaCmdEventual.cbac_id = cmdEventual.cbac_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca;
			} else {
				consulta = consulta + "WHERE ces.cese_id = " + idContrato;
			}
			consulta = consulta
					+ " and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and atmen.amen_icexecucao = 1) or (os.cbdo_id is not null and ameaCmdEventual.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepCalcada", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDesconto(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 and os.cbdo_id = dc.cbdo_id "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id = :atenMotivoEnce and im.rota_idalternativa is null "
					+ "and caac.cbcr_id not in (select cbcr_id from cobranca.bol_med_ac_pen_just)";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					// +
					// "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					// +
					// "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					// +
					// "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					// +
					// "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 and os.cbdo_id = dc.cbdo_id "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id = :atenMotivoEnce and im.rota_idalternativa is not null";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoSemDecursoPrazo(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					// +
					// "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					// +
					// "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					// +
					// "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					// +
					// "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 2 "
					+ "INNER JOIN cobranca.cob_ac_os_nao_aceitas caosnaceitas on os.orse_id = caosnaceitas.orse_id and caon_icaceita = 2 and caon_icdescontado = 2 and os.cbdo_id = dc.cbdo_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id <> :atenMotivoEnce and im.rota_idalternativa is null "
					+ "and atmen.AMEN_ICVISITAREALIZADA = 2 "
					+ "and caac.cbcr_id not in (select cbcr_id from cobranca.bol_med_ac_pen_just)";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoSemDecursoPrazoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					// +
					// "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					// +
					// "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					// +
					// "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					// +
					// "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac on cbac.svtp_id = itsc.svtp_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cbcr on cbcr.cese_id = ces.cese_id and cbac.cbac_id = cbcr.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cbcr.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on (cgcm.cbcm_id = cbcr.cbcm_id) "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cbgr_id = cgcm.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN micromedicao.item_contrato_servico_tipo icst on icst.svtp_id = os.svtp_id and icst.itsc_id = itsc.itsc_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 2 "
					+ "INNER JOIN cobranca.cob_ac_os_nao_aceitas caosnaceitas on os.orse_id = caosnaceitas.orse_id and caon_icaceita = 2 and caon_icdescontado = 2 and os.cbdo_id = dc.cbdo_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cogr.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "atmen.AMEN_ICVISITAREALIZADA = 2 and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id <> :atenMotivoEnce and im.rota_idalternativa is not null";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection<Object[]> pesquisarSituacaoAtualContaPeloCronogramaCobranca(
			Integer idGrupoCobranca, Integer referencia, Integer idContrato)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select "
					+ "cd.imov_id as idImovel, "// 0
					+ "cd.loca_id as idLocalidade, "// 1
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.dcst_idatual "
					+ " else "
					+ "   cthist.dcst_idatual"
					+ " end as situacaoAtualConta," // 2
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   pg.pgmt_vlpagamento "
					+ " else "
					+ "   pghistContaHist.pghi_vlpagamento "
					+ " end as valorPagamento, " // 3
					+ " ces.cese_pctaxasucesso as percentualTaxaSucesso, "// 4
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.cnta_amreferenciaconta "
					+ " else "
					+ "   cthist.cnhi_amreferenciaconta"
					+ " end as referenciaConta, " // 5
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.cnta_vlagua + ct.cnta_vlesgoto + ct.cnta_vldebitos - ct.cnta_vlcreditos - ct.cnta_vlimpostos "
					+ " else "
					+ "   cthist.cnhi_vlagua + cthist.cnhi_vlesgoto + cthist.cnhi_vldebitos - cthist.cnhi_vlcreditos - cthist.cnhi_vlimpostos "
					+ " end as valorConta " // 6
					+ " from cobranca.cobranca_documento_item cdi "
					+ " INNER JOIN cobranca.cobranca_documento cd on cdi.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.caac_id = cd.caac_id "
					+ " INNER join cobranca.cobranca_acao_cronograma cbcr on cbcr.cbcr_id = caac.cbcr_id "
					+ " INNER join cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbcm_id = cbcr.cbcm_id "
					+ " INNER join cobranca.cobranca_grupo cg on cg.cbgr_id = cgcm.cbgr_id "
					+ " INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = cbcr.cese_id "
					+ " INNER join atendimentopublico.ordem_servico os on os.cbdo_id = cd.cbdo_id  "
					+ " INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ " LEFT JOIN faturamento.conta ct on ct.cnta_id = cdi.cnta_id "
					+ " LEFT JOIN arrecadacao.pagamento pg on pg.cnta_id = ct.cnta_id "
					+ " LEFT JOIN faturamento.conta_historico cthist on cthist.cnta_id = cdi.cnta_id "
					+ " LEFT JOIN arrecadacao.pagamento_historico pghistContaHist on pghistContaHist.cnta_id = cthist.cnta_id ";
			if (idGrupoCobranca != null) {
				consulta = consulta + "WHERE cg.cbgr_id = " + idGrupoCobranca
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else {
				consulta = consulta
						+ "WHERE ces.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta
					+ " and cgcm.cbcm_amreferencia = :referencia and cbcr.cbac_id = :idCobrancaAcao and "
					+ " os.orse_cdsituacao = :cdSituacao "
					+ " order by cd.imov_id";

			// executa o hql
			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("situacaoAtualConta", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("percentualTaxaSucesso", Hibernate.BIG_DECIMAL)
					.addScalar("referenciaConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("referencia", referencia)
					.setInteger("idCobrancaAcao", CobrancaAcao.VISITA_COBRANCA)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public void atualizaIndicadorBoletimOS(Collection idsOS)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em débito automático a Data Exclusão com a data corrente
			atualizaDataExclusao = "update gcom.atendimentopublico.ordemservico.OrdemServico "
					+ "set orse_icboletim = 1,orse_tmultimaalteracao = :ultimaAlteracao where orse_id in(:idsOS)";

			session.createQuery(atualizaDataExclusao)
					.setParameterList("idsOS", idsOS)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public void atualizaIndicadorCobrancaAcaoOSNaoAceitas(
			Collection idsOSNaoAceitas) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em débito automático a Data Exclusão com a data corrente
			atualizaDataExclusao = "update gcom.cobranca.CobrancaAcaoOrdemServicoNaoAceitas "
					+ "set caon_icdescontado = 1,caon_tmultimaltarecao = :ultimaAlteracao where orse_id in (:idsOSNaoAceitas) and "
					+ " caac_id = :idCobrancaAcao ";

			session.createQuery(atualizaDataExclusao)
					.setParameterList("idsOSNaoAceitas", idsOSNaoAceitas)
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("idCobrancaAcao", CobrancaAcao.VISITA_COBRANCA)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1153] Solicitar Geração/Emissão Boletim de Medição de Cobrança
	 * 
	 * [FS0002] - Ações não encerradas no cronograma.
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Integer pesquisarAcoesEncerradasCronograma(Integer anoMesReferencia,
			Integer idCobrancaGrupo, Integer idContrato)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			Map parameters = new HashMap();

			consulta = " SELECT count(*) AS contador "
					+ "  FROM cobranca.cobranca_acao_ativ_crg caac "
					+ "  INNER JOIN cobranca.cobranca_acao_cronograma cbcr ON cbcr.cbcr_id = caac.cbcr_id "
					+ "  INNER JOIN cobranca.cobranca_grupo_crg_mes cbcm ON cbcm.cbcm_id = cbcr.cbcm_id "
					+ "  WHERE cbcm.cbcm_amreferencia = :anoMesReferencia "
					+ "  AND caac.caac_tmrealizacao IS NULL ";

			if (idCobrancaGrupo != null) {
				consulta = consulta
						+ " AND cbcm.cbgr_id = :idCobrancaGrupo AND cbcr.cbcr_cdtipocobranca = :tipoCobranca ";
				parameters.put("idCobrancaGrupo", idCobrancaGrupo);
				parameters.put("tipoCobranca", new Short("1"));

			} else if (idContrato != null) {
				consulta = consulta
						+ " AND cbcr.cese_id = :idContrato AND cbcr.cbcr_cdtipocobranca = :tipoCobranca  ";
				parameters.put("idContrato", idContrato);
				parameters.put("tipoCobranca", new Short("2"));
			}

			Query q = session.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.setInteger("anoMesReferencia", anoMesReferencia);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					q.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					q.setParameterList(key, collection);
				} else {
					q.setParameter(key, parameters.get(key));
				}
			}

			retorno = (Integer) q.setMaxResults(1).uniqueResult();
			;

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa os Itens de Serviço relacionados ao boletim de medição de
	 * cobrança selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimDesconto(
			Integer idBoletimMedicao, Integer idGerenciaRegional,
			Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  itse.itse_id AS idItemServico, " // 1
					+ "  itse.itse_dsitemservico AS descricao, " // 2
					+ "  itse.itse_cdconstantecalculo AS constante, " // 3
					+ "  cobm_dtgeracao AS dataGeracao, " // 4
					+ "  itse_cditem AS codigoItem, " // 5
					+ "  loca.loca_nmlocalidade AS localidade, " // 6
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 7
					+ "  loca.loca_id AS idLoca, " // 8
					+ "  greg.greg_id AS idGerencia, " // 9
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 10
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_desc cbds ON cbds.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbds.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cobm_id = :idBoletimMedicao ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbds.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta
						+ "  AND cbds.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.addScalar("constante", Hibernate.STRING)
					.addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("codigoItem", Hibernate.LONG)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("idBoletimMedicao", idBoletimMedicao);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa os Itens de Serviço relacionados ao boletim de medição de
	 * cobrança selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimExecutados(
			Integer idBoletimMedicao, Integer idGerenciaRegional,
			Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  itse.itse_id AS idItemServico, " // 1
					+ "  itse.itse_dsitemservico AS descricao, " // 2
					+ "  itse.itse_cdconstantecalculo AS constante, " // 3
					+ "  cobm_dtgeracao AS dataGeracao, " // 4
					+ "  itse_cditem AS codigoItem, " // 5
					+ "  loca.loca_nmlocalidade AS localidade, " // 6
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 7
					+ "  loca.loca_id AS idLoca, " // 8
					+ "  greg.greg_id AS idGerencia, " // 9
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 10
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbex.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cobm_id = :idBoletimMedicao ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbex.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta
						+ "  AND cbex.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.addScalar("constante", Hibernate.STRING)
					.addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("codigoItem", Hibernate.LONG)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("idBoletimMedicao", idBoletimMedicao);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa os Itens de Serviço relacionados ao boletim de medição de
	 * cobrança selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimSucesso(
			Integer idBoletimMedicao, Integer idGerenciaRegional,
			Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  cobm_dtgeracao AS dataGeracao, " // 1
					+ "  loca.loca_nmlocalidade AS localidade, " // 2
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 3
					+ "  loca.loca_id AS idLoca, " // 4
					+ "  greg.greg_id AS idGerencia, " // 5
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 6
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_sucesso cbsu ON cbsu.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbsu.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cobm_id = :idBoletimMedicao ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbsu.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta
						+ "  AND cbsu.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, cobm.cobm_dtgeracao ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, cobm.cobm_dtgeracao ";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("idBoletimMedicao", idBoletimMedicao);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * De acordo com o código da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 22/03/2011
	 **/
	public Object[] obterQuantidadeOSBoletimMedicaoCobranca(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(orse.orse_id) AS contador, "
					+ " itsc.itsc_vlitemservcontr AS valorItem, cbex.cbex_vlservico AS valorServico "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ "  INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.orse_id = orse.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbex.cobm_id = cobm.cobm_id ";

			switch (helper.getItemServico().getCodigoConstanteCalculo()) {

			case 2:
			case 6:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 3 ";
				break;

			case 3:
			case 7:
			case 9:
			case 11:
			case 13:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 2 ";
				break;

			case 4:
			case 8:
			case 10:
			case 12:
			case 14:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 ";
				break;

			case 18:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 AND orbo.orbo_cdtipopavimento = 1 ";
				break;

			case 19:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 AND orbo.orbo_cdtipopavimento = 2 ";
				break;

			case 20:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 2 AND orbo.orbo_iccalcada = 2 ";
				break;

			case 21:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 AND orbo.orbo_cdtipopavimento = 2 "
						+ " AND orbo.orbo_iccalcada = 2 ";
				break;

			case 22:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 AND orbo.orbo_cdtipopavimento = 2 "
						+ " AND orbo.orbo_iccalcada = 1 ";
				break;

			case 23:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 AND orbo.orbo_cdtipopavimento = 1 "
						+ " AND orbo.orbo_iccalcada = 2 ";
				break;

			case 24:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 AND orbo.orbo_cdtipopavimento = 1 "
						+ " AND orbo.orbo_iccalcada = 1 ";
				break;

			case 25:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.atend_motivo_encmt amen on orse.amen_id = amen.amen_id "
						+ " AND amen.amen_icexecucao = 2 AND amen.amen_icvisitarealizada = 1 ";
				break;
				
			case 26:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 2 AND orbo.orbo_iccalcada = 1 ";
				break;

			default:
				break;
			}

			consulta = consulta
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON cobm.cese_id = itsc.cese_id  "
					+ " INNER JOIN micromedicao.item_contrato_servico_tipo icst ON orse.svtp_id = icst.svtp_id AND itsc.itsc_id = icst.itsc_id"
					+ " WHERE itsc.itse_id = :idItemServico "
					+ "  AND cbex.cobm_id = :idCobBolMedicao "
					+ "  AND cbex.loca_id = :idLocalidade ";

			consulta = consulta
					+ " GROUP BY itsc.itsc_vlitemservcontr, cbex.cbex_vlservico ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("valorServico", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServico",
							helper.getItemServico().getId())
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * De acordo com o código da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 22/03/2011
	 **/
	public Object[] obterSomatorioOSBoletimMedicaoCobranca(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			switch (helper.getItemServico().getCodigoConstanteCalculo()) {

			case 15:
				consulta = consulta
						+ " SELECT sum(orbo.orbo_nnrepasfalto) AS somatorio, ";
				break;

			case 16:
				consulta = consulta
						+ " SELECT sum(orbo.orbo_nnrepparalelo) AS somatorio, ";
				break;

			case 17:
				consulta = consulta
						+ " SELECT sum(orbo.orbo_nnrepcalcada) AS somatorio, ";
				break;

			default:
				break;
			}

			consulta = consulta
					+ " itsc.itsc_vlitemservcontr AS valorItem "
					+ " FROM atendimentopublico.ordem_servico_boletim orbo "
					+ "  INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.orse_id = orbo.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbex.cobm_id = cobm.cobm_id "
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON cobm.cese_id = itsc.cese_id "
					+ " WHERE itsc.itse_id = :idItemServico "
					+ "  AND cbex.cobm_id = :idCobBolMedicao "
					+ "  AND cbex.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY itsc.itsc_vlitemservcontr";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("somatorio", Hibernate.BIG_DECIMAL)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServico",
							helper.getItemServico().getId())
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * De acordo com o código da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 23/03/2011
	 **/
	public Object[] obterQuantidadeOSBoletimMedicaoCobrancaDesconto(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(orse.orse_id) AS contador, "
					+ " itsc.itsc_vlitemservcontr AS valorItem "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ "  INNER JOIN cobranca.cobr_boletim_desc cbde ON cbde.orse_id = orse.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbde.cobm_id = cobm.cobm_id "
					+ "  INNER JOIN micromedicao.item_contrato_servico_tipo icst ON orse.svtp_id = icst.svtp_id "
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON itsc.itsc_id = icst.itsc_id  "
					+ "    AND cobm.cese_id = itsc.cese_id "
					+ " WHERE itsc.itse_id = :idItemServico "
					+ "  AND cbde.cobm_id = :idCobBolMedicao "
					+ "  AND cbde.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY itsc.itsc_vlitemservcontr ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServico",
							helper.getItemServico().getId())
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Consulta os valores da totalização da taxa de sucesso.
	 * 
	 * @author Mariana Victor
	 * @created 23/03/2011
	 **/
	public Object[] obterTotalizacaoOSBoletimMedicaoCobrancaSucesso(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(cbsu.imov_id) AS contador, cese.cese_pctaxasucesso AS pcTxSucesso, "
					+ "    sum(cbsu.cbsu_vlrecuperado) AS somatorio, sum(cbsu.cbsu_vltxsucesso) AS comatorioCalculado "
					+ " FROM cobranca.cobr_boletim_sucesso cbsu "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cobm_id = cbsu.cobm_id "
					+ "   INNER JOIN micromedicao.contrato_empresa_servico cese ON cobm.cese_id = cese.cese_id "
					+ " WHERE cbsu.cobm_id = :idCobBolMedicao "
					+ "   AND cbsu.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY cese.cese_pctaxasucesso ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.addScalar("pcTxSucesso", Hibernate.BIG_DECIMAL)
					.addScalar("somatorio", Hibernate.BIG_DECIMAL)
					.addScalar("comatorioCalculado", Hibernate.BIG_DECIMAL)
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emissão Boletim Medição Cobrança
	 * 
	 * Pesquisa dados da empresa e do contrado do boletim de cobrança
	 * 
	 * @author Mariana Victor
	 * @created 24/03/2011
	 **/
	public Object[] pesquisarDadosBoletimMedicaoCobranca(
			Integer anoMesReferencia, Integer idCobrancaGrupo,
			Integer idContratoEmpresaServico) throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT empr.empr_nmempresa AS nome, cese.cese_dsnumerocontrato AS numero, cobm.cobm_vltotal AS valorTotal, "
					+ " cobm.cobm_id as idBoletimMedicao"
					+ " FROM cobranca.cobr_boletim_medicao cobm "
					+ " INNER JOIN micromedicao.contrato_empresa_servico cese ON cobm.cese_id = cese.cese_id "
					+ " INNER JOIN cadastro.empresa empr ON cese.empr_id = empr.empr_id ";
			if (idCobrancaGrupo != null) {
				consulta = consulta + "WHERE cobm.cbgr_id = " + idCobrancaGrupo;
			} else {
				consulta = consulta
						+ "WHERE cobm.cbgr_id is null and cese.cese_id = "
						+ idContratoEmpresaServico;
			}
			consulta = consulta
					+ " AND cobm.cobm_amreferencia = :anoMesReferencia ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("nome", Hibernate.STRING)
					.addScalar("numero", Hibernate.STRING)
					.addScalar("valorTotal", Hibernate.BIG_DECIMAL)
					.addScalar("idBoletimMedicao", Hibernate.INTEGER)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * [UC1155] Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * 
	 * @author Paulo Diniz,Vivianne Sousa
	 * @date 16/03/2011, 14/01/2012
	 * 
	 * @param mesAno
	 *            para análise
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> gerarRelatorioAnalisePerdasCreditos(
			String anoMesReferencia) throws ErroRepositorioException {
		RelatorioAnalisePerdasCreditosBean retorno = new RelatorioAnalisePerdasCreditosBean();
		Collection<Object[]> retornoBanco = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		SQLQuery query = null;

		try {

			consulta = " select  	 "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoAte180, "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoMais180, "
					+

					"  sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoAte360, "
					+ "  sum( case when (drrs.drrs_qtdiasvencidos > 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoMais360, "
					+

					" sum( case when (drrs.drrs_qtdiasvencidos <=0 or  drrs.drrs_qtdiasvencidos is null) "
					+ " then drfx.drfx_vldocumentos end) as a_vencer, "
					+ " sum(drfx.drfx_qtdocumentos) as qtd_documentos, "
					+ " sum(drfx.drfx_vldocumentos) as valor_total , "
					+ " fdrc.fdrc_vlfaixainicial as faixaInicial, "
					+ " fdrc.fdrc_vlfaixafinal as faixaFinal, "
					+ " catg.catg_id as categoriaId, "
					+ " catg.catg_dscategoria as categoriaTexto, "
					+ " fdrc.fdrc_id as idFaixa "
					+ " from  	financeiro.docs_a_rec_resumo drrs  "
					+ " inner join financeiro.doc_receber_faixa_resumo drfx on drfx.drrs_id = drrs.drrs_id "
					+ " inner join financeiro.faixa_docs_a_receber fdrc on fdrc.fdrc_id = drfx.fdrc_id"
					+ " inner join cadastro.categoria catg on drrs.catg_id = catg.catg_id "
					+ " where 	drrs.drrs_amreferenciarecebimentos = "
					+ anoMesReferencia
					+ " group by catg.catg_id,fdrc.fdrc_vlfaixainicial, fdrc.fdrc_vlfaixafinal,catg.catg_dscategoria,fdrc.fdrc_id "
					+ " order by catg.catg_id,fdrc.fdrc_vlfaixainicial";

			query = session.createSQLQuery(consulta);
			query.addScalar("vencidoAte180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoAte360", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais360", Hibernate.BIG_DECIMAL);
			query.addScalar("a_vencer", Hibernate.BIG_DECIMAL);
			query.addScalar("qtd_documentos", Hibernate.INTEGER);
			query.addScalar("valor_total", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaInicial", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaFinal", Hibernate.BIG_DECIMAL);
			query.addScalar("categoriaId", Hibernate.INTEGER);
			query.addScalar("categoriaTexto", Hibernate.STRING);
			query.addScalar("idFaixa", Hibernate.INTEGER);
			// query.setMaxResults(3);
			retornoBanco = (Collection<Object[]>) query.list();

			// if(retornoBanco != null && retornoBanco.size() == 3){
			//
			// if(retornoBanco.get(0)[0] != null){
			// retorno.setPrimeiraFaixaVencidosAteSeisMeses(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(0)[0]+"")));
			// }else{
			// retorno.setPrimeiraFaixaVencidosAteSeisMeses("");
			// }
			// if(retornoBanco.get(0)[1] != null){
			// retorno.setPrimeiraFaixaVencidosSuperiorSeisMeses(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(0)[1]+"")));
			// }else{
			// retorno.setPrimeiraFaixaVencidosSuperiorSeisMeses("");
			// }
			// if(retornoBanco.get(0)[4] != null){
			// retorno.setPrimeiraFaixaVencer(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(0)[4]+"")));
			// }else{
			// retorno.setPrimeiraFaixaVencer("");
			// }
			// if(retornoBanco.get(0)[6] != null){
			// retorno.setPrimeiraFaixaTotal(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(0)[6]+"")));
			// }else{
			// retorno.setPrimeiraFaixaTotal("");
			// }
			//
			// if(retornoBanco.get(1)[2] != null){
			// retorno.setSegundaFaixaVencidosAteDoseMeses(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(1)[2]+"")));
			// }else{
			// retorno.setSegundaFaixaVencidosAteDoseMeses("");
			// }
			// if(retornoBanco.get(1)[3] != null){
			// retorno.setSegundaFaixaVencidosSuperiorDoseMeses(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(1)[3]+"")));
			// }else{
			// retorno.setSegundaFaixaVencidosSuperiorDoseMeses("");
			// }
			// if(retornoBanco.get(1)[4] != null){
			// retorno.setSegundaFaixaVencer(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(1)[4]+"")));
			// }else{
			// retorno.setSegundaFaixaVencer("");
			// }
			// if(retornoBanco.get(1)[6] != null){
			// retorno.setSegundaFaixaTotal(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(1)[6]+"")));
			// }else{
			// retorno.setSegundaFaixaTotal("");
			// }
			//
			// if(retornoBanco.get(2)[2] != null){
			// retorno.setTerceiraFaixaVencidosAteDoseMeses(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(2)[2]+"")));
			// }else{
			// retorno.setTerceiraFaixaVencidosAteDoseMeses("");
			// }
			// if(retornoBanco.get(2)[3] != null){
			// retorno.setTerceiraFaixaVencidosSuperiorDoseMeses(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(2)[3]+"")));
			// }else{
			// retorno.setTerceiraFaixaVencidosSuperiorDoseMeses("");
			// }
			// if(retornoBanco.get(2)[4] != null){
			// retorno.setTerceiraFaixaVencer(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(2)[4]+"")));
			// }else{
			// retorno.setTerceiraFaixaVencer("");
			// }
			// if(retornoBanco.get(2)[6] != null){
			// retorno.setTerceiraFaixaTotal(Util.formatarMoedaReal(new
			// BigDecimal(retornoBanco.get(2)[6]+"")));
			// }else{
			// retorno.setTerceiraFaixaTotal("");
			// }
			// }else{
			// retorno = null;
			// }
			//

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoBanco;
	}

	/**
	 * Retorna o maior ano mesReferencia da tabela docs_a_rec_resumo
	 * 
	 * [UC1155] Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * 
	 * @author Paulo Diniz
	 * @date 16/03/2011
	 * 
	 * @param mesAno
	 *            para análise
	 * @throws ErroRepositorioException
	 * @throws ErroRepositorioException
	 */
	public int maiorAnoMesReferenciaDocumentosAReceberResumo()
			throws ErroRepositorioException {
		int retorno = 0;
		Object retornoBanco = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		SQLQuery query = null;

		try {

			consulta = " select max(drrs.drrs_amreferenciarecebimentos) as max from  	financeiro.docs_a_rec_resumo drrs 	 ";

			query = session.createSQLQuery(consulta);
			query.addScalar("max", Hibernate.INTEGER);
			retornoBanco = (Object) query.uniqueResult();

			if (retornoBanco != null) {
				retorno = Integer.parseInt(retornoBanco + "");
			}
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1151] Gerar Boletim de Medição
	 * 
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection<BigDecimal> pesquisarValorContaouContaHistorico(
			Integer idImovel, Integer referencia)
			throws ErroRepositorioException {

		// cria a variável que vai armazenar a coleção pesquisada
		Collection<BigDecimal> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select "
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   pg.pgmt_vlpagamento "
					+ " else "
					+ "   pghistContaHist.pghi_vlpagamento "
					+ " end as valorPagamento  " // 0
					+ " from cadastro.imovel im "
					+ " LEFT JOIN faturamento.conta ct on ct.imov_id = im.imov_id and ct.cnta_amreferenciaconta = :referencia and ct.dcst_idatual = :retificada "
					+ " LEFT JOIN arrecadacao.pagamento pg on pg.cnta_id = ct.cnta_id "
					+ " LEFT JOIN faturamento.conta_historico cthist on cthist.imov_id = im.imov_id and cthist.cnhi_amreferenciaconta = :referencia and cthist.dcst_idatual = :retificada "
					+ " LEFT JOIN arrecadacao.pagamento_historico pghistContaHist on pghistContaHist.cnta_id = cthist.cnta_id "
					+ " where im.imov_id = :idImovel ";
			// executa o hql
			retorno = session.createSQLQuery(consulta)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("referencia", referencia).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * Pesquisa a quantidade de contas associadas ao imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 13/04/2011
	 */
	public Integer pesquisarQuantidadeContasEmCobrancaPorImovel(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta,
			Integer idImovel, SistemaParametro sistemaParametro)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT COUNT(DISTINCT conta.cnta_id)  AS qtdContas"
					+ " FROM faturamento.conta conta "
					+ " LEFT OUTER JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ " INNER JOIN cadastro.imovel imov ON conta.imov_id = imov.imov_id "
					+ " WHERE conta.imov_id = :idImovel "
					+ " AND conta.cnta_amreferenciaconta <  :anoMes "
					+ " AND conta.cmrv_id is null and conta.cnta_dtrevisao is null "
					+ " AND conta.cnta_dtvencimentoconta < :dataVencimento "
					+ " AND pagto.pgmt_id is null and conta.dcst_idatual in (:incluida,:normal,:retificada) ";

			Date dataVencimento = new Date();
			if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {

				dataVencimento = Util.subtrairNumeroDiasDeUmaData(new Date(),
						comandoEmpresaCobrancaConta.getQtdDiasVencimento());
			}

			consulta = consulta
					+ " AND imov.imov_idcategoriaprincipal IN (:idsCategoria) ";

			consulta = consulta
					+ criarCondicionaisPesquisarContasInformarContasEmCobranca(comandoEmpresaCobrancaConta);

			Collection<Integer> idsCategorias = new ArrayList();
			idsCategorias.add(Categoria.RESIDENCIAL);
			idsCategorias.add(Categoria.COMERCIAL);
			idsCategorias.add(Categoria.INDUSTRIAL);
			idsCategorias.add(Categoria.PUBLICO);

			if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null && !comandoEmpresaCobrancaConta
					.getIndicadorResidencial().equals(
							ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorComercial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorComercial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorIndustrial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorPublico() != null && !comandoEmpresaCobrancaConta
							.getIndicadorPublico().equals(
									ConstantesSistema.NAO.intValue()))) {

				idsCategorias = new ArrayList();

				if (comandoEmpresaCobrancaConta.getIndicadorResidencial() != null
						&& !comandoEmpresaCobrancaConta
								.getIndicadorResidencial().equals(
										ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.RESIDENCIAL);
				}

				if (comandoEmpresaCobrancaConta.getIndicadorComercial() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorComercial()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.COMERCIAL);
				}

				if (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null
						&& !comandoEmpresaCobrancaConta
								.getIndicadorIndustrial().equals(
										ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.INDUSTRIAL);
				}

				if (comandoEmpresaCobrancaConta.getIndicadorPublico() != null
						&& !comandoEmpresaCobrancaConta.getIndicadorPublico()
								.equals(ConstantesSistema.NAO.intValue())) {
					idsCategorias.add(Categoria.PUBLICO);
				}

			}

			// retorno = (Integer) query.setMaxResults(1).uniqueResult();
			retorno = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("qtdContas", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMes",
							sistemaParametro.getAnoMesArrecadacao())
					.setDate("dataVencimento", dataVencimento)
					.setParameterList("idsCategoria", idsCategorias)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoImovelPerfil(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "iper.iper_id as idImovelPerfil, "// 16
					+ "iper.iper_dsimovelperfil as dsImovelPerfil "// 17
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_per ceip on ceip.cecc_id = cecc.cecc_id "
					+ "left join cadastro.imovel_perfil iper on ceip.iper_id = iper.iper_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("dsImovelPerfil", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoGerenciaRegional(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "greg.greg_id as idGerenciaRegional, "// 16
					+ "greg.greg_nmregional as nmGerenciaRegional "// 17
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_ger cecg on cecg.cecc_id = cecc.cecc_id "
					+ "left join cadastro.gerencia_regional greg on cecg.greg_id = greg.greg_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nmGerenciaRegional", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extensão de Comando de Contas em Cobrança por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoUnidadeNegocio(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "uneg.uneg_id as idUnidadeNegocio, "// 0
					+ "uneg.uneg_nmunidadenegocio as dsUnidadeNegocio "// 1
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_uneg ceun on ceun.cecc_id = cecc.cecc_id "
					+ "left join cadastro.unidade_negocio uneg on ceun.uneg_id = uneg.uneg_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("dsUnidadeNegocio", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * @author: Mariana Victor
	 * @date: 13/04/2011
	 */
	public Integer pesquisarQuantidadeContasArquivoTextoContasCobrancaEmpresa(
			Collection ids, Integer idImovel) throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = " SELECT COUNT(DISTINCT conta.cnta_id) AS quantidadeContas " // 1
					+ " from cobranca.empresa_cobranca_conta ecco "
					+ " inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ " inner join cadastro.imovel imovel  on imovel.imov_id = conta.imov_id and imovel.imov_id = :idImovel "
					+ " where ecco.cecc_id in (:ids) "
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidadeContas", Hibernate.INTEGER)
					.setParameterList("ids", ids)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * Pesquisa a Situação de cobrança a partir do código constante.
	 * 
	 * @author: Mariana Victor
	 * @date: 18/04/2011
	 */
	public Integer pesquisarCobrancaSituacao(Integer codigoConstante)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = " SELECT cbst_id AS id "
					+ " FROM cobranca.cobranca_situacao "
					+ " WHERE cbst_cdconstante = :codigoConstante ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("codigoConstante", codigoConstante)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisar Debito Cobrado de Parcelamento
	 * 
	 * @author Rogério Peixoto
	 * @throws ErroRepositorioException
	 * @date 29/03/2011
	 */
	public boolean pesquisarDebitoCobradoParcelamento(Integer codigoParcelamento)
			throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeDebito = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade FROM "
					+ "cobranca.parcelamento parc "
					+ "INNER JOIN faturamento.debito_a_cobrar dac ON (parc.parc_id = dac.parc_id)"
					+ "INNER JOIN faturamento.debito_cobrado dec ON (dac.dbac_id = dec.dbac_id)"
					+ "WHERE parc.parc_id = :codigoParcelamento";

			quantidadeDebito = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("codigoParcelamento", codigoParcelamento)
					.setMaxResults(1).uniqueResult();

			if (quantidadeDebito != null && quantidadeDebito > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarReferenciaContaPorId(Integer idConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String consulta;
		Integer referencia = null;

		try {

			consulta = "SELECT cnta_amreferenciaconta as referencia FROM "
					+ "faturamento.conta cnta " + "WHERE cnta_id = "
					+ idConta.intValue();

			referencia = (Integer) session.createSQLQuery(consulta)
					.addScalar("referencia", Hibernate.INTEGER)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return referencia;
	}

	public boolean verificaContaVinculadaAContratoParcelAtivo(Integer idConta)
			throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeContas = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from COBRANCA.contrato_parcel_item item "
					+ "inner join COBRANCA.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.cnta_id = :idConta and cpar.pcst_id = "
					+ ParcelamentoSituacao.NORMAL;

			quantidadeContas = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

			if (quantidadeContas != null && quantidadeContas > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public boolean verificaGuiaVinculadaAContratoParcelAtivo(Integer idGuia)
			throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeContas = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from COBRANCA.contrato_parcel_item item "
					+ "inner join COBRANCA.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.gpag_id = :idGuia and cpar.pcst_id = "
					+ ParcelamentoSituacao.NORMAL;

			quantidadeContas = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idGuia", idGuia).setMaxResults(1)
					.uniqueResult();

			if (quantidadeContas != null && quantidadeContas > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1140] Cancelar Contrato de Parcelamento por Cliente
	 * 
	 * @author Rômulo Aurélio
	 * @throws ErroRepositorioException
	 * @date 12/05/2011
	 */
	public ContratoParcelamento pesquisarContratoParcelamento(
			String numeroParcelamento) throws ErroRepositorioException {
		ContratoParcelamento retorno = null;
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "SELECT  contratoParcelamento AS contratoParcelamento "
					+ "FROM  ContratoParcelamento contratoParcelamento "
					+ "INNER JOIN FETCH contratoParcelamento.parcelamentoSituacao parcelamentoSituacao "
					+ "LEFT JOIN FETCH contratoParcelamento.contratoAnterior contratoAnterior "
					+ "LEFT JOIN FETCH contratoParcelamento.relacaoAnterior relacaoAnterior "
					+ "LEFT JOIN FETCH contratoParcelamento.usuarioResponsavel usuarioResponsavel "
					+ "LEFT JOIN FETCH contratoParcelamento.relacaoCliente relacaoCliente "
					+ "LEFT JOIN FETCH contratoParcelamento.resolucaoDiretoria resolucaoDiretoria "
					+ "LEFT JOIN FETCH contratoParcelamento.cobrancaForma cobrancaForma "
					+ "LEFT JOIN FETCH contratoParcelamento.motivoDesfazer motivoDesfazer "

					+ "WHERE contratoParcelamento.numero = :numeroParcelamento ";

			retorno = (ContratoParcelamento) session.createQuery(consulta)
					.setString("numeroParcelamento", numeroParcelamento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1140] Cancelar Contrato de Parcelamento por Cliente
	 * 
	 * @author Rômulo Aurélio, Mariana Victor
	 * @throws ErroRepositorioException
	 * @date 12/05/2011, 18/07/2011
	 */
	public Collection pesquisarDebitoContratoParcelamentoPorTipoDocumento(
			ContratoParcelamento contratoParcelamento, Integer idDocumentoTipo)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "SELECT  contratoParcelamentoItem AS contratoParcelamentoItem "
					+ "FROM  ContratoParcelamentoItem contratoParcelamentoItem "
					+ " LEFT JOIN fetch contratoParcelamentoItem.contrato contratoParcelamento "
					+ " LEFT JOIN fetch contratoParcelamentoItem.contaGeral contageral "
					+ " LEFT JOIN fetch contratoParcelamentoItem.guiaPagamentoGeral guiaPagamentoGeral "
					+ " LEFT JOIN fetch guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ " LEFT JOIN fetch contratoParcelamentoItem.debitoACobrarGeral debitoACobrarGeral "
					+ " LEFT JOIN fetch debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "WHERE contratoParcelamento.numero = :numeroParcelamento "
					+ " and contratoParcelamentoItem.documentoTipo.id = "
					+ idDocumentoTipo
					+ " "
					+ " and contratoParcelamentoItem.valorItem not in (select  coalesce(sum(prestacaoItem.valorPago), 0) "
					+ "  from PrestacaoItemContratoParcelamento prestacaoItem "
					+ "  inner join prestacaoItem.prestacao b "
					+ "  where contratoParcelamento.id = b.contratoParcelamento.id "
					+ "  and contratoParcelamentoItem.id = prestacaoItem.item.id) ";

			retorno = (Collection) session
					.createQuery(consulta)
					.setParameter("numeroParcelamento",
							contratoParcelamento.getNumero()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * Pesquisa os dados dos comandos
	 * 
	 * @author: Mariana Victor
	 * @date: 04/05/2011
	 */
	public Collection pesquisarDadosConsultarComandosContasCobrancaEmpresaResumido(
			Integer idEmpresa, Date cicloInicial, Date cicloFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que já monta uma coleção de
		 * ConsultarComandosContasCobrancaEmpresaHelper com tudo que é
		 * necessário **
		 */
		try {
			consulta = "select new gcom.cobranca.cobrancaporresultado.ConsultarComandosContasCobrancaEmpresaHelper("
					+ " comandoEmpresaCobrancaConta.id," // 1
					+ " comandoEmpresaCobrancaConta.empresa.id," // 2
					+ " comandoEmpresaCobrancaConta.empresa.descricao," // 3
					+ " comandoEmpresaCobrancaConta.dataInicioCiclo," // 4
					+ " comandoEmpresaCobrancaConta.dataFimCiclo," // 5
					+ " comandoEmpresaCobrancaConta.dataExecucao," // 6
					+ " comandoEmpresaCobrancaConta.dataEncerramento," // 7
					+ " comandoEmpresaCobrancaConta.imovel.id," // 8
					+ " comandoEmpresaCobrancaConta.cliente.id," // 9
					+ " comandoEmpresaCobrancaConta.cliente.nome," // 10
					+ " comandoEmpresaCobrancaConta.gerenciaRegional.id," // 11
					+ " comandoEmpresaCobrancaConta.gerenciaRegional.nome," // 12
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id," // 13
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome," // 14
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id," // 15
					+ " comandoEmpresaCobrancaConta.localidadeInicial.descricao," // 16
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id," // 17
					+ " comandoEmpresaCobrancaConta.localidadeFinal.descricao," // 18
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial," // 19
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal," // 20
					+ " comandoEmpresaCobrancaConta.numeroQuadraInicial," // 21
					+ " comandoEmpresaCobrancaConta.numeroQuadraFinal," // 22
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial," // 23
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal," // 24
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial," // 25
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal," // 26
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta," // 27
					+ " comandoEmpresaCobrancaConta.valorMaximoConta) " // 28
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "left join comandoEmpresaCobrancaConta.cliente cliente "
					+ "left join comandoEmpresaCobrancaConta.localidadeInicial localidadeInicial "
					+ "left join comandoEmpresaCobrancaConta.localidadeFinal localidadeFinal "
					+ "left join comandoEmpresaCobrancaConta.unidadeNegocio unidadeNegocio "
					+ "left join comandoEmpresaCobrancaConta.gerenciaRegional gerenciaRegional "
					+ "inner join comandoEmpresaCobrancaConta.empresa empresa "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa ";

			if (cicloInicial != null && cicloFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataInicioCiclo between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta + "ORDER BY comandoEmpresaCobrancaConta.id ";

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice * quantidadeRegistros).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * Pesquisa os dados de um comando para exibir no popup
	 * 
	 * @author: Mariana Victor, Raimundo Martins
	 * @date: 04/05/2011, 13/10/2011
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosPopupExtensaoComandoCobranca(
			Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		String consulta2;
		String debitoOuConta;
		SistemaParametro sistemaParametro = RepositorioUtilHBM.getInstancia()
				.pesquisarParametrosDoSistema();
		try {
			consulta = "select "
					+ "empre.empr_nmempresa as empresa, "// 0
					+ "cecc.cecc_dtiniciociclo as dataInicioCiclo, "// 1
					+ "cecc.cecc_dtfimciclo as dataFimCiclo, "// 2
					+ "cecc.cecc_dtexecucao as dataExecucao, "// 3
					+ "cecc.cecc_dtencerramento as dataEncerramento, "// 4
					+ "imov_id as imovel, "// 5
					+ "cli.clie_id as idCliente, "// 6
					+ "cli.clie_nmcliente as cliente, "// 7
					+ "cecc.cecc_icresidencial as icResidencial, "// 8
					+ "cecc.cecc_iccomercial as icComercial, "// 9
					+ "cecc.cecc_icindustrial as icIndustrial, "// 10
					+ "cecc.cecc_icpublico as icPublico, "// 11
					+ "iper.iper_id as idImovelPerfil, "// 12
					+ "iper.iper_dsimovelperfil as dsImovelPerfil, "// 13
					+ "greg.greg_id as idGerenciaRegional, "// 14
					+ "greg.greg_nmregional as dsGerenciaRegional, "// 15
					+ "uneg.uneg_id as idUneg, "// 16
					+ "uneg.uneg_nmunidadenegocio as nomeUneg, "// 17
					+ "loca_idinicial as locaIncial, "// 18
					+ "loca_idfinal as locaFinal, "// 19
					+ "cecc_cdsetorcomercialinicial as setorInicial, "// 20
					+ "cecc_cdsetorcomercialfinal as setorFinal, "// 21
					+ "cecc_nnquadrainicial as idQuadraInicial, "// 22
					+ "cecc_nnquadrafinal as idQuadraFinal, "// 23
					+ "cecc.cecc_amreferenciacontainicial as anoMesContaInicial, "// 24
					+ "cecc.cecc_amreferenciacontafinal as anoMesContaFinal, "// 25
					+ "cecc.cecc_dtvencimentocontainicial as vencimentoIncial, "// 26
					+ "cecc.cecc_dtvencimentocontafinal as vencimentoFinal, ";// 27

			consulta2 = "emco.emco_id as idEmpContrCob, "// 30
					+ "emco.emco_pcpagamentodevido as pcPagDevido, "// 31
					+ "cecc.cecc_icgeracaotxt as indicadorGeracaoTxt, "// 32
					+ "cecc.cecc_qtdcontasinicial as qtdContasInicial, "// 33
					+ "cecc.cecc_qtdcontasfinal as qtdContasFinal, "// 34
					+ "cecc.cecc_qtddiasvencimento as qtdDiasVencimento, "// 35
					+ "las.last_dsligacaoaguasituacao as situacaoAgua "// 36
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "inner join cadastro.empresa empre on cecc.empr_id = empre.empr_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = empre.empr_id "
					+ "left join cadastro.cliente cli on cli.clie_id = cecc.clie_id "
					+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = cecc.uneg_id "
					+ "left join cadastro.imovel_perfil iper on iper.iper_id = cecc.iper_id "
					+ "left join cadastro.gerencia_regional greg on cecc.greg_id = greg.greg_id "
					+ "left join atendimentopublico.ligacao_agua_situacao las on cecc.last_id = las.last_id "
					+ "where cecc.cecc_id = :idComando ";

			if (sistemaParametro.getIndicadorTotalDebito() == 1) {
				debitoOuConta = "cecc_vldebitoinicial as vlMinino, "// 28
						+ "cecc_vldebitofinal as vlMaximo, ";// 29;
			} else {
				debitoOuConta = "cecc_vlminimoconta as vlMinino, "// 28
						+ "cecc_vlmaximoconta as vlMaximo, ";// 29;
			}
			retorno = session
					.createSQLQuery(consulta + debitoOuConta + consulta2)
					.addScalar("empresa", Hibernate.STRING)
					.addScalar("dataInicioCiclo", Hibernate.DATE)
					.addScalar("dataFimCiclo", Hibernate.DATE)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("cliente", Hibernate.STRING)
					.addScalar("icResidencial", Hibernate.SHORT)
					.addScalar("icComercial", Hibernate.SHORT)
					.addScalar("icIndustrial", Hibernate.SHORT)
					.addScalar("icPublico", Hibernate.SHORT)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("dsImovelPerfil", Hibernate.STRING)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("dsGerenciaRegional", Hibernate.STRING)
					.addScalar("idUneg", Hibernate.INTEGER)
					.addScalar("nomeUneg", Hibernate.STRING)
					.addScalar("locaIncial", Hibernate.INTEGER)
					.addScalar("locaFinal", Hibernate.INTEGER)
					.addScalar("setorInicial", Hibernate.INTEGER)
					.addScalar("setorFinal", Hibernate.INTEGER)
					.addScalar("idQuadraInicial", Hibernate.INTEGER)
					.addScalar("idQuadraFinal", Hibernate.INTEGER)
					.addScalar("anoMesContaInicial", Hibernate.INTEGER)
					.addScalar("anoMesContaFinal", Hibernate.INTEGER)
					.addScalar("vencimentoIncial", Hibernate.DATE)
					.addScalar("vencimentoFinal", Hibernate.DATE)
					.addScalar("vlMinino", Hibernate.BIG_DECIMAL)
					.addScalar("vlMaximo", Hibernate.BIG_DECIMAL)
					.addScalar("idEmpContrCob", Hibernate.INTEGER)
					.addScalar("pcPagDevido", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorGeracaoTxt", Hibernate.INTEGER)
					.addScalar("qtdContasInicial", Hibernate.INTEGER)
					.addScalar("qtdContasFinal", Hibernate.INTEGER)
					.addScalar("qtdDiasVencimento", Hibernate.INTEGER)
					.addScalar("situacaoAgua", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * - Pesquisa dados da cobrança
	 * 
	 * @author: Mariana Victor
	 * @date: 06/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaComandoEmpresa(
			Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " ecc.ecco_vloriginalconta as valor"
					+ " from cobranca.empresa_cobranca_conta ecc"
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ecc.cecc_id = cecc.cecc_id"
					+ " inner join faturamento.conta conta on ecc.cnta_id = conta.cnta_id "
					+ " where cecc.cecc_id = :idComando"
					+ " and not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=ecc.cnta_id)"
					+ " and (conta.dcst_idatual in " + "("
					+ DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.RETIFICADA + ", "
					+ DebitoCreditoSituacao.INCLUIDA + " )) ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * Pesquisa a quantidade de contas, agrupando por imóvel
	 * 
	 * @author: Mariana Victor
	 * @date: 06/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaComandoEmpresaPorImovel(
			Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT COUNT(emprCobConta.imov_id)      AS qtdContas, "
					+ "  SUM(emprCobConta.ecco_vloriginalconta)     AS valorTotalDebitos "
					+ " FROM cobranca.empresa_cobranca_conta emprCobConta "
					+ " WHERE emprCobConta.cecc_id = :idComando "
					+ "  and emprcobconta.ecco_icpagamentovalido = :indicadorPgValido "
					+ "  and emprCobConta.ecco_cdincluido is null"
					+ " GROUP BY emprCobConta.imov_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("qtdContas", Hibernate.INTEGER)
					.addScalar("valorTotalDebitos", Hibernate.BIG_DECIMAL)
					.setInteger("idComando", idComando)
					.setInteger("indicadorPgValido", ConstantesSistema.SIM)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobrança por Empresa
	 * 
	 * @author Mariana Victor
	 * @data 09/05/2011
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarIndicadorGeracaoTxt(Collection idsComandos)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "update gcom.cobranca.ComandoEmpresaCobrancaConta "
					+ "set cecc_icgeracaotxt = :icGeracao, cecc_tmultimaalteracao = :ultimaAlteracao where cecc_id in (";

			Iterator iterator = idsComandos.iterator();

			while (iterator.hasNext()) {
				consulta += ((Integer) iterator.next()).toString() + ", ";
			}
			// remove a virgula do final e coloca o parêntese
			consulta = consulta.substring(0, consulta.length() - 2) + ")";

			session.createQuery(consulta)
					.setInteger("icGeracao", ConstantesSistema.SIM)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1168] Encerrar Comandos de Cobrança por Empresa
	 * 
	 * Pesquisa os ids dos imóveis e das ordens de serviços geradas para um
	 * determinado comando
	 * 
	 * @author Mariana Victor
	 * @created 09/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection<Object[]> pesquisarImovelOrdemServicoParaEncerrarComando(
			int quantidadeInicio, Integer idComando)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT emprCobConta.imov_id AS idImovel, "
					+ "  emprCobConta.orse_id AS idOS "
					+ " FROM cobranca.empresa_cobranca_conta emprCobConta "
					+ " WHERE emprCobConta.cecc_id = :idComando "
					+ " group by emprCobConta.imov_id, emprCobConta.orse_id "
					+ " order by emprCobConta.imov_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idOS", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setFirstResult(quantidadeInicio).setMaxResults(1000)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC1168] Encerrar Comandos de Cobrança por Empresa
	 * 
	 * @author Mariana Victor
	 * @data 09/05/2011
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarDataEncerramentoComando(Integer idComando)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "update gcom.cobranca.ComandoEmpresaCobrancaConta "
					+ " set cecc_dtencerramento = :dataEncerramento, cecc_tmultimaalteracao = :ultimaAlteracao "
					+ " where cecc_id = :idComando ";

			session.createQuery(consulta)
					.setTimestamp("dataEncerramento", new Date())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("idComando", idComando).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Gerar OS
	 * 
	 * @author Mariana Victor
	 * @data 17/05/2011
	 */
	public Collection<Integer> pesquisarIdsImoveis(
			MovimentarOrdemServicoGerarOSHelper helper)
			throws ErroRepositorioException {

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select imov.imov_id as idImovel "
					+ " from cadastro.imovel imov "
					+ "   inner join cobranca.empresa_cobranca_conta ecco on ecco.imov_id = imov.imov_id "
					+ "   inner join cobranca.cmd_empr_cobr_conta cecc on ecco.cecc_id = cecc.cecc_id "
					+ "   inner join cadastro.imovel_subcategoria imsb on imsb.imov_id = imov.imov_id "
					+ "   inner join cadastro.subcategoria scat on scat.scat_id = imsb.scat_id "
					+ " where cecc.cecc_id = :idComando ";

			if (helper.getIdsCategoria() != null
					&& helper.getIdsCategoria().length != 0) {
				consulta += "   and scat.catg_id in (";

				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					consulta += helper.getIdsCategoria()[i] + ", ";
				}
				// remove a virgula do final e coloca o parêntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getIdsImovelPerfil() != null
					&& helper.getIdsImovelPerfil().length != 0) {
				consulta += "   and imov.iper_id in (";

				for (int i = 0; i < helper.getIdsImovelPerfil().length; i++) {
					consulta += helper.getIdsImovelPerfil()[i] + ", ";
				}
				// remove a virgula do final e coloca o parêntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getIdsLigacaoAguaSituacao() != null
					&& helper.getIdsLigacaoAguaSituacao().length != 0) {
				consulta += "   and imov.last_id in (";

				for (int i = 0; i < helper.getIdsLigacaoAguaSituacao().length; i++) {
					consulta += helper.getIdsLigacaoAguaSituacao()[i] + ", ";
				}
				// remove a virgula do final e coloca o parêntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getValorMinimo() != null
					&& helper.getValorMaximo() != null) {

				consulta = consulta
						+ " and ( (select sum(ecc.ecco_vloriginalconta)  "
						+ " from cobranca.empresa_cobranca_conta ecc "
						+ " where ecc.ecco_id = ecco.ecco_id) between :valorInicial and :valorFinal) ";
			}

			consulta = consulta + " group by imov.imov_id ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", helper.getIdComandoContaCobranca());

			if (helper.getValorMinimo() != null
					&& helper.getValorMaximo() != null) {
				retorno = query
						.setBigDecimal("valorInicial", helper.getValorMinimo())
						.setBigDecimal("valorFinal", helper.getValorMaximo())
						.list();
			} else {
				retorno = query.list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Emitir OS Gerada pela Empresa
	 * 
	 * @author Mariana Victor
	 * @data 18/05/2011
	 */
	public Collection<Object[]> pesquisarDadosOSGeradasPelaEmpresa(
			Integer idComando, Integer idTipoServico)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select orse.orse_id as idOS, svtp.svtp_dsservicotipo as servicoTipo, orse.imov_id as idImovel, clie.clie_nmcliente as nomeCliente "
					+ " from cobranca.cmd_empr_cobr_conta cecc "
					+ "   inner join cadastro.unidade_organizacional unid on unid.empr_id = cecc.empr_id "
					+ "   inner join atendimentopublico.ordem_servico_unidade osun on unid.unid_id = osun.unid_id "
					+ "   inner join atendimentopublico.ordem_servico orse on osun.orse_id = orse.orse_id "
					+ "   inner join atendimentopublico.servico_tipo svtp on svtp.svtp_id = orse.svtp_id "
					+ "   inner join cadastro.cliente_imovel clim on clim.imov_id = orse.imov_id "
					+ "   inner join cadastro.cliente clie on clie.clie_id = clim.clie_id "
					+ " where cecc.cecc_id = :idComando "
					+ "   and osun.attp_id = 1 "
					+ "   and clim.crtp_id = 2 "
					+ "   and clim.clim_dtrelacaofim is null "
					+ "   and orse.orse_cdsituacao = 1 "
					+ "   and orse.orse_id not in (select eccc.orse_id from cobranca.empresa_cobranca_conta eccc where cecc.cecc_id = eccc.cecc_id) ";

			if (idTipoServico != null
					&& idTipoServico.compareTo(new Integer(-1)) != 0) {
				consulta += "   and orse.svtp_id = " + idTipoServico;
			}

			consulta = consulta
					+ " group by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente "
					+ " order by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("servicoTipo", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * Emitir OS de Registro de Atendimento
	 * 
	 * @author Mariana Victor
	 * @data 18/05/2011
	 */
	public Collection<Object[]> pesquisarDadosOSRegistroAtendimento(
			Integer idComando, Integer idTipoServico)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select distinct(orse.orse_id) as idOS, svtp.svtp_dsservicotipo as servicoTipo, orse.imov_id as idImovel, clie.clie_nmcliente as nomeCliente "
					+ " from cobranca.cmd_empr_cobr_conta cecc "
					+ "   inner join cadastro.unidade_organizacional unid on unid.empr_id = cecc.empr_id "
					+ "   inner join atendimentopublico.tramite tram on tram.unid_iddestino = unid.unid_id "
					+ "   inner join atendimentopublico.ordem_servico orse on tram.rgat_id = orse.rgat_id "
					+ "   inner join atendimentopublico.servico_tipo svtp on svtp.svtp_id = orse.svtp_id "
					+ "   inner join cadastro.cliente_imovel clim on clim.imov_id = orse.imov_id "
					+ "   inner join cadastro.cliente clie on clie.clie_id = clim.clie_id "
					+ " where cecc.cecc_id = :idComando "
					+ "   and clim.crtp_id = 2 "
					+ "   and clim.clim_dtrelacaofim is null "
					+ "   and orse.orse_cdsituacao = 1 ";

			if (idTipoServico != null
					&& idTipoServico.compareTo(new Integer(-1)) != 0) {
				consulta += "   and orse.svtp_id = " + idTipoServico;
			}

			consulta = consulta
					+ " group by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente "
					+ " order by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("servicoTipo", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * obtem contas em débito do imóvel, comparando a data de vencimento
	 * original usado no emitir contas da CAEMA
	 * 
	 * Author: Vivianne Sousa Data: 15/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImovelDataVencimentoOriginal(
			Integer idImovel, int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id = :idImovel "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentooriginal between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal",
							new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada",
							new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida",
							new Integer(contaSituacaoIncluida))
					.setInteger("inicialReferencia",
							new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia",
							new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
					.setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobrança
	 * 
	 * Consulta chamada pelo "[FS0006 - Validar Comando]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public ComandoEmpresaCobrancaConta pesquisarComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {

		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = null;
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT empr_id AS idEmpresa, " // 0
					+ "    cecc_dtencerramento AS dataEncerramento, " // 1
					+ "    cecc_icgeracaotxt AS icGeracaoArqTxt " // 2
					+ "  FROM cobranca.cmd_empr_cobr_conta "
					+ "  WHERE cecc_id = :idComando ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("icGeracaoArqTxt", Hibernate.INTEGER)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (retorno != null) {
			comandoEmpresaCobrancaConta = new ComandoEmpresaCobrancaConta();

			comandoEmpresaCobrancaConta.setId(idComando);

			if (retorno[0] != null) {
				Empresa empresa = new Empresa();
				empresa.setId((Integer) retorno[0]);

				comandoEmpresaCobrancaConta.setEmpresa(empresa);
			}

			if (retorno[1] != null) {
				comandoEmpresaCobrancaConta
						.setDataEncerramento((Date) retorno[1]);
			}

			if (retorno[2] != null) {
				comandoEmpresaCobrancaConta
						.setIndicadorGeracaoTxt((Integer) retorno[2]);
			}

		}

		return comandoEmpresaCobrancaConta;

	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobrança
	 * 
	 * Consulta chamada pelo "[FS0007 - Validar OS]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public Short pesquisarSituacaoOrdemServico(Integer numeroOS)
			throws ErroRepositorioException {

		Short retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT orse_cdsituacao AS situacao " // 0
					+ "  FROM atendimentopublico.ordem_servico "
					+ "  WHERE orse_id = :numeroOS ";

			retorno = (Short) session.createSQLQuery(consulta)
					.addScalar("situacao", Hibernate.SHORT)
					.setInteger("numeroOS", numeroOS).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobrança
	 * 
	 * Consulta chamada pelo "[FS0007 - Validar OS]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public Boolean verificarOrdemServicoComando(Integer numeroOS,
			Integer idComando) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(*) AS quantidade " // 0
					+ "  FROM cobranca.empresa_cobranca_conta "
					+ "  WHERE cecc_id = :idComando "
					+ "    AND orse_id = :numeroOS ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("numeroOS", numeroOS).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (retorno != null && retorno.compareTo(new Integer(0)) > 0) {
			return true;
		}

		return false;

	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * @author Paulo Diniz
	 * @throws ErroRepositorioException
	 * @data 30/06/2011
	 */
	public List<Object[]> pesquisarOrdensServicoContasPagasParceladas()
			throws ErroRepositorioException {
		List<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select orse.orse_id as orse_id, cecc.cecc_id as cecc_id  "
					+ "from COBRANCA.cmd_empr_cobr_conta cecc "
					+ "inner join COBRANCA.empresa_cobranca_conta ecco on ecco.cecc_id = cecc.cecc_id  "
					+ "inner join ATENDIMENTOPUBLICO.ordem_servico orse on ecco.orse_id = orse.orse_id "
					+ "inner join CADASTRO.imovel imov on orse.imov_id = imov.imov_id "
					+ "inner join FATURAMENTO.conta cnta on cnta.cnta_id = ecco.cnta_id "
					+ "where cecc.cecc_dtexecucao is not null and cecc.cecc_dtencerramento is null and cecc.cecc_icgeracaotxt = 1  and ( "
					+ "exists (select pgmt.cnta_id from arrecadacao.pagamento pgmt  "
					+ "where pgmt.cnta_id=ecco.cnta_id)"
					+ " or exists (select pghi.cnta_id from arrecadacao.pagamento_historico pghi"
					+ " where pghi.cnta_id=ecco.cnta_id) "
					+ " or cnta.dcst_idatual = 5"
					+ " or exists (select cnhi.cnta_id from FATURAMENTO.conta_historico cnhi "
					+ "where cnhi.cnta_id=ecco.cnta_id and cnhi.dcst_idatual = 5 )"
					+ ") group by orse.orse_id,  cecc.cecc_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("orse_id", Hibernate.INTEGER)
					.addScalar("cecc_id", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1186] Gerar Relatório Ordem de Serviço Cobrança p/Resultado
	 * 
	 * Pesquisar EmpresaCobrancaConta a partir do imóvel
	 * 
	 * @author Hugo Azevedo
	 * @data 02/07/2011
	 */

	public Collection obterColecaoEmpresaCobrancaContaResultadoporImovel(
			Integer id, Integer tipoServico) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select distinct emprc.ordemServico  "
					+ "from EmpresaCobrancaConta emprc, OrdemServico ordemServico "
					+ "inner join fetch emprc.comandoEmpresaCobrancaConta "
					+ "inner join fetch ordemServico.servicoTipo "
					+ "inner join fetch ordemServico.atendimentoMotivoEncerramento "
					+ "where emprc.ordemServico.id = ordemServico.id and emprc.imovel.id = :imovelId and ";
			if (tipoServico != null && tipoServico.intValue() != -1) {
				consulta += "emprc.ordemServico.servicoTipo.id = "
						+ tipoServico;
			}
			consulta += "ordemServico.dataGeracao >= emprc.comandoEmpresaCobrancaConta.dataExecucao "
					+ "and emprc.ordemServico.dataGeracao <= emprc.comandoEmpresaCobrancaConta.dataEncerramento "
					+ "and emprc.comandoEmpresaCobrancaConta.dataExecucao is not null "
					+ "and emprc.comandoEmpresaCobrancaConta.dataEncerramento is not null ";

			consulta += "union select distinct emprc.ordemServico "
					+ "from EmpresaCobrancaConta emprc , OrdemServico ordemServico "
					+ "inner join fetch emprc.comandoEmpresaCobrancaConta "
					+ "inner join fetch ordemServico.servicoTipo "
					+ "inner join fetch ordemServico.atendimentoMotivoEncerramento "
					+ "where emprc.ordemServico.id = ordemServico.id and emprc.imovel.id = :imovelId and ";
			if (tipoServico != null && tipoServico.intValue() != -1) {
				consulta += "emprc.ordemServico.servicoTipo.id = "
						+ tipoServico;
			}
			consulta += "ordemServico.dataGeracao >= emprc.comandoEmpresaCobrancaConta.dataExecucao "
					+ "and emprc.comandoEmpresaCobrancaConta.dataExecucao is not null "
					+ "and emprc.comandoEmpresaCobrancaConta.dataEncerramento is null";

			retorno = session.createQuery(consulta).setInteger("imovelId", id)
					.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 * */
	public Collection<Object[]> pesquisarEmpresasComandosCobrancaAtivosExecutados()
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct cecc.empr_id AS idEmpresa, empr.empr_dsemail AS emailEmpresa "
					+ "  FROM cobranca.cmd_empr_cobr_conta cecc "
					+ "    INNER JOIN cadastro.empresa empr ON empr.empr_id = cecc.empr_id "
					+ "  WHERE cecc.cecc_dtexecucao is not null "
					+ "    AND cecc.cecc_dtencerramento is null "
					+ "    AND cecc.cecc_icgeracaotxt = 1 ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("emailEmpresa", Hibernate.STRING).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2. O sistema deverá verificar todos os comandos de cobrança por
	 * resultados ativos e executados
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Collection<Integer> pesquisarComandosCobrancaAtivosExecutados(
			Integer idEmpresa) throws ErroRepositorioException {

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cecc.cecc_id AS idComando "
					+ "   FROM cobranca.cmd_empr_cobr_conta cecc "
					+ " WHERE cecc.cecc_dtexecucao is not null "
					+ "   AND cecc.cecc_dtencerramento is null "
					+ "   AND cecc.cecc_icgeracaotxt = 1 "
					+ "   AND cecc.empr_id = :idEmpresa ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idComando", Hibernate.INTEGER)
					.setInteger("idEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2.1. Para cada comando selecionado o sistema deverá selecionar os ordens
	 * de serviço ativas associadas ao mesmo
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Collection<Object[]> pesquisarOrdensServicoAtivasComando(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct orse.orse_id AS idOS, ecco.imov_id AS idImovel "
					+ "  FROM ATENDIMENTOPUBLICO.ordem_servico orse "
					+ "    INNER JOIN cobranca.empresa_cobranca_conta ecco ON ecco.orse_id = orse.orse_id "
					+ "  WHERE ecco.cecc_id = :idComando "
					+ "    AND orse.orse_cdsituacao = 1 ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", idComando).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2.1.1. Para cada Ordem de Serviço selecionada, o sistema deverá verificar
	 * se as contas associadas ao imóvel da ordem de serviço estão quitadas ou
	 * parceladas
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Boolean verificarExisteContasEmAberto(Integer idOS)
			throws ErroRepositorioException {

		Boolean retorno = null;
		Integer dados = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(ecco.cnta_id) AS quantidadeConta "
					+ "  FROM cobranca.empresa_cobranca_conta ecco "
					+ "  WHERE ecco.orse_id = :idOS "
					// + "  AND ecco.ecco_cdincluido is null "
					+ "  AND ( NOT EXISTS (SELECT pgmt.cnta_id FROM arrecadacao.pagamento pgmt WHERE pgmt.cnta_id = ecco.cnta_id) "
					+ "  AND NOT EXISTS (SELECT pghi.cnta_id FROM arrecadacao.pagamento_historico pghi WHERE pghi.cnta_id = ecco.cnta_id) "
					+ "  AND NOT EXISTS (SELECT cnta.cnta_id FROM faturamento.conta cnta WHERE cnta.cnta_id = ecco.cnta_id AND cnta.dcst_idatual = 5) "
					+ "  AND NOT EXISTS (SELECT cntahi.cnta_id FROM faturamento.conta_historico cntahi WHERE cntahi.cnta_id = ecco.cnta_id AND cntahi.dcst_idatual = 5)) ";

			dados = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidadeConta", Hibernate.INTEGER)
					.setInteger("idOS", idOS).setMaxResults(1).uniqueResult();

			if (dados == null || dados.compareTo(new Integer(0)) == 0) {
				retorno = false;
			} else {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param idDebitoACobrar
	 * 
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean verificaDebitoACobrarVinculadoAContratoParcelAtivo(
			Integer idDebitoACobrar) throws ErroRepositorioException {

		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeDebitosACobrar = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from cobranca.contrato_parcel_item item "
					+ "inner join cobranca.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.dbac_id = :idDebitoACobrar and cpar.pcst_id = "
					+ ParcelamentoSituacao.NORMAL;

			quantidadeDebitosACobrar = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

			if (quantidadeDebitosACobrar != null
					&& quantidadeDebitosACobrar > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0020] - Processar Pagamento de Contrato Parcelamento
	 * 
	 * @author Mariana Victor
	 * @data 03/08/2011
	 */
	public Object[] obterDadosDocumentoCobrancaItemContratoParcelamento(
			Integer idPrestacao) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cdit.cdit_vlitemcobrado AS valorItem, "
					+ "   cppr.cppr_nnprestacao AS numeroPrestacao, "
					+ "   cppr.cpar_id AS idContrato "
					+ " FROM cobranca.cobranca_documento_item cdit "
					+ "   INNER JOIN cobranca.contrato_parcel_prest cppr ON cppr.cppr_id = cdit.cppr_id "
					+ " WHERE cdit.cppr_id = :idPrestacao ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacao", Hibernate.INTEGER)
					.addScalar("idContrato", Hibernate.INTEGER)
					.setInteger("idPrestacao", idPrestacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1167] Consultar Comandos de Cobrança por Empresa Pesquisa dados do
	 * popup
	 * 
	 * @author Hugo Azevedo
	 * @date 25/08/2011
	 */

	public Collection pesquisarDadosPopupExtensaoComandoAguaSituacao(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT las.last_id AS id,"
					+ " las.last_dsligacaoaguasituacao as descricao "
					+ " from cobranca.cmd_empr_cobr_conta_last cecc "
					+ " inner join atendimentopublico.ligacao_agua_situacao las on cecc.last_id = las.last_id "
					+ " where cecc.cecc_id = :idComando";

			retorno = session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.setInteger("idComando", idComando).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 0869] Gerar Arqv Texto das Contas em Cobrança por Empresa
	 * 
	 * @author Paulo Diniz
	 * @data 03/08/2011
	 * 
	 */
	public Object[] pesquisarDadosQtdContasEDiasVencidos(Integer idComando)
			throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cecc.CECC_QTDCONTASINICIAL AS qtdContasInicial, "
					+ "   cecc.CECC_QTDCONTASINICIAL AS qtdContasFinal, "
					+ "   cecc.CECC_QTDDIASVENCIMENTO AS qtdDiasVencidos, "
					+ "   last.last_id AS ligacaoId, "
					+ "   last.last_dsligacaoaguasituacao AS ligacaoNome "
					+ " FROM cobranca.cmd_empr_cobr_conta cecc "
					+ " left join atendimentopublico.ligacao_agua_situacao last on last.last_id = cecc.last_id "
					+ " WHERE cecc.cecc_id = :idComando ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("qtdContasInicial", Hibernate.INTEGER)
					.addScalar("qtdContasFinal", Hibernate.INTEGER)
					.addScalar("qtdDiasVencidos", Hibernate.INTEGER)
					.addScalar("ligacaoId", Hibernate.INTEGER)
					.addScalar("ligacaoNome", Hibernate.STRING)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0869] Gerar Arqv Texto das Contas em Cobrança por Empresa
	 * 
	 * @author Paulo Diniz
	 * @data 03/08/2011
	 * 
	 */
	public Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao> pesquisarColecaoLigacaoAguaSituacaoPorComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao> retorno = null;
		String consulta;

		try {
			consulta = "select \n "
					+ "	comandoLigacao \n "
					+ "from \n "
					+ "   CmdEmpresaCobrancaContaLigacaoAguaSituacao comandoLigacao \n "
					+ "   inner join fetch comandoLigacao.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta \n "
					+ "   inner join fetch comandoLigacao.ligacaoAguaSituacao ligacaoAguaSituacao \n "
					+ "where comandoEmpresaCobrancaConta.id = :idComando";

			retorno = (Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao>) session
					.createQuery(consulta).setInteger("idComando", idComando)
					.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @author Raphael Rossiter
	 * @date 19/09/2011
	 * 
	 * @param idImovel
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short obterIndicadorAcrescimosClienteResponsavel(Integer idImovel)
			throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select cli.indicadorAcrescimos from ClienteImovel cliImo "
					+ "inner join cliImo.clienteRelacaoTipo crt "
					+ "inner join cliImo.cliente cli "
					+ "inner join cliImo.imovel imo "
					+ "where imo.id = :idImovel AND "
					+ "crt.id = :idResponsavel AND "
					+ "cliImo.dataFimRelacao is null ";
			retorno = (Short) session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Obter Débito do Imóvel ou Cliente
	 * 
	 * @author Raphael Rossiter
	 * @date 19/09/2011
	 * 
	 * @param idImovel
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short obterIndicadorAcrescimosCliente(Integer idCliente)
			throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select clie.indicadorAcrescimos from Cliente clie "
					+ "where clie.id = :idCliente ";

			retorno = (Short) session.createQuery(consulta)
					.setInteger("idCliente", idCliente).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC1233] - Encerrar Ordem de Servico de Visita de Cobrança
	 * 
	 * @author Hugo Azevedo
	 * @date 23/09/2011
	 */
	public Collection<Integer> obterColecaoOrdemServicoVisitaCobranca(
			String idGrupo, String mesAno) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String sql = "";
		Collection<Integer> retorno = new ArrayList<Integer>();

		try {
			sql = " select os.orse_id"
					+ " from atendimentopublico.ordem_servico os "
					+ " inner join cobranca.cobranca_documento cobdoc on cobdoc.cbdo_id = os.cbdo_id"
					+ " inner join cobranca.cobranca_acao_ativ_crg cobaar on cobaar.caac_id = cobdoc.caac_id"
					+ " inner join cobranca.cobranca_acao_cronograma cac on cac.cbcr_id = cobaar.cbcr_id"
					+ " inner join cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbcm_id = cac.cbcm_id"
					+ " where cgcm.cbgr_id = :idGrupo"
					+ " and cgcm.cbcm_amreferencia = :mesAno"
					+ " and os.orse_cdsituacao = :situacao";

			retorno = session.createSQLQuery(sql)
					.addScalar("orse_id", Hibernate.INTEGER)
					.setInteger("idGrupo", new Integer(idGrupo))
					.setInteger("mesAno", new Integer(mesAno))
					.setInteger("situacao", OrdemServico.SITUACAO_PENDENTE)
					.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer pesquisarQuantidadeImoveisPorGrupoCobrancaAgrupadosTitulo(
			Integer gerencia, Integer unidade, Integer localidade,
			Integer setorComercial, Integer quadra)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;
		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis"
					+ " FROM cadastro.imovel i"
					+ " join cobranca.imovel_nao_gerado ing on ing.imov_id = i.imov_id"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
					+ " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id"
					+ " where i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session.createSQLQuery(query)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança
	 * 
	 * Metodo que pesquisa contas canceladas associadas a comandos de cobrança
	 * no mes de arrecadação
	 * 
	 * @author Raimundo Martins
	 * @date 03/10/2011
	 * 
	 */
	public Collection<Object[]> pesquisarContasCanceladasMesAssocComandosCobranca(
			Integer anoMesArrecadacao, Integer debitoCreditoSituacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT ecco.ecco_id, "
					+ "  cnta.cmcn_id, "
					+ "  cnta.cnta_dtcancelamento, "
					+ "  CASE "
					+ "    WHEN cnta.cnta_vlimpostos IS NULL "
					+ "    THEN ((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - cnta.cnta_vlcreditos) "
					+ "    WHEN ((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos - cnta.cnta_vlimpostos)) IS NULL "
					+ "    THEN 0 "
					+ "    ELSE ((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos - cnta.cnta_vlimpostos)) "
					+ "  END AS valorContaCancelada, "
					+ "  cnta.imov_id "
					+ "FROM FATURAMENTO.conta cnta "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON ecco.cnta_id                                  = cnta.cnta_id "
					+ "WHERE TO_CHAR(cnta.cnta_dtcancelamento,'YYYYMM') = :anoMesArrecadacao "
					+ "AND cnta.dcst_idatual                            = :debitoCreditoSituacao ";

			return session
					.createSQLQuery(sql)
					.addScalar("ecco_id", Hibernate.INTEGER)
					.addScalar("cmcn_id", Hibernate.INTEGER)
					.addScalar("valorContaCancelada", Hibernate.BIG_DECIMAL)
					.addScalar("imov_id", Hibernate.INTEGER)
					.addScalar("cnta_dtcancelamento", Hibernate.DATE)
					.setString("anoMesArrecadacao",
							anoMesArrecadacao.toString())
					.setInteger("debitoCreditoSituacao", debitoCreditoSituacao)
					.list();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Empresa> obterColecaoEmpresasContratadasCobranca()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Empresa> colecaoEmpresa = new ArrayList<Empresa>();

		try {
			colecaoEmpresa = session
					.createCriteria(Empresa.class)
					.add(Restrictions.eq("indicadorUso",
							ConstantesSistema.INDICADOR_USO_ATIVO))
					.add(Restrictions.eq("indicadorEmpresaContratadaCobranca",
							ConstantesSistema.INDICADOR_USO_ATIVO)).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoEmpresa;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Regiao> obterColecaoRegioes()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Regiao> colecaoRegiao = new ArrayList<Regiao>();

		try {
			colecaoRegiao = session
					.createCriteria(Regiao.class)
					.add(Restrictions.eq("indicadorUso",
							ConstantesSistema.INDICADOR_USO_ATIVO))
					.addOrder(Order.asc("nome")).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return colecaoRegiao;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */

	public Collection<Microrregiao> obterColecaoMicroRegioes(String[] idsRegiao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Microrregiao> colecaoMicroRegiao = new ArrayList<Microrregiao>();
		String hql = "";

		try {
			hql = " select mr " + " from Microrregiao mr "
					+ " inner join mr.regiao r"
					+ " where mr.indicadorUso = :indicador";

			if (idsRegiao != null)
				hql += " and r.id in (:idsRegiao)";

			hql += " order by mr.nome";

			Query q = session.createQuery(hql).setInteger("indicador",
					ConstantesSistema.INDICADOR_USO_ATIVO);
			if (idsRegiao != null)
				q.setParameterList("idsRegiao", idsRegiao);

			colecaoMicroRegiao = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoMicroRegiao;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Municipio> obterColecaoMunicipios(String[] idsRegiao,
			String[] idsMicroRegiao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Municipio> colecaoMunicipio = new ArrayList<Municipio>();
		String hql = "";

		try {
			hql = " select m " + " from Municipio m "
					+ " inner join m.microrregiao mr"
					+ " inner join mr.regiao r"
					+ " where m.indicadorUso = :indicador";

			if (idsRegiao != null)
				hql += " and r.id in (:idsRegiao)";
			if (idsMicroRegiao != null)
				hql += " and mr.id in (:idsMicroRegiao)";

			hql += " order by m.nome ASC";

			Query q = session.createQuery(hql).setInteger("indicador",
					ConstantesSistema.INDICADOR_USO_ATIVO);
			if (idsRegiao != null)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);

			colecaoMunicipio = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoMunicipio;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<UnidadeNegocio> obterColecaoUnidadeNegocio(
			String[] idsGerencias) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String hql = "";
		Collection<UnidadeNegocio> retorno = new ArrayList<UnidadeNegocio>();

		try {
			hql = "select un " + " from UnidadeNegocio un "
					+ " inner join un.gerenciaRegional gr "
					+ " where un.indicadorUso = :indicador ";

			if (idsGerencias != null)
				hql += " and gr.id in (:idsGerencia)";

			hql += " order by un.nome";

			Query q = session.createQuery(hql).setInteger("indicador",
					ConstantesSistema.INDICADOR_USO_ATIVO);
			if (idsGerencias != null)
				q.setParameterList("idsGerencia", idsGerencias);

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Localidade> obterColecaoLocalidade(Integer idLocalidade,
			String[] idsGerencias, String[] idsUnidadeNegocio)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String hql = "";
		Collection<Localidade> retorno = new ArrayList<Localidade>();

		try {

			hql = " select l " + " from Localidade l "
					+ " inner join l.unidadeNegocio un"
					+ " inner join l.gerenciaRegional gr"
					+ " where l.indicadorUso = :indicador "
					+ " and l.id = :idLocalidade";

			if (idsGerencias != null)
				hql += " and gr.id in (:idsGerencia) ";
			if (idsUnidadeNegocio != null)
				hql += " and un.id in (:idsUnidadeNegocio) ";

			Query q = session
					.createQuery(hql)
					.setInteger("indicador",
							ConstantesSistema.INDICADOR_USO_ATIVO)
					.setInteger("idLocalidade", idLocalidade);
			if (idsGerencias != null)
				q.setParameterList("idsGerencia", idsGerencias);
			if (idsUnidadeNegocio != null)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0001]
	 * - Emitir Relatório de Boletim de Medição - Recuperação de Créditos
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoGeralResumido(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " SELECT GREG.GREG_ID       AS idGerenciaRegional, " + // 0
					" ECBM.LOCA_ID              AS idLocalidade, " + // 1
					" emcf.emcf_id              AS idFaixaContas, " + // 2
					" re.regi_id                AS idRegiao, " + // 3
					" loca.muni_idprincipal     AS idMunicipio, " + // 4
					" empr.empr_nmempresa       AS nomeEmpresa, " + // 5
					" ces.cese_dsnumerocontrato AS numeroContrato, " + // 6
					" ecbm.ecbm_amreferencia    AS anoMesRef, " + // 7
					" loca.loca_nmlocalidade    AS nomeLocalidade, " + // 8
					" mun.muni_nmmunicipio      AS nomeMunicipio, " + // 9
					" emcf.emcf_dsfaixa         AS descricaoFaixaContas,"; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			String sql2 = " (select sum(count( DISTINCT ecco2.imov_id))  "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2  "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    group by ecco2.imov_id  " + "    having   ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

					sql2 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))  " + "  as qtdFaturasNegociadas, "; // 11

					sql2 += "  count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))   " + "  as contadorImoveis,"; // 12
				}

			}

			sql += sql1 + sql2;

			sql += " sum(ecbm.ecbm_vlcontaspagtoavista) as pagtoAVista, "
					+ // 13
					" sum(ecbm.ecbm_vlcontaspagtoparcelado) as pagtoParcelado, "
					+ // 14
					" emcf.emcf_pcfaixa as percentualFaixa,"
					+ // 15
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 16
					" re.REGI_NMREGIAO as regiao, "
					+ // 17
					" ecbm.ecbm_vldescontos as valorDesconto "
					+ // 18

					" FROM COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (CECC.cecc_ID = ECBM.cecc_ID) "
					+ " left JOIN CADASTRO.empresa EMPR ON (EMPR.EMPR_ID = CECC.EMPR_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_ID =ECBM.emcf_ID ) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id"
					+

					" WHERE empr.empr_id            = :idEmpresa "
					+ " AND ecbm.ecbm_amreferencia    = :anoMesReferencia "
					+ " AND EMPR.EMPR_ICUSO           = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA      = 1 "
					+ " AND GREG.GREG_ICUSO           = 1 ";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY GREG.GREG_ID," + " ECBM.LOCA_ID,"
					+ " emcf.emcf_id," + " re.regi_id,"
					+ " loca.muni_idprincipal," + " empr.empr_nmempresa,"
					+ " ces.cese_dsnumerocontrato,"
					+ " ecbm.ecbm_amreferencia," + " loca.loca_nmlocalidade,"
					+ " mun.muni_nmmunicipio," + " emcf.emcf_dsfaixa,"
					+ " emcf.emcf_pcfaixa," + " ecbm.cecc_id,"
					+ " greg.GREG_NMREGIONAL," + " re.REGI_NMREGIAO,"
					+ " ecbm.ecbm_vldescontos ";

			// 4.1. Caso informada a Opção do Boletim=Geral e Opção do
			// Relatório=Resumido
			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade, idFaixaContas";
			else
				sql += " order by regiao, nomeMunicipio, idFaixaContas";

			Query q = session.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("contadorImoveis", Hibernate.INTEGER)
					// 12
					.addScalar("pagtoAVista", Hibernate.BIG_DECIMAL)
					// 13
					.addScalar("pagtoParcelado", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("percentualFaixa", Hibernate.BIG_DECIMAL)
					// 15
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 16
					.addScalar("regiao", Hibernate.STRING)
					// 17
					.addScalar("valorDesconto", Hibernate.BIG_DECIMAL)
					// 18
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao));

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0003]
	 * - Emitir Relatório de Boletim de Medição - Recuperação de Créditos
	 * Parcelados
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoResumidoParcelamento(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " SELECT GREG.GREG_ID       AS idGerenciaRegional, " + // 0
					" ECBM.LOCA_ID              AS idLocalidade, " + // 1
					" emcf.emcf_id              AS idFaixaContas, " + // 2
					" re.regi_id                AS idRegiao, " + // 3
					" loca.muni_idprincipal     AS idMunicipio, " + // 4
					" empr.empr_nmempresa       AS nomeEmpresa, " + // 5
					" ces.cese_dsnumerocontrato AS numeroContrato, " + // 6
					" ecbm.ecbm_amreferencia    AS anoMesRef, " + // 7
					" loca.loca_nmlocalidade    AS nomeLocalidade, " + // 8
					" mun.muni_nmmunicipio      AS nomeMunicipio, " + // 9
					" emcf.emcf_dsfaixa         AS descricaoFaixaContas,"; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.imov_id = eccp.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			String sql2 = " (select sum(count( DISTINCT ecco2.imov_id))  "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2  "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.imov_id = eccp.imov_id "
					+ "    group by ecco2.imov_id  " + "    having   ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

					sql2 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))  " + "  as qtdFaturasNegociadas, "; // 11

					sql2 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))   " + "  as contadorImoveis,"; // 12
				}

			}

			sql += sql1 + sql2;

			sql += "SUM(ecbm.ecbm_vlcontaspagtoavista) AS pagtoAVista, "
					+ // 13
					"	(select sum(ecbm2.ecbm_vlcontaspagtoparcelado) "
					+ "	  from COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM2 "
					+ "	  where ecbm2.cecc_id = ecbm.cecc_id "
					+ "     and ecbm2.imov_id = eccp.imov_id) as pagtoParcelado, "
					+ // 14
					"	emcf.emcf_pcfaixa  AS percentualFaixa, "
					+ // 15
					"	(select sum(ecco2.ecco_vloriginalconta) "
					+ "	  from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "	  where ecco2.cecc_id = ecbm.cecc_id "
					+ "     and ecco2.imov_id = eccp.imov_id) as ValorNeg, "
					+ // 16

					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 17
					" re.REGI_NMREGIAO as regiao "
					+ // 18"

					" FROM  COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (ECBM.CECC_ID = CECC.CECC_ID) "
					+ " INNER JOIN CADASTRO.empresa EMPR  ON (CECC.EMPR_ID = EMPR.EMPR_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " inner join COBRANCA.empresa_cobranca_conta ecco on (ecco.CECC_ID = cecc.cecc_id and ecbm.imov_id = ecco.imov_id) "
					+ " inner join COBRANCA.empr_cobr_conta_pagto eccp on (eccp.imov_id = ecco.imov_id and ecco.ecco_id = eccp.ecco_id) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id ";

			sql += " WHERE empr.empr_id            = :idEmpresa "
					+ " AND ecbm.ecbm_amreferencia    = :anoMesReferencia "
					+ " AND  EMPR.EMPR_ICUSO = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA = 1 "
					+ " AND GREG.GREG_ICUSO = 1 "
					+ " AND  eccp.eccp_ictipopagamento = 2";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY GREG.GREG_ID, " + "  ECBM.LOCA_ID, "
					+ "  emcf.emcf_id, " + "  re.regi_id, "
					+ "  loca.muni_idprincipal, " + "  empr.empr_nmempresa, "
					+ "  ces.cese_dsnumerocontrato, "
					+ "  ecbm.ecbm_amreferencia, "
					+ "  loca.loca_nmlocalidade, " + "  mun.muni_nmmunicipio, "
					+ "  emcf.emcf_dsfaixa, " + "  emcf.emcf_pcfaixa, "
					+ "  ecbm.cecc_id," + " greg.GREG_NMREGIONAL,"
					+ " re.REGI_NMREGIAO," + " eccp.imov_id";

			// 4.3. Caso informada a Opção do Boletim=Parcelamento e Opção do
			// Relatório=Resumido,
			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade, idFaixaContas";
			else
				sql += " order by regiao, nomeMunicipio, idFaixaContas";

			Query q = session.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("contadorImoveis", Hibernate.INTEGER)
					// 12
					.addScalar("pagtoAVista", Hibernate.BIG_DECIMAL)
					// 13
					.addScalar("pagtoParcelado", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("percentualFaixa", Hibernate.BIG_DECIMAL)
					// 15
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 16
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 17
					.addScalar("regiao", Hibernate.STRING)
					// 18
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao));

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0002]
	 * - Emitir Relatório de Acompanhamento dos Créditos Pagos à Vista
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoGeralAnalitico(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " select GREG.GREG_ID as idGerenciaRegional, " + // 0
					"	ECBM.LOCA_ID as idLocalidade, " + // 1
					"	emcf.emcf_id as idFaixaContas, " + // 2
					"	re.regi_id as idRegiao, " + // 3
					"	loca.muni_idprincipal as idMunicipio, " + // 4
					"	empr.empr_nmempresa as nomeEmpresa, " + // 5
					"	ces.cese_dsnumerocontrato as numeroContrato, " + // 6
					"	ecbm.ecbm_amreferencia as anoMesRef, " + // 7
					"	loca.loca_nmlocalidade as nomeLocalidade, " + // 8
					"	mun.muni_nmmunicipio as nomeMunicipio, " + // 9
					"	emcf.emcf_dsfaixa as descricaoFaixaContas, "; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    AND ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			String sql2 = " (select sum(count( DISTINCT ecco2.imov_id))  "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2  "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    AND ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id  " + "    having   ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

					sql2 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))  " + "  as qtdFaturasNegociadas, "; // 11

					sql2 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))   " + "  as contadorImoveis,"; // 12
				}

			}

			sql += sql1 + sql2;

			sql += " ecbm.ecbm_vlcontaspagtoavista as pagtoAVista,"
					+ // 13
					" ecbm.ecbm_vlcontaspagtoparcelado as pagtoParcelado,"
					+ // 14
					" emcf.emcf_pcfaixa as percentualFaixa,"
					+ // 15
					" cli.clie_nmcliente as clienteNome,"
					+ // 16
					" ecbm.imov_id as idImovel, "
					+ // 17
					" sum(ecco.ecco_vloriginalconta) as ValorNeg,"
					+ // 18
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 19
					" re.REGI_NMREGIAO as regiao, "
					+ // 20
					" ecbm.ecbm_vldescontos as valorDesconto "
					+ // 21
					" from cobranca.EMPR_COBR_CONTA_BOL_MED ecbm  "
					+ " left join COBRANCA.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecbm.cecc_id   "
					+ " left join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " left join COBRANCA.empresa_cobranca_conta ecco on (ecco.CECC_ID = cecc.cecc_id and ecbm.imov_id = ecco.imov_id) "
					+ " inner join CADASTRO.empresa empr on cecc.empr_id = empr.empr_id  "
					+ " inner join CADASTRO.localidade loca on loca.loca_id = ecbm.loca_id  "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " inner join CADASTRO.municipio mun on mun.muni_id = loca.muni_idprincipal   "
					+ " inner join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id   "
					+ " inner join CADASTRO.regiao re on re.regi_id = mr.regi_id   "
					+ " inner join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id  "
					+ " inner join CADASTRO.cliente_imovel cliim on ecbm.imov_id = cliim.imov_id "
					+ " inner join CADASTRO.cliente cli on cliim.clie_id = cli.clie_id "
					+ " where empr.empr_id = :idEmpresa "
					+ " and ecbm.ecbm_amreferencia = :anoMesReferencia "
					+ " and cliim.clim_dtrelacaofim is null "
					+ " and cliim.crtp_id = :clienteTipo "
					+ " and ecbm.ecbm_vlcontaspagtoavista is not null "
					+ " and ecbm.ecbm_vlcontaspagtoavista <> 0 "
					+ " and EMPR.EMPR_ICUSO = 1 "
					+ " and EMPR.EMPR_ICCOBRANCA = 1 "
					+ " and GREG.GREG_ICUSO = 1";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY GREG.GREG_ID, ECBM.LOCA_ID, emcf.emcf_id, re.regi_id,loca.muni_idprincipal,"
					+ " empr.empr_nmempresa, ces.cese_dsnumerocontrato,ecbm.ecbm_amreferencia,"
					+ " loca.loca_nmlocalidade,ecbm.ecbm_vlcontaspagtoavista,ecbm.ecbm_vlcontaspagtoparcelado,"
					+ " mun.muni_nmmunicipio, emcf.emcf_dsfaixa, emcf.emcf_pcfaixa,cli.clie_nmcliente,ecbm.imov_id,ecbm.cecc_id,greg.GREG_NMREGIONAL,re.REGI_NMREGIAO,ecbm.ecbm_vldescontos";

			// 4.2. Caso informada a Opção do Boletim=Geral e Opção do
			// Relatório=Analítico,
			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade, idFaixaContas, idImovel";
			else
				sql += " order by regiao, nomeMunicipio,idFaixaContas, idImovel";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("contadorImoveis", Hibernate.INTEGER)
					// 12
					.addScalar("pagtoAVista", Hibernate.BIG_DECIMAL)
					// 13
					.addScalar("pagtoParcelado", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("percentualFaixa", Hibernate.BIG_DECIMAL)
					// 15
					.addScalar("clienteNome", Hibernate.STRING)
					// 16
					.addScalar("idImovel", Hibernate.INTEGER)
					// 17
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 18
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 19
					.addScalar("regiao", Hibernate.STRING)
					// 20
					.addScalar("valorDesconto", Hibernate.BIG_DECIMAL)
					// 21
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao))
					.setInteger("clienteTipo", ClienteRelacaoTipo.USUARIO);

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0004]
	 * - Emitir Relatório de Acompanhamento dos Parcelamentos - Recuperação de
	 * Créditos
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoParcAnalitico(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " select GREG.GREG_ID as idGerenciaRegional, " + // 0
					"	ECBM.LOCA_ID as idLocalidade, " + // 1
					"	emcf.emcf_id as idFaixaContas, " + // 2
					"	re.regi_id as idRegiao, " + // 3
					"	loca.muni_idprincipal as idMunicipio, " + // 4
					"	empr.empr_nmempresa as nomeEmpresa, " + // 5
					"	ces.cese_dsnumerocontrato as numeroContrato, " + // 6
					"	ecbm.ecbm_amreferencia as anoMesRef, " + // 7
					"	loca.loca_nmlocalidade as nomeLocalidade, " + // 8
					"	mun.muni_nmmunicipio as nomeMunicipio, " + // 9
					"	emcf.emcf_dsfaixa as descricaoFaixaContas, "; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))  " + "  as qtdFaturasNegociadas, "; // 11
				}

			}

			sql += sql1;

			sql += " (select sum(ecco2.ecco_vloriginalconta) "
					+ " 		from COBRANCA.empresa_cobranca_conta ecco2 "
					+ " 		where ecco2.cecc_id = ecbm.cecc_id "
					+ " 		and ecco2.imov_id = ecbm.imov_id) as ValorNeg,"
					+ // 12
					" count(distinct eccp.eccp_nnparcelaatual) as ParcelasPaga, "
					+ // 13
					" (select sum(eccp2.eccp_vlpagamentomes) "
					+ " 		from COBRANCA.empr_cobr_conta_pagto eccp2"
					+ "		where eccp2.imov_id = ecbm.imov_id) as ValorPago,"
					+ // 14

					"   (select dbac.dbac_nnprestacaodebito "
					+ "        from FATURAMENTO.debito_a_cobrar dbac  "
					+ "        where dbac.imov_id = ecbm.imov_id "
					+ "         and dbac.parc_id is not null "
					+ "         and dbac.fntp_id in (2,3,4,8,9)"
					+ "         and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "         inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "         where pcit.parc_id = dbac.parc_id and ecco2.cecc_id = ecbm.cecc_id) "
					+ "         and dbac.dbac_id = (select max(dbac2.dbac_id) "
					+ "                  from FATURAMENTO.debito_a_cobrar dbac2  "
					+ "                  where dbac2.imov_id = ecbm.imov_id "
					+ "                   and dbac2.parc_id is not null "
					+ "                   and dbac2.fntp_id in (2,3,4,8,9) "
					+ "                   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "                   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "                   where pcit.parc_id = dbac2.parc_id and ecco2.cecc_id = ecbm.cecc_id))) as QuantidadeParcelasEmAberto, "
					+ // 15

					"(select dahi.dahi_nnprestacaodebito "
					+ "        from FATURAMENTO.deb_a_cobrar_hist dahi  "
					+ "        where dahi.imov_id = ecbm.imov_id "
					+ "         and dahi.parc_id is not null "
					+ "         and dahi.fntp_id in (2,3,4,8,9) "
					+ "         and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "         inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "         where pcit.parc_id = dahi.parc_id and ecco2.cecc_id = ecbm.cecc_id) "
					+ "         and dahi.dbac_id = (select max(dahi2.dbac_id) from FATURAMENTO.deb_a_cobrar_hist dahi2  "
					+ "                    where dahi2.imov_id = ecbm.imov_id "
					+ "                   and dahi2.parc_id is not null "
					+ "                   and dahi2.fntp_id in (2,3,4,8,9) "
					+ "                   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "                   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "                   where pcit.parc_id = dahi2.parc_id and ecco2.cecc_id = ecbm.cecc_id)) "
					+ "         ) as QuantidadeParcelasEmAbertoHist,"
					+ // 16

					" (select sum(dbac.dbac_VLDEBITO) "
					+ "   from FATURAMENTO.debito_a_cobrar dbac "
					+ "   where dbac.imov_id = ecbm.imov_id  "
					+ "   and dbac.parc_id is not null "
					+ "   and dbac.fntp_id in (2,3,4,8,9) "
					+ "   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "       inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "       where pcit.parc_id = dbac.parc_id and ecco2.cecc_id = ecbm.cecc_id) "
					+ "   ) AS SaldoEmAberto, "
					+ // 17

					"	(select sum(dahi.dahi_VLDEBITO) "
					+ "	from FATURAMENTO.deb_a_cobrar_hist dahi "
					+ "	where dahi.imov_id = ecbm.imov_id  "
					+ "	 and dahi.parc_id is not null "
					+ "	 and dahi.fntp_id in (2,3,4,8,9) "
					+ "	 and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "	   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "	   where pcit.parc_id = dahi.parc_id and ecco2.cecc_id = ecbm.cecc_id) "
					+ "	 ) AS SaldoEmAbertoHist, "
					+ // 18

					" cli.clie_nmcliente as clienteNome,"
					+ // 19
					" ecbm.imov_id AS idImovel,"
					+ // 20
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 21
					" re.REGI_NMREGIAO as regiao "
					+ // 22

					" FROM  CADASTRO.empresa EMPR  "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (CECC.EMPR_ID = EMPR.EMPR_ID) "
					+ " INNER JOIN COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM ON (ECBM.CECC_ID = CECC.CECC_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.cliente_imovel clim on (clim.imov_id = ecbm.imov_id and clim.crtp_id = 2 AND clim.clim_dtrelacaofim is null ) "
					+ " inner join CADASTRO.cliente cli on (cli.clie_id = clim.clie_id) "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " inner join COBRANCA.empr_cobr_conta_pagto eccp on (eccp.imov_id = ecbm.imov_id ) "
					+ " inner join COBRANCA.empresa_cobranca_conta ecco on (ecco.CECC_ID = cecc.cecc_id and ecbm.imov_id = ecco.imov_id) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id "
					+

					" WHERE EMPR.EMPR_ICUSO = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA = 1 "
					+ " AND GREG.GREG_ICUSO = 1 "
					+ " and eccp.eccp_ictipopagamento = 2 "
					+ " and clim.crtp_id = :clienteTipo "
					+ " and ECBM.ECBM_AMREFERENCIA = :anoMesReferencia "
					+ " and empr.empr_id= :idEmpresa ";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY " + " GREG.GREG_ID," + " ECBM.LOCA_ID,"
					+ " emcf.emcf_id," + " re.regi_id,"
					+ " loca.muni_idprincipal," + " empr.empr_nmempresa,"
					+ " ces.cese_dsnumerocontrato,"
					+ " ecbm.ecbm_amreferencia," + " cli.clie_nmcliente, "
					+ " loca.loca_nmlocalidade," + " mun.muni_nmmunicipio,"
					+ " emcf.emcf_dsfaixa," + " ecbm.cecc_id,"
					+ " ecbm.imov_id," + " greg.GREG_NMREGIONAL,"
					+ " re.REGI_NMREGIAO";

			// 4.4. Caso informada a Opção do Boletim= Parcelamento e Opção do
			// Relatório=Analítico,

			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade,idFaixaContas, idImovel";
			else
				sql += " order by regiao, nomeMunicipio,idFaixaContas, idImovel";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 12
					.addScalar("ParcelasPaga", Hibernate.INTEGER)
					// 13
					.addScalar("ValorPago", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("QuantidadeParcelasEmAberto", Hibernate.INTEGER)
					// 15
					.addScalar("QuantidadeParcelasEmAbertoHist",
							Hibernate.INTEGER)
					// 16
					.addScalar("SaldoEmAberto", Hibernate.BIG_DECIMAL)
					// 17
					.addScalar("SaldoEmAbertoHist", Hibernate.BIG_DECIMAL)
					// 18
					.addScalar("clienteNome", Hibernate.STRING)
					// 19
					.addScalar("idImovel", Hibernate.INTEGER)
					// 20
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 21
					.addScalar("regiao", Hibernate.STRING)
					// 22
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao))
					.setInteger("clienteTipo", ClienteRelacaoTipo.USUARIO);

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0005]
	 * - Emitir Relatório de Acompanhamento dos Parcelamentos em Atraso -
	 * Recuperação de Créditos
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoParcEmAtrasoAnalitico(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " select GREG.GREG_ID as idGerenciaRegional, " + // 0
					"	ECBM.LOCA_ID as idLocalidade, " + // 1
					"	emcf.emcf_id as idFaixaContas, " + // 2
					"	re.regi_id as idRegiao, " + // 3
					"	loca.muni_idprincipal as idMunicipio, " + // 4
					"	empr.empr_nmempresa as nomeEmpresa, " + // 5
					"	ces.cese_dsnumerocontrato as numeroContrato, " + // 6
					"	ecbm.ecbm_amreferencia as anoMesRef, " + // 7
					"	loca.loca_nmlocalidade as nomeLocalidade, " + // 8
					"	mun.muni_nmmunicipio as nomeMunicipio, " + // 9
					"	emcf.emcf_dsfaixa as descricaoFaixaContas, "; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )))  " + "  as qtdFaturasNegociadas, "; // 11
				}

			}

			sql += sql1;

			sql += " (select sum(ecco2.ecco_vloriginalconta) "
					+ " 		from COBRANCA.empresa_cobranca_conta ecco2 "
					+ " 		where ecco2.cecc_id = ecbm.cecc_id "
					+ " 		and ecco2.imov_id = ecbm.imov_id) as ValorNeg,"
					+ // 12
					" count(distinct eccp.eccp_nnparcelaatual) as ParcelasPaga, "
					+ // 13
					" (select sum(eccp2.eccp_vlpagamentomes) "
					+ " 		from COBRANCA.empr_cobr_conta_pagto eccp2"
					+ "		where eccp2.imov_id = ecbm.imov_id) as ValorPago,"
					+ // 14

					" (select count(distinct dbcd.cnta_id) "
					+ " from FATURAMENTO.debito_cobrado DBCD "
					+ " INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ " INNER JOIN FATURAMENTO.CONTA CNTA ON (CNTA.CNTA_ID = DBCD.CNTA_ID) "
					+ " WHERE DBAC.PARC_ID IS NOT NULL  "
					+ " AND DBAC.IMOV_ID = ECBM.IMOV_ID "
					+ " and dbac.fntp_id in (2,3,4,8,9) "
					+ " AND trunc(:dataAtual) - trunc(cnta.cnta_dtvencimentoconta) > 3 "
					+ " and not exists (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta.cnta_id)) AS parcelaAtraso, "
					+ // 15

					" (select sum(dbcd.dbcb_vlprestacao) "
					+ " from FATURAMENTO.debito_cobrado DBCD "
					+ " INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ " INNER JOIN FATURAMENTO.CONTA CNTA ON (CNTA.CNTA_ID = DBCD.CNTA_ID) "
					+ " WHERE DBAC.PARC_ID IS NOT NULL  "
					+ " AND DBAC.IMOV_ID = ECBM.IMOV_ID "
					+ " and dbac.fntp_id in (2,3,4,8,9) "
					+ " AND trunc(:dataAtual) - trunc(cnta.cnta_dtvencimentoconta) > 3 "
					+ " and not exists (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta.cnta_id)) AS ValorEmAtraso, "
					+ // 16

					" (select sum(dbac.dbac_VLDEBITO) "
					+ "   from FATURAMENTO.debito_a_cobrar dbac "
					+ "   where dbac.imov_id = ecbm.imov_id  "
					+ "   and dbac.parc_id is not null "
					+ "   and dbac.fntp_id in (2,3,4,8,9) "
					+ "   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "       inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "       where pcit.parc_id = dbac.parc_id and ecco2.cecc_id = ecbm.cecc_id) "
					+ "   ) AS SaldoEmAberto, "
					+ // 17

					"	(select sum(dahi.dahi_VLDEBITO) "
					+ "	from FATURAMENTO.deb_a_cobrar_hist dahi "
					+ "	where dahi.imov_id = ecbm.imov_id  "
					+ "	 and dahi.parc_id is not null "
					+ "	 and dahi.fntp_id in (2,3,4,8,9) "
					+ "	 and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "	   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "	   where pcit.parc_id = dahi.parc_id and ecco2.cecc_id = ecbm.cecc_id) "
					+ "	 ) AS SaldoEmAbertoHist, "
					+ // 18

					" cli.clie_nmcliente as clienteNome,"
					+ // 19
					" ecbm.imov_id AS idImovel,"
					+ // 20
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 21
					" re.REGI_NMREGIAO as regiao "
					+ // 22

					" FROM  CADASTRO.empresa EMPR  "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (CECC.EMPR_ID = EMPR.EMPR_ID) "
					+ " INNER JOIN COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM ON (ECBM.CECC_ID = CECC.CECC_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.cliente_imovel clim on (clim.imov_id = ecbm.imov_id and clim.crtp_id = 2 AND clim.clim_dtrelacaofim is null ) "
					+ " inner join CADASTRO.cliente cli on (cli.clie_id = clim.clie_id) "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " inner join COBRANCA.empr_cobr_conta_pagto eccp on (eccp.imov_id = ecbm.imov_id ) "
					+ " inner join COBRANCA.empresa_cobranca_conta ecco on (ecco.CECC_ID = cecc.cecc_id and ecbm.imov_id = ecco.imov_id) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id "
					+

					" WHERE EMPR.EMPR_ICUSO = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA = 1 "
					+ " AND GREG.GREG_ICUSO = 1 "
					+ " and eccp.eccp_ictipopagamento = 2 "
					+ " and clim.crtp_id = :clienteTipo "
					+ " and ECBM.ECBM_AMREFERENCIA = :anoMesReferencia "
					+ " and empr.empr_id= :idEmpresa ";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY " + " GREG.GREG_ID," + " ECBM.LOCA_ID,"
					+ " emcf.emcf_id," + " re.regi_id,"
					+ " loca.muni_idprincipal," + " empr.empr_nmempresa,"
					+ " ces.cese_dsnumerocontrato,"
					+ " ecbm.ecbm_amreferencia," + " cli.clie_nmcliente, "
					+ " loca.loca_nmlocalidade," + " mun.muni_nmmunicipio,"
					+ " emcf.emcf_dsfaixa," + " ecbm.cecc_id,"
					+ " ecbm.imov_id," + " greg.GREG_NMREGIONAL,"
					+ " re.REGI_NMREGIAO";

			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade,idFaixaContas, idImovel";
			else
				sql += " order by regiao, nomeMunicipio,idFaixaContas, idImovel";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 12
					.addScalar("ParcelasPaga", Hibernate.INTEGER)
					// 13
					.addScalar("ValorPago", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("parcelaAtraso", Hibernate.INTEGER)
					// 15
					.addScalar("ValorEmAtraso", Hibernate.BIG_DECIMAL)
					// 16
					.addScalar("SaldoEmAberto", Hibernate.BIG_DECIMAL)
					// 17
					.addScalar("SaldoEmAbertoHist", Hibernate.BIG_DECIMAL)
					// 18
					.addScalar("clienteNome", Hibernate.STRING)
					// 19
					.addScalar("idImovel", Hibernate.INTEGER)
					// 20
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 21
					.addScalar("regiao", Hibernate.STRING)
					// 22
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao))
					.setInteger("clienteTipo", ClienteRelacaoTipo.USUARIO)
					.setDate("dataAtual", new Date());

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0004]
	 * - Emitir Relatório de Acompanhamento dos Parcelamentos - Recuperação de
	 * Créditos
	 * 
	 * 2.4.5. Quantidade de Parcelas Pagas 2.4.6. Valor Pago
	 * 
	 * Retorna a quantidade de parcelas pagas, bem como o valor total quitado.
	 * 
	 * @author Hugo Azevedo
	 * @date 24/10/2011
	 */

	public Collection obterParcelasPagasRecuperacaoCreditos(Integer idImovel)
			throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection col = new ArrayList();
		try {
			sql = " select nvl(count(eccp.eccp_id),0) as contador,"
					+ // 0
					" nvl(sum(eccp.eccp_vlpagamentomes),0) as soma"
					+ // 1
					" from cobranca.empr_cobr_conta_pagto eccp "
					+ " where eccp.eccp_ictipopagamento = :tipoPagamento "
					+ " and eccp.imov_id = :imovel";

			col = session
					.createSQLQuery(sql)
					.addScalar("contador", Hibernate.INTEGER)
					// 0
					.addScalar("soma", Hibernate.BIG_DECIMAL)
					// 1
					.setInteger("tipoPagamento",
							ConstantesSistema.INDICADOR_USO_DESATIVO)
					.setInteger("imovel", idImovel).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return col;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0004]
	 * - Emitir Relatório de Acompanhamento dos Parcelamentos - Recuperação de
	 * Créditos
	 * 
	 * 2.4.7. Quantidade de Parcelas Em Aberto 2.4.8. Saldo em Aberto
	 * 
	 * @author Hugo Azevedo
	 * @date 24/10/2011
	 */

	public Collection obterDebitosQtdParcelasACobrarRecuperacaoCreditos(
			Integer idImovel) throws ErroRepositorioException {
		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection col = new ArrayList();
		try {
			sql = " select nvl(sum(dac.dbac_nnprestacaodebito),0) as prestacoes,"
					+ " nvl(sum(dac.dbac_nnprestacaodebito*dac.dbac_vldebito),0) as valor "
					+ " from faturamento.debito_a_cobrar dac "
					+ " where dac.parc_id is not null "
					+ " and dac.imov_id = :idImovel ";

			col = session.createSQLQuery(sql)
					.addScalar("prestacoes", Hibernate.INTEGER)// 0
					.addScalar("valor", Hibernate.BIG_DECIMAL)// 1
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return col;
	}

	/**
	 * [UC1237] Gerar Relatório de Boletim de Medição e Acompanhamento [SB0005]
	 * - Emitir Relatório de Acompanhamento dos Parcelamentos em Atraso -
	 * Recuperação de Créditos
	 * 
	 * 2.4.6. Quantidade de Parcelas Em Atraso
	 * 
	 * @author Hugo Azevedo
	 * @date 24/10/2011
	 */
	public Collection obterParcelasEmAtrasoRecuperacaoCreditos(Integer idImovel)
			throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection col = new ArrayList();
		Date dataAtual = new Date();

		try {
			sql = " select count(dc.dbcb_id) as contador,"
					+ " nvl(sum(dc.dbcb_vlprestacao),0) as soma"
					+ " from faturamento.debito_cobrado dc "
					+ " inner join faturamento.debito_a_cobrar dac on dac.dbac_id = dc.dbac_id "
					+ " inner join faturamento.conta cnta on cnta.cnta_id = dc.cnta_id "
					+ " where dac.parc_id is not null "
					+ " and dac.imov_id = :idImovel "
					+ " and (trunc(:dataAtual) - trunc(cnta.cnta_dtvencimentoconta)) > 3 "
					+ " and not exists ("
					+ "		select pg.cnta_id from arrecadacao.pagamento pg where pg.cnta_id = cnta.cnta_id"
					+ " )";

			col = session.createSQLQuery(sql)
					.addScalar("contador", Hibernate.INTEGER)
					// 0
					.addScalar("soma", Hibernate.BIG_DECIMAL)
					// 1
					.setInteger("idImovel", idImovel)
					.setDate("dataAtual", dataAtual).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return col;
	}

	/**
	 * [UC1239] Gerar Relatório de Penalidades por Índice de Atuação e Sucesso
	 * Financeiro
	 * 
	 * @author Hugo Azevedo
	 * @date 27/10/2011
	 */

	public Collection<Object[]> obterComandosEmPenalidades(Integer idEmpresa,
			Date dataInicial, Date dataFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String sql = "";
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {
			sql = " select cecc.empr_id as idEmpresa, "
					+ " sum(ceccp.ecpe_qtosgeradas) as qtosgeradas, "
					+ " sum(ceccp.ecpe_qtosencdec) as qtosencdec, "
					+ " sum(ceccp.ecpe_vltotalenv) as vltotalenv, "
					+ " sum(ceccp.ecpe_vltotalneg) as vltotalneg,"
					+ " emp.empr_nmempresa as nomeEmpresa,"
					+ " ces.cese_dsnumerocontrato as numerocontrato"
					+ " from cobranca.empr_conta_cobr_pena ceccp "
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ceccp.cecc_id = cecc.cecc_id "
					+ " inner join cadastro.empresa emp on cecc.empr_id = emp.empr_id "
					+ " inner join micromedicao.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id"
					+ " where cecc.empr_id = :idEmpresa "
					+ " and cecc.cecc_dtexecucao between :dataInicial and :dataFinal "
					+ " group by cecc.empr_id, emp.empr_nmempresa, ces.cese_dsnumerocontrato";

			retorno = session.createSQLQuery(sql)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("qtosgeradas", Hibernate.BIG_DECIMAL)
					.addScalar("qtosencdec", Hibernate.BIG_DECIMAL)
					.addScalar("vltotalenv", Hibernate.BIG_DECIMAL)
					.addScalar("vltotalneg", Hibernate.BIG_DECIMAL)
					.addScalar("nomeEmpresa", Hibernate.STRING)
					.addScalar("numerocontrato", Hibernate.STRING)
					.setInteger("idEmpresa", idEmpresa)
					.setDate("dataInicial", dataInicial)
					.setDate("dataFinal", dataFinal).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança
	 * 
	 * Metodo que retorna a soma data de encerramento do contrato mais
	 * quantidade de meses válido para pagamento de uma determinada conta
	 * 
	 * @author Raimundo Martins
	 * @date 06/10/2011
	 * 
	 */
	public Date pesquisarDataEncerContratoMaisQtdMesValPgmt(Integer idConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT (empr.empr_dtenccontrcob + empr.empr_nnmesesvalidopagto) AS dataEncerramento "
					+ "FROM CADASTRO.empresa empr "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.empr_id = empr.empr_id "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON ecco.cecc_id = cecc.cecc_id "
					+ "INNER JOIN FATURAMENTO.conta cnta "
					+ "ON cnta.cnta_id    = ecco.cnta_id "
					+ "WHERE cnta.cnta_id = :contaId";
			return (Date) session.createSQLQuery(sql)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.setInteger("contaId", idConta).setMaxResults(1)
					.uniqueResult();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança
	 * 
	 * metodo que pesquisa os comandos encerrados sem penalidades geradas
	 * 
	 * @author Raimundo Martins
	 * @date 20/10/2011
	 * */
	public Collection<Object[]> pesquisarComandosEncerradosSemPenalidades()
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT cecc.cecc_id as comandoId,"
					+ "  COUNT(DISTINCT ecco.imov_id) AS qtImoveisEnv, "
					+ "  COUNT(DISTINCT ecco.orse_id) AS qtOSGerada, "
					+ "  COUNT(DISTINCT( "
					+ "  CASE "
					+ "    WHEN orse.amen_id = :atMotEnc "
					+ "    THEN orse.orse_id "
					+ "    ELSE 0 "
					+ "  END))                        AS qtOsEncDec, "
					+ "  COUNT(DISTINCT ecco.cnta_id) AS qtFaturasEnv, "
					+ "  (SELECT COUNT(DISTINCT ecco2.cnta_id) "
					+ "  FROM COBRANCA.empr_cobr_conta_pagto eccp, "
					+ "    COBRANCA.empresa_cobranca_conta ecco2 "
					+ "  WHERE eccp.ecco_id = ecco2.ecco_id "
					+ "  AND ecco2.cecc_id  = cecc.cecc_id "
					+ "  )                              AS qtFaturasNeg, "
					+ "  SUM(ecco.ecco_vloriginalconta) AS vlTotalEnv, "
					+ "  (SELECT "
					+ "    CASE "
					+ "      WHEN SUM(ecco2.ecco_vloriginalconta) IS NULL "
					+ "      OR SUM(ecco2.ecco_vloriginalconta)    = 0 "
					+ "      THEN 0 "
					+ "      ELSE SUM(ecco2.ecco_vloriginalconta) "
					+ "    END "
					+ "  FROM COBRANCA.empr_cobr_conta_pagto eccp, "
					+ "    COBRANCA.empresa_cobranca_conta ecco2 "
					+ "  WHERE eccp.ecco_id = ecco2.ecco_id "
					+ "  AND ecco2.cecc_id  = cecc.cecc_id "
					+ "  ) AS vlTotalNeg "
					+ "FROM COBRANCA.cmd_empr_cobr_conta cecc "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON ecco.cecc_id = cecc.cecc_id "
					+ "INNER JOIN ATENDIMENTOPUBLICO.ordem_servico orse "
					+ "ON orse.orse_id                 = ecco.orse_id "
					+ "WHERE cecc.cecc_dtencerramento IS NOT NULL "
					+ "AND cecc.cecc_id NOT           IN "
					+ "  (SELECT eccpe.cecc_id FROM COBRANCA.empr_conta_cobr_pena eccpe "
					+ "  ) " + "GROUP BY cecc.cecc_id";

			return session
					.createSQLQuery(sql)
					.addScalar("comandoId", Hibernate.INTEGER)
					.addScalar("qtImoveisEnv", Hibernate.INTEGER)
					.addScalar("qtOSGerada", Hibernate.INTEGER)
					.addScalar("qtOsEncDec", Hibernate.INTEGER)
					.addScalar("qtFaturasEnv", Hibernate.INTEGER)
					.addScalar("qtFaturasNeg", Hibernate.INTEGER)
					.addScalar("vlTotalEnv", Hibernate.BIG_DECIMAL)
					.addScalar("vlTotalNeg", Hibernate.BIG_DECIMAL)
					.setInteger(
							"atMotEnc",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança
	 * 
	 * Metodo que pesquisa o ComandoEmpresaCobrancaConta que possui o id
	 * informado
	 * 
	 * @author Raimundo Martins
	 * @date 20/10/2011
	 * */
	public ComandoEmpresaCobrancaConta pesquisarDadosComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "select comando from ComandoEmpresaCobrancaConta comando where comando.id = :idComando";
			return (ComandoEmpresaCobrancaConta) session.createQuery(hql)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1240] Gerar Boletim de Cobrança por Resultado
	 * 
	 * Método que pesquisa os dados para a geração do boletim de cobrança por
	 * resultado
	 * 
	 * @author Raimundo Martins
	 * @date 24/10/2011
	 * */
	public Collection<Object[]> pesquisarDadosBoletimCobrancaResultado()
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT ecco.cecc_id                 AS comando, "
					+ "  sisp.parm_amreferenciaarrecadacao AS mesAno, "
					+ "  imov.loca_id                      AS localidade, "
					+ "  imov.imov_id                      AS imovel, "
					+ "  COUNT(dado.idCan)                 AS qtdContaCanceladas, "
					+ "  SUM( "
					+ "  CASE "
					+ "    WHEN dado.valorCancelado IS NULL "
					+ "    THEN 0 "
					+ "    ELSE dado.valorCancelado "
					+ "  END) AS valorCancelamento, "
					+ "  COUNT( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 1 "
					+ "    THEN dado.idPag "
					+ "  END) AS qtdPgAVista, "
					+ "  ( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 2 "
					+ "    THEN dado.totalParc "
					+ "    ELSE 0 "
					+ "  END) AS qtdPgParc, "
					+ "  SUM( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 1 "
					+ "    THEN dado.valorPago "
					+ "    ELSE 0 "
					+ "  END) AS vlPgAVista, "
					+ "  SUM( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 2 "
					+ "    THEN dado.valorPago "
					+ "    ELSE 0 "
					+ "  END)         AS vlPgParc, "
					+ "  emcf.emcf_id AS cobrancaFaixa, "
					+ "  ( "
					+ "  CASE "
					+ "    WHEN dado.cobrDoc IS NOT NULL "
					+ "    THEN "
					+ "      (SELECT "
					+ "        CASE "
					+ "          WHEN cbdo.cbdo_vldesconto IS NOT NULL "
					+ "          AND cbdo.cbdo_vldesconto  <> 0 "
					+ "          AND (cbdo.cbdo_vlacrescimos IS NULL OR cbdo.cbdo_vlacrescimos = 0 "
					+ "				OR COALESCE(cbdo.cbdo_vldesconto,0) >= COALESCE(cbdo.cbdo_vlacrescimos,0) ) "
					+ "          THEN (COALESCE(cbdo.cbdo_vldesconto,0) - COALESCE(cbdo.cbdo_vlacrescimos,0)) "
					+ "          ELSE NULL "
					+ "        END "
					+ "      FROM COBRANCA.cobranca_documento cbdo "
					+ "      WHERE cbdo.cbdo_id     = dado.cobrDoc "
					+ "      AND dado.tipoPagamento = 1 "
					+ "      AND cbdo.imov_id       = dado.imovel "
					+ "      ) "
					+ "  END) AS valorDesconto "
					+ "FROM "
					+ "  (SELECT eccp.ecco_id        AS eccon, "
					+ "    eccp.imov_id              AS imovel, "
					+ "    eccp.eccp_ampagamento     AS amref, "
					+ "    NULL                      AS valorCancelado, "
					+ "    eccp.eccp_vlpagamentomes  AS valorPago, "
					+ "    eccp.eccp_ictipopagamento AS tipoPagamento, "
					+ "    eccp.eccp_id              AS idPag, "
					+ "    NULL                      AS idCan, "
					+ "    eccp.eccp_nntotalparcelas AS totalParc, "
					+ "    eccp.cbdo_id              AS cobrDoc "
					+ "  FROM COBRANCA.empr_cobr_conta_pagto eccp "
					+ "  UNION "
					+ "  SELECT eccc.ecco_id , "
					+ "    eccc.imov_id, "
					+ "    eccc.eccc_amrefarrecadacao, "
					+ "    eccc.eccc_vlcancelamento, "
					+ "    NULL, "
					+ "    NULL, "
					+ "    NULL, "
					+ "    eccc.eccc_id, "
					+ "    NULL, "
					+ "    NULL "
					+ "  FROM COBRANCA.empr_conta_cobr_canc eccc "
					+ "  ) dado "
					+ "INNER JOIN CADASTRO.sistema_parametros sisp "
					+ "ON dado.amref = sisp.parm_amreferenciaarrecadacao "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON dado.eccon = ecco.ecco_id "
					+ "INNER JOIN CADASTRO.imovel imov "
					+ "ON dado.imovel = imov.imov_id "
					+ "INNER JOIN CADASTRO.empr_cobr_faixa emcf "
					+ "ON emcf.emcf_pcfaixa                    = ecco.ecco_pcempresaconta "
					+ "GROUP BY ecco.cecc_id, "
					+ "  sisp.parm_amreferenciaarrecadacao, "
					+ "  imov.loca_id, " + "  imov.imov_id, "
					+ "  dado.imovel, " + "  dado.tipoPagamento, "
					+ "  emcf.emcf_id, " + "  dado.cobrDoc, "
					+ "  dado.totalParc";

			return session.createSQLQuery(sql)
					.addScalar("comando", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.addScalar("localidade", Hibernate.INTEGER)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("qtdContaCanceladas", Hibernate.INTEGER)
					.addScalar("valorCancelamento", Hibernate.BIG_DECIMAL)
					.addScalar("qtdPgAVista", Hibernate.INTEGER)
					.addScalar("qtdPgParc", Hibernate.INTEGER)
					.addScalar("vlPgAVista", Hibernate.BIG_DECIMAL)
					.addScalar("vlPgParc", Hibernate.BIG_DECIMAL)
					.addScalar("valorDesconto", Hibernate.BIG_DECIMAL)
					.addScalar("cobrancaFaixa", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1186] Gerar Relatório Ordem de Serviço Cobrança p/Resultado
	 * 
	 * Pesquisar Valor enviado e quantidade de contas enviadas na cobranca por
	 * Resultado
	 * 
	 * @author Rômulo Aurélio
	 * @data 24/10/2011
	 */

	public Collection obterValorEnviadoCobrancaPorResultado(OrdemServico os)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select sum (coalesce(conta.CNTA_VLAGUA,0) + coalesce(conta.CNTA_VLESGOTO,0) + coalesce(conta.CNTA_VLDEBITOS,0) "
					+ "- coalesce(conta.CNTA_VLCREDITOS,0) - coalesce(conta.CNTA_VLIMPOSTOS,0)) as valorTotal, "
					+ "count (distinct conta.cnta_id) as qtdeContas, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta conta on conta.cnta_id = emprc.cnta_id "
					+ "where emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";
			consulta += "group by emprc.imov_id ";

			consulta += "union select sum (coalesce(contaHistorico.cnhi_vlagua,0) + coalesce(contaHistorico.cnhi_vlesgoto,0) "
					+ "+ coalesce(contaHistorico.cnhi_vldebitos,0) - coalesce(contaHistorico.cnhi_vlcreditos,0) - coalesce(contaHistorico.cnhi_vlimpostos,0)) as valorTotal, "
					+ "count (distinct contaHistorico.cnta_id) as qtdeContas, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta_historico contaHistorico on contaHistorico.cnta_id = emprc.cnta_id "
					+ "where emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";

			consulta += "group by emprc.imov_id";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valorTotal", Hibernate.BIG_DECIMAL)
					.addScalar("qtdeContas", Hibernate.INTEGER)
					.addScalar("imovel", Hibernate.INTEGER)
					.setInteger("imovelId", os.getImovel().getId())
					.setInteger("idOrdemServico", os.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1186] Gerar Relatório Ordem de Serviço Cobrança p/Resultado
	 * 
	 * Pesquisar Valor Pago e quantidade de contas Pagas na cobranca por
	 * Resultado
	 * 
	 * @author Rômulo Aurélio
	 * @data 24/10/2011
	 */

	public Collection obterValorPagoCobrancaPorResultado(OrdemServico os)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select sum(coalesce(pgmt.pgmt_vlpagamento,0) + coalesce(pghi.pghi_vlpagamento,0)) as valorPago, "
					+ "count (pgmt.pgmt_id) + count(pghi.pghi_id) as qtdecontaspagas  "
					+ "from cobranca.empresa_cobranca_conta emprc  "
					+ "left join arrecadacao.pagamento pgmt on  pgmt.cnta_id = emprc.cnta_id "
					+ "left join arrecadacao.pagamento_historico pghi on pghi.cnta_id = emprc.cnta_id "
					+ "where emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valorPago", Hibernate.BIG_DECIMAL)
					.addScalar("qtdecontaspagas", Hibernate.INTEGER)
					.setInteger("imovelId", os.getImovel().getId())
					.setInteger("idOrdemServico", os.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1186] Gerar Relatório Ordem de Serviço Cobrança p/Resultado
	 * 
	 * Pesquisar Valor Parcelado na cobranca por Resultado
	 * 
	 * @author Rômulo Aurélio
	 * @data 24/10/2011
	 */

	public Collection obterValorParceladoCobrancaPorResultado(OrdemServico os)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select sum (coalesce(conta.CNTA_VLAGUA,0) + coalesce(conta.CNTA_VLESGOTO,0) + coalesce(conta.CNTA_VLDEBITOS,0) "
					+ "- coalesce(conta.CNTA_VLCREDITOS,0) - coalesce(conta.CNTA_VLIMPOSTOS,0)) as valorTotal, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta conta on conta.cnta_id = emprc.cnta_id "
					+ "where conta.dcst_idatual = 5 and emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";
			consulta += "group by emprc.imov_id ";

			consulta += "union select sum (coalesce(contaHistorico.cnhi_vlagua,0) + coalesce(contaHistorico.cnhi_vlesgoto,0) "
					+ "+ coalesce(contaHistorico.cnhi_vldebitos,0) - coalesce(contaHistorico.cnhi_vlcreditos,0) - coalesce(contaHistorico.cnhi_vlimpostos,0)) as valorTotal, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta_historico contaHistorico on contaHistorico.cnta_id = emprc.cnta_id "
					+ "where contaHistorico.dcst_idatual = 5 and emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";

			consulta += "group by emprc.imov_id";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valorTotal", Hibernate.BIG_DECIMAL)
					.addScalar("imovel", Hibernate.INTEGER)
					.setInteger("imovelId", os.getImovel().getId())
					.setInteger("idOrdemServico", os.getId()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1156] Emitir Documentos de Cobrança Em Lote
	 * 
	 * [SB0005] - Obter Motivo de Encerramento da Ação de Cobrança
	 * 
	 * 1. Seleciona os motivos de encerramento da ação de cobrança
	 * 
	 * @author Mariana Victor
	 * @date 26/10/2011
	 */
	public Collection<AtendimentoMotivoEncerramento> selecionaMotivosEncerramentoAcaoCobranca(
			Integer idAcaoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection<AtendimentoMotivoEncerramento> retorno = null;
		Collection<Object[]> colecaoDados = null;

		try {
			consulta = "select amen.amen_id AS idAtendMotEnc, "
					+ " amen.amen_dsmotivoencerramento AS descricao "
					+ " from atendimentopublico.atend_motivo_encmt amen "
					+ "   inner join atendimentopublico.atend_mot_enc_acao_cobr amea "
					+ "     on (amea.amen_id = amen.amen_id and amea.cbac_id = :idAcaoCobranca) "
					+ " where amea.amea_icexibedocumento = :indicadorExibeDocConsta "
					+ " order by amen.amen_dsmotivoencerramento ";

			colecaoDados = session
					.createSQLQuery(consulta)
					.addScalar("idAtendMotEnc", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					.setInteger("indicadorExibeDocConsta",
							ConstantesSistema.SIM).list();

			if (colecaoDados != null && !colecaoDados.isEmpty()) {
				retorno = new ArrayList<AtendimentoMotivoEncerramento>();
				Iterator<Object[]> iterator = colecaoDados.iterator();

				while (iterator.hasNext()) {
					Object[] dados = iterator.next();

					AtendimentoMotivoEncerramento atendimentoMotivoEncerramento = new AtendimentoMotivoEncerramento();
					atendimentoMotivoEncerramento.setId((Integer) dados[0]);
					atendimentoMotivoEncerramento
							.setDescricao((String) dados[1]);

					retorno.add(atendimentoMotivoEncerramento);
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1156] Emitir Documentos de Cobrança Em Lote
	 * 
	 * Método que pesquisa o endereço da unidade de negocio a partir da
	 * localidade do imovel
	 * 
	 * @author Raimundo Martins
	 * @return id da localidade da unidade de negocio
	 * */

	public Integer obterEnderecoUnNegocioLocalImovel(Integer idLocalidadeImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "select loca_cdelo from cadastro.localidade where loca_id = :idLocalidadeImovel";

			return (Integer) session.createSQLQuery(consulta)
					.addScalar("loca_cdelo", Hibernate.INTEGER)
					.setInteger("idLocalidadeImovel", idLocalidadeImovel)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0243] Inserir Comando de Ação de Cobrança
	 * 
	 * @author Raphael Rossiter
	 * @date 21/10/2011
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeRotasPorGrupoCobranca(
			Integer idGrupoCobranca) throws ErroRepositorioException {

		Integer retorno = 0;
		Collection<Integer> rotas = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct(rota.id) "
					+ "from Rota rota "
					+ "inner join rota.cobrancaGrupo cbgr "
					+ "where cbgr.id = :idCobrancaGrupo and rota.indicadorUso = :indicadorUso ";

			rotas = session
					.createQuery(consulta)
					.setInteger("idCobrancaGrupo", idGrupoCobranca)
					.setShort("indicadorUso",
							ConstantesSistema.INDICADOR_USO_ATIVO).list();

			if (rotas != null && !rotas.isEmpty()) {
				retorno = rotas.size();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Inserir Ação de Cobrança
	 * 
	 * @author Raphael Rossiter
	 * @created 07/11/2011
	 * 
	 * @param idCobrancaAcao
	 * @param textoPersonalizado
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoTextoPersonalizado(Integer idCobrancaAcao,
			String textoPersonalizado) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String update;
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			update = "UPDATE cobranca.cobranca_acao SET cbac_dstextopersonalizado = ? "
					+ "WHERE cbac_id = ? ";

			st = jdbcCon.prepareStatement(update);
			st.setString(1, textoPersonalizado);
			st.setInt(2, idCobrancaAcao);

			st.executeUpdate();

			session.flush();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0214] Consultar Comando de Ação de Cobrança
	 * 
	 * @author Erivan Sousa
	 * @date 04/11/2011
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public String buscarTextoPersonalizadoAcaoCobranca(Integer idAcaoCobranca)
			throws ErroRepositorioException {
		StringBuilder builder = new StringBuilder();
		String retorno = "";
		Collection col = null;
		Session session = HibernateUtil.getSession();

		builder.append("SELECT cbac_dstextopersonalizado ");
		builder.append("FROM cobranca.cobranca_acao ");
		builder.append("WHERE cbac_id = :idAcaoCobranca");

		try {
			col = session.createSQLQuery(builder.toString())
					.addScalar("cbac_dstextopersonalizado", Hibernate.STRING)
					.setInteger("idAcaoCobranca", idAcaoCobranca).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (col != null && !col.isEmpty()) {
			retorno = (String) col.iterator().next();
		}

		return retorno;
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança Metodo que remove
	 * contas canceladas associadas a comandos de cobrança no mes de arrecadação
	 * 
	 * @author Raimundo Martins
	 * @date 28/10/2011
	 **/
	public void removerContasCanceladasMesAssocComandosCobranca(
			Integer anoMesArrecadacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "DELETE EmpresaContaCobrancaCancelada empresa WHERE empresa.amRefArrecadacao = :anoMes";
			session.createQuery(sql).setInteger("anoMes", anoMesArrecadacao)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC120] Gerar Boletim de Cobrança por Resultado
	 * 
	 * Método que remove os dados para a geração do boletim de cobrança por
	 * resultado a partir do mes de arrecadação
	 * 
	 * @author Raimundo Martins
	 * @date 28/10/2011
	 * */
	public void removerDadosBoletimCobrancaResultado(Integer anoMesArrecadacao)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "DELETE EmpresaCobrancaContaBoletimMedicao boletim WHERE boletim.anoMesReferenciaConta = :anoMes";
			session.createQuery(sql).setInteger("anoMes", anoMesArrecadacao)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança
	 * 
	 * Método que pesquisa o comando a partir do ID de EmpresaCobrancaConta
	 * 
	 * @author Raimundo Martins
	 * @date 28/10/2011
	 * */

	public ComandoEmpresaCobrancaConta pesquisarComandoEmpresaCobrancaContaPorEmpresaCobrancaConta(
			Integer idEmpresaCobrancaConta) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "SELECT ecc.comandoEmpresaCobrancaConta FROM EmpresaCobrancaConta ecc WHERE ecc.id = :idEmpresaCobrancaConta ";
			return (ComandoEmpresaCobrancaConta) session
					.createQuery(hql)
					.setInteger("idEmpresaCobrancaConta",
							idEmpresaCobrancaConta).uniqueResult();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * [SB0003] - Gerar Atividade de Ação de Cobrança o Imóvel
	 * 
	 * 2.3.1. Caso exista ação de cobrança para o motivo de encerramento
	 * 
	 * @author Mariana Victor
	 * @date 28/10/2011
	 */
	public boolean existeCobrancaAcaoMotivoEncerramento(
			Integer idAcaoCobrancaPrecedente) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Integer quantidade = null;
		boolean retorno = false;

		try {
			consulta = "select count(*) AS quantidade "
					+ " from atendimentopublico.atend_mot_enc_acao_cobr "
					+ " where cbac_id = :idAcaoCobrancaPrecedente ";

			quantidade = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idAcaoCobrancaPrecedente",
							idAcaoCobrancaPrecedente).setMaxResults(1)
					.uniqueResult();

			if (quantidade != null && quantidade > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança
	 * 
	 * [SB0003] - Gerar Atividade de Ação de Cobrança o Imóvel
	 * 
	 * 2.3.1.1. Caso não exista ordem de serviço, relativa à ação precedente,
	 * realizada até a data mínima de emissão/realização da ação precedente
	 * 
	 * @author Mariana Victor
	 * @date 28/10/2011
	 */
	public Integer documentoCobrancaOrdemServicoAcaoPrecedente(
			Integer idDocumentoCobrancaAcaoPrecedente,
			Integer idAcaoPrecedente,
			Date dataMinimaEmissaoRealizacaoAcaoPrecente)
			throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obtém a sessão
		Session session = HibernateUtil.getSession();

		try {

			/*
			 * RM 3452 Alterado por Raphael Rossiter em 03/07/2012 a pedido de
			 * Rosana Carvalho.
			 */
			consulta = "select orse.cbdo_id AS idDocCob "
					+ " from atendimentopublico.ordem_servico orse "
					+ " inner join atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = orse.amen_id "
					+ " where orse.cbdo_id = :idDocumentoCobrancaAcaoPrecedente and amea.amea_icgerasucessor = :icGeraSucessor "
					+ " and amea.cbac_id = :idAcaoPrecedente and orse.orse_tmencerramento is not null "
					+ " and orse.orse_tmgeracao <= :dataMinimaEmissaoRealizacaoAcaoPrecente ";

			retorno = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("idDocCob", Hibernate.INTEGER)
					.setInteger("idDocumentoCobrancaAcaoPrecedente",
							idDocumentoCobrancaAcaoPrecedente)
					.setInteger("idAcaoPrecedente", idAcaoPrecedente)
					.setShort("icGeraSucessor", ConstantesSistema.SIM)
					.setTimestamp("dataMinimaEmissaoRealizacaoAcaoPrecente",
							dataMinimaEmissaoRealizacaoAcaoPrecente)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1238] Gerar Relatório de Acompanhamento dos Comandos de Cobrança
	 * 
	 * Pesquisa a quantidade de comandos
	 * 
	 * @author: Mariana Victor
	 * @date: 04/05/2011
	 */
	public Integer pesquisarQuantidadeComandosContasCobrancaEmpresa(
			Integer idEmpresa, Date cicloInicial, Date cicloFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select "
					+ " count(comandoEmpresaCobrancaConta) " // 1
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa ";

			if (cicloInicial != null && cicloFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataInicioCiclo between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloFinal)
						+ "','YYYY-MM-DD') ";

			}

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1238] Gerar Relatório de Acompanhamento dos Comandos de Cobrança
	 * 
	 * Pesquisa os dados dos comandos
	 * 
	 * @author: Mariana Victor
	 * @date: 04/05/2011
	 */
	public Collection<Object[]> pesquisarTotalizacaoComandoContasCobrancaEmpresa(
			List<EmpresaCobrancaFaixa> colecaoEmpresaCobrancaFaixa,
			Integer idEmpresa, Date cicloInicial, Date cicloFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select count(distinct ecco.cnta_id) AS quantidadeContas, " // 0
					+ "   count(distinct ecco.imov_id) AS quantidadeClientes, " // 1
					+ "   sum(ecco.ecco_vloriginalconta) AS valorOriginal, " // 2
					+ "   ecco.cecc_id AS comando, " // 3
					+ "   cecc.cecc_dtexecucao AS dataExecucao, " // 4
					+ "   cecc.cecc_dtiniciociclo AS dataInicio, " // 5
					+ "   cecc.cecc_dtfimciclo AS dataFim, " // 6
					+ "   emcf.emcf_id AS faixa, " // 7
					+ "   emcf.emcf_dsfaixa AS descricaoFaixa " // 8
					+ " from cobranca.empresa_cobranca_conta ecco "
					+ "   inner join cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ "   inner join cadastro.empr_cobr_faixa emcf on emcf.emcf_pcfaixa = ecco.ecco_pcempresaconta "
					+ " where cecc.empr_id = :idEmpresa ";

			if (cicloInicial != null && cicloFinal != null) {

				consulta = consulta + " and "
						+ "  cecc.cecc_dtexecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta + "   and exists "
					+ "    (select eccc.imov_id "
					+ "      from cobranca.empresa_cobranca_conta eccc "
					+ "      where eccc.imov_id = ecco.imov_id "
					+ "       and ecco.cecc_id = eccc.cecc_id "
					+ "      group by eccc.imov_id " + "      having ";

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {

					consulta = consulta
							+ " count(distinct (CASE WHEN eccc.ecco_pcempresaconta = "
							+ faixa.getPercentualFaixa()
							+ "       THEN  eccc.cnta_id "
							+ "       ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					consulta = consulta
							+ " count(distinct (CASE WHEN eccc.ecco_pcempresaconta = "
							+ faixa.getPercentualFaixa()
							+ "       THEN  eccc.cnta_id "
							+ "       ELSE NULL END)) >= " + numeroMinimoContas;

				}
			}

			consulta = consulta
					+ " ) "
					+ " GROUP BY ecco.cecc_id, cecc.cecc_dtexecucao, cecc.cecc_dtiniciociclo, "
					+ "   cecc.cecc_dtfimciclo, emcf.emcf_id, emcf.emcf_dsfaixa";

			retorno = session.createSQLQuery(consulta)
					.addScalar("quantidadeContas", Hibernate.INTEGER)
					.addScalar("quantidadeClientes", Hibernate.INTEGER)
					.addScalar("valorOriginal", Hibernate.BIG_DECIMAL)
					.addScalar("comando", Hibernate.INTEGER)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("dataInicio", Hibernate.DATE)
					.addScalar("dataFim", Hibernate.DATE)
					.addScalar("faixa", Hibernate.INTEGER)
					.addScalar("descricaoFaixa", Hibernate.STRING)
					.setInteger("idEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1153] Solicitar Geração/Emissão Boletim de Medição de Cobrança
	 * 
	 * Metódo que pesquisa as ações de penalidade a partir mês de referencia e
	 * Grupo ou Empresa
	 * 
	 * @author Raimundo Martins, Vivianne Sousa
	 * 
	 * @date 10/11/2011,26/06/2014
	 */

	public Collection<Object[]> pesquisarAcoesPenalidadesPorGrupoMes(
			Integer idGrupo, Integer anoMes, Integer idContrato)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			Map parameters = new HashMap();

			String sql = " select  distinct(cbac.cbac_id) as idAcao, cbac.cbac_dscobrancaacao as acao"
					+ " from cobranca.cobranca_acao cbac "
					+ " inner join cobranca.cobranca_acao_cronograma cbgr on cbac.cbac_id = cbgr.cbac_id "
					+ " inner join cobranca.cobranca_grupo_crg_mes  cbcm on cbcm.cbcm_id = cbgr.cbcm_id ";

			if (idGrupo != null) {
				sql = sql
						+ " where cbcm.cbgr_id = :idGrupo AND cbgr.cbcr_cdtipocobranca = :tipoCobranca ";
				parameters.put("idGrupo", idGrupo);
				parameters.put("tipoCobranca", new Short("1"));

			} else if (idContrato != null) {
				sql = sql
						+ " where cbgr.cese_id = :idContrato AND cbgr.cbcr_cdtipocobranca = :tipoCobranca ";
				parameters.put("idContrato", idContrato);
				parameters.put("tipoCobranca", new Short("2"));
			}

			sql = sql + " and cbcm.cbcm_amreferencia = :anoMes "
					+ " order by cbac.cbac_id";

			Query q = session.createSQLQuery(sql)
					.addScalar("idAcao", Hibernate.INTEGER)
					.addScalar("acao", Hibernate.STRING)
					.setInteger("anoMes", anoMes);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					q.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					q.setParameterList(key, collection);
				} else {
					q.setParameter(key, parameters.get(key));
				}
			}

			return q.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1153] Solicitar Geração / Emissão Boletim de Medição
	 * 
	 * Metodo que retorna a CobrancaAçãoCronograma a partir da Ação, Ano/Mes e
	 * Grupo de ação de cobrança
	 * 
	 * @author Raimundo Martins
	 * @date 17/11/2011
	 * */
	public CobrancaAcaoCronograma pesquisarCobrancaAcaoCronograma(
			Integer idGrupo, Integer anoMes, Integer idAcaoCobranca,
			Integer idContratoEmpresaServico) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "select cbgr "
					+ "from CobrancaAcaoCronograma cbgr "
					+ "inner join cbgr.cobrancaAcao cbac "
					+ "inner join cbgr.cobrancaGrupoCronogramaMes cbcm ";
			if (idGrupo != null) {
				consulta = consulta + " where cbcm.cobrancaGrupo.id = "
						+ idGrupo + " and cbgr.codigoTipoCobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO;
			} else if (idContratoEmpresaServico != null) {
				consulta = consulta
						+ " where cbgr.contratoEmpresaServico.id = "
						+ idContratoEmpresaServico
						+ " and cbgr.codigoTipoCobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA;
			}
			consulta = consulta + " and cbac.id = :idAcaoCobranca "
					+ " and cbcm.anoMesReferencia = :anoMes";

			return (CobrancaAcaoCronograma) session.createQuery(consulta)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					.setInteger("anoMes", anoMes).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1151] Gerar Boletim Medição
	 * 
	 * Metodo que pesquisa as justificativas de não penalidades para o grupo de
	 * cobrança a partir do ano / mês informado
	 * 
	 * @author Raimundo Martins
	 * @date 17/11/2011
	 * */
	public Collection<Integer> pesquisarNaoPenalidades(Integer idGrupo,
			Integer anoMes, Integer idContrato) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select bmpj_id as id "
					+ " from cobranca.bol_med_ac_pen_just where cbcr_id in ( select cbgr.cbcr_id from cobranca.cobranca_acao cbac "
					+ " inner join cobranca.cobranca_acao_cronograma cbgr on cbac.cbac_id = cbgr.cbac_id "
					+ " inner join cobranca.cobranca_grupo_crg_mes  cbcm on cbcm.cbcm_id = cbgr.cbcm_id "
					+ " where cbcm.cbcm_amreferencia = :anoMes and ";
			if (idGrupo != null) {
				sql = sql + "cbcm.cbgr_id = " + idGrupo
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_GRUPO
						+ ")";
			} else {
				sql = sql
						+ "cbgr.cese_id = "
						+ idContrato
						+ " and cbcr_cdtipocobranca = "
						+ CobrancaAcaoCronograma.CODIGO_TIPO_COBRANCA_ACAO_COBRANCA
						+ ")";
			}

			return (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("anoMes", anoMes).list();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1151] Gerar Boletim Medição
	 * 
	 * Metodo que atualiza a tabela cobranca.bol_med_ac_pen_just inserindo o id
	 * do boletim gerado para as justificativas de não penalidades geradas para
	 * um grupo de cobrança
	 * 
	 * @author Raimundo Martins
	 * @date 17/11/2011
	 * */
	public void atualizarBoletimGeradoEmBolMedAcPenJust(Integer idBmpj,
			Integer idBoletimGerado) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {

			String sql = "UPDATE BoletimMedicaoJustificativaPenalidade "
					+ "SET cobm_id = :idBoletimGerado, bmpj_tmultimaalteracao = :data "
					+ "WHERE bmpj_id = :idBmpj";
			session.createQuery(sql)
					.setInteger("idBoletimGerado", idBoletimGerado)
					.setDate("data", new Date()).setInteger("idBmpj", idBmpj)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1152] Emitir Boletim Medição Cobrança
	 * 
	 * Metodo que pesquisa a justificativa da penalidade de um boletim de
	 * medição
	 * 
	 * @author Raimundo Martins
	 * @date 22/11/2011
	 * */
	public BoletimMedicaoJustificativaPenalidade pesquisarBoletimMedicaoJustificativaPenalidade(
			Integer idBoletim) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "select bol from BoletimMedicaoJustificativaPenalidade bol "
					+ " inner join fetch bol.cobrancaAcaoCronograma acaoCrono "
					+ " inner join fetch acaoCrono.cobrancaAcao acao"
					+ " where bol.id = :idBoletim ";
			return (BoletimMedicaoJustificativaPenalidade) session
					.createQuery(hql).setInteger("idBoletim", idBoletim)
					.uniqueResult();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * 1.5.1. O usuário informa o filtro e ao clicar no botão "Selecionar" o
	 * sistema deverá exibir, em uma tabela, todos os boletins de medição
	 * 
	 * @author Mariana Victor
	 * @date 21/11/2011
	 * */
	public Collection<Object[]> pesquisarBoletimMedicaoContrato(
			Integer idContrato, String descricaoContrato, Integer anoMes)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = "select cobm.cobm_amreferencia AS anoMesRef, "
					+ "  cobm.cobm_id AS idCobrancaGrupo,  "
					+ "  cbgr.cbgr_dscobrancagrupo AS cobrancaGrupo "
					+ " from cobranca.cobr_boletim_medicao cobm "
					+ " left join cobranca.cobranca_grupo cbgr on cbgr.cbgr_id = cobm.cbgr_id "
					+ " inner join micromedicao.contrato_empresa_servico cese on cese.cese_id = cobm.cese_id ";

			if (anoMes != null) {
				sql = sql + " where cobm.cobm_amreferencia = :anoMes ";
			}

			sql = sql
					+ "  and ((cobm.cobc_id is null and cbgr.cese_id = :idContrato) "
					+ "  or cese.cese_dsnumerocontrato = :descricaoContrato)"

					+ " order by cbgr.cbgr_id ";

			Query query = session.createSQLQuery(sql)
					.addScalar("anoMesRef", Hibernate.INTEGER)
					.addScalar("idCobrancaGrupo", Hibernate.INTEGER)
					.addScalar("cobrancaGrupo", Hibernate.STRING)
					.setInteger("idContrato", idContrato)
					.setString("descricaoContrato", descricaoContrato);

			if (anoMes != null) {
				query = query.setInteger("anoMes", anoMes);
			}

			return (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * [SB0001] - Gerar Boletim Medição de Contrato
	 * 
	 * 2. E, para cada boletim de medição selecionado, atualiza os dados da
	 * tabela COBR_BOLETIM_MEDICAO:
	 * 
	 * @author Mariana Victor
	 * @data 21/11/2011
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarBoletimMedicaoCobranca(String[] idsBoletim,
			Integer idCobrancaBoletimContrato) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "update gcom.cobranca.CobrancaBoletimMedicao "
					+ " set cobc_id = :idCobrancaBoletimContrato, cobm_tmultimaalteracao = :ultimaAlteracao "
					+ " where cobm_id in (:idsBoletim) ";

			session.createQuery(consulta)
					.setInteger("idCobrancaBoletimContrato",
							idCobrancaBoletimContrato)
					.setTimestamp("ultimaAlteracao", new Date())
					.setParameterList("idsBoletim", idsBoletim).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> filtrarRelatorioAcompanhamentoBoletimMedicaoContrato(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = " SELECT itensServico.idItemServico, " // 0 - ID
																		// Item
																		// Serviço
					+ " itensServico.descricaoServico,  " // 1 - Descrição Item
															// Serviço
					+ " itensServico.quantidadeOrcada,  " // 1 - Descrição Item
															// Serviço
					+ " itensServico.valorUnitario,  " // 3 - Valor Unitário
					+ " sum(itensServico.quantidade) as quantidadeItem,  " // 4
																			// -
																			// Quantidade
																			// do
																			// Item
					+ " (itensServico.valorUnitario * sum(itensServico.quantidade)) as valorItem,  " // 5
																										// -
																										// Valor
																										// Item
					+ " itensServico.unidadeItem,  " // 6 - Unidade do Item
					+ " itensServico.valorOrcado,  " // 7 - Valor Orcado
					+ " sum(itensServico.valorMedidoPeriodo) AS valorMedidoPeriodo, " // 8
																						// -
																						// Valor
																						// medido
																						// no
																						// período
					+ " itensServico.cdItemServico AS cdItemServico  " // 9 -
																		// Codigo
																		// Item
																		// Servico
					+ " FROM (SELECT  "
					+ " itse.itse_id AS idItemServico,  "
					+ " itse.itse_dsitemservico AS descricaoServico,  "
					+ " itsc.itsc_qtorcadaitemservico AS quantidadeOrcada,  "
					+ " 1 AS quantidade,  "
					+ " itsc.itsc_vlitemservcontr AS valorUnitario,  "
					+ " (CASE WHEN itse.itse_cdconstantecalculo IN (3, 7, 9, 11, 13, 4, 8, 10, 12, 14, 18, 19, 20, 21, 22, 23, 24, 25, 26) THEN 'UND'  "
					+ " ELSE '' END) AS unidadeItem,  "
					+ " itsc.itsc_vlorcadoitemservico AS valorOrcado,  "
					+ " cbex.cbex_vlservico AS valorMedidoPeriodo, "
					+ " itse.itse_cdconstantecalculo AS cdItemServico  "
					+ " FROM cobranca.cobr_boletim_exec cbex  "
					+ " INNER JOIN cobranca.cobr_boletim_medicao cobm ON (cbex.cobm_id = cobm.cobm_id)  "
					+ " INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id AND cobc.cobc_id = :idBoletimContrato)  "
					+ " INNER JOIN micromedicao.contrato_empresa_servico cese ON (cobc.cese_id = cese.cese_id AND cese.cese_id = :idContrato)  "
					+ " INNER JOIN atendimentopublico.ordem_servico orse ON (cbex.orse_id = orse.orse_id)  "
					+ " INNER JOIN micromedicao.item_contrato_servico_tipo icst ON (icst.svtp_id = orse.svtp_id)  "
					+ " INNER JOIN micromedicao.item_servico_contrato itsc ON (cese.cese_id = itsc.cese_id AND icst.itsc_id = itsc.itsc_id)  "
					+ " INNER JOIN micromedicao.item_servico itse ON (itsc.itse_id = itse.itse_id)  "
					+ " LEFT JOIN atendimentopublico.ATEND_MOTIVO_ENCMT amen on amen.amen_id = orse.amen_id"
					+ " LEFT OUTER JOIN atendimentopublico.ordem_servico_boletim orbo ON (cbex.orse_id = orbo.orse_id)  "
					+ " WHERE (itse.itse_cdconstantecalculo IN (2,6) AND orbo.orbo_icpavimento = 3)  "
					+ " OR (itse.itse_cdconstantecalculo IN (3,7,9,11,13) AND orbo.orbo_icpavimento = 2)  "
					+ " OR (itse.itse_cdconstantecalculo IN (4,8,10,12,14) AND orbo.orbo_icpavimento = 1)  "
					+ " OR (itse.itse_cdconstantecalculo IN (1,5)) "
					+ " OR (itse.itse_cdconstantecalculo IN (1,5))  "
					+ " OR (itse.itse_cdconstantecalculo IN (18) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=1) "
					+ " OR (itse.itse_cdconstantecalculo IN (19) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=2) "
					+ " OR (itse.itse_cdconstantecalculo IN (20) AND orbo.orbo_icpavimento = 2 AND orbo_iccalcada=2) "
					+ " OR (itse.itse_cdconstantecalculo IN (21) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=2 and orbo_iccalcada=2) "
					+ " OR (itse.itse_cdconstantecalculo IN (22) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=2 and orbo_iccalcada=1) "
					+ " OR (itse.itse_cdconstantecalculo IN (23) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=1 and orbo_iccalcada=2) "
					+ " OR (itse.itse_cdconstantecalculo IN (24) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=1 and orbo_iccalcada= 1) "
					+ " OR (itse.itse_cdconstantecalculo = 25 and amen.AMEN_ICEXECUCAO = 2 and amen.AMEN_ICVISITAREALIZADA =1) "
					+ " OR (itse.itse_cdconstantecalculo IN (26) AND orbo.orbo_icpavimento = 2 AND orbo_iccalcada= 1) "
					+ " ORDER BY idItemServico) itensServico  "
					+ " GROUP BY idItemServico, cdItemServico, descricaoServico, quantidadeOrcada, valorUnitario, unidadeItem, valorOrcado  "
					+ " UNION "
					+ " SELECT itensServico.idItemServico,  "
					+ " itensServico.descricaoServico,  "
					+ " itensServico.quantidadeOrcada,  "
					+ " itensServico.valorUnitario,  "
					+ " ROUND(sum(itensServico.quantidade), 0) as quantidadeItem,  "
					+ " (itensServico.valorUnitario * ROUND(sum(itensServico.quantidade), 0)) as valorItem,  "
					+ " itensServico.unidadeItem,  "
					+ " itensServico.valorOrcado,  "
					+ " (itensServico.valorUnitario * ROUND(sum(itensServico.quantidade), 0)) AS valorMedidoPeriodo, "
					+ " itensServico.cdItemServico  "
					+ " FROM (SELECT  "
					+ " itse.itse_id AS idItemServico,  "
					+ " itse.itse_dsitemservico AS descricaoServico,  "
					+ " itsc.itsc_qtorcadaitemservico AS quantidadeOrcada,  "
					+ " (CASE WHEN itse.itse_cdconstantecalculo = 15 THEN orbo.orbo_nnrepasfalto  "
					+ " WHEN itse.itse_cdconstantecalculo = 16 THEN orbo.orbo_nnrepparalelo  "
					+ " WHEN itse.itse_cdconstantecalculo = 17 THEN orbo.orbo_nnrepcalcada END) AS quantidade, "
					+ " itsc.itsc_vlitemservcontr AS valorUnitario,  "
					+ " (CASE WHEN itse.itse_cdconstantecalculo IN (15, 16, 17) THEN 'M2'  "
					+ " ELSE '' END) AS unidadeItem,  "
					+ " itsc.itsc_vlorcadoitemservico AS valorOrcado,  "
					+ " itsc.itsc_vlitemservcontr AS valorMedidoPeriodo, "
					+ " itse.itse_cdconstantecalculo AS cdItemServico "
					+ " FROM cobranca.cobr_boletim_exec cbex  "
					+ " INNER JOIN cobranca.cobr_boletim_medicao cobm ON (cbex.cobm_id = cobm.cobm_id) "
					+ " INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id AND cobm.cese_id = :idContrato AND cobc.cobc_id = :idBoletimContrato)  "
					+ " INNER JOIN micromedicao.item_servico_contrato itsc ON (cobm.cese_id = itsc.cese_id) "
					+ " INNER JOIN micromedicao.item_servico itse ON (itsc.itse_id = itse.itse_id)  "
					+ " LEFT  JOIN atendimentopublico.ordem_servico_boletim orbo ON (cbex.orse_id = orbo.orse_id) "
					+ " WHERE (itse.itse_cdconstantecalculo > 14 and itse.itse_cdconstantecalculo < 18) "
					+ " ORDER BY idItemServico) itensServico  "
					+ " GROUP BY idItemServico, cdItemServico, descricaoServico, quantidadeOrcada, valorUnitario, unidadeItem, valorOrcado  "
					+ " ORDER BY idItemServico  ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricaoServico", Hibernate.STRING)
					.addScalar("quantidadeOrcada", Hibernate.BIG_DECIMAL)
					.addScalar("valorUnitario", Hibernate.BIG_DECIMAL)
					.addScalar("quantidadeItem", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("unidadeItem", Hibernate.STRING)
					.addScalar("valorOrcado", Hibernate.BIG_DECIMAL)
					.addScalar("valorMedidoPeriodo", Hibernate.BIG_DECIMAL)
					.addScalar("cdItemServico", Hibernate.INTEGER)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * Método que vai retornar as quantidades acumuladas e os valores acumulados
	 * no período para geração do relatório de acompanhamento do boletim de
	 * medição de cobrança.
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoAcumuladas(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = " SELECT itensServico.idItemServico, "// 0 - ID
																	// Item
																	// Serviço
					+ "   itensServico.descricaoServico, "// 1 - Descrição Item
															// Serviço
					+ "   sum(itensServico.quantidade) as quantidadeAcumuladaPeriodo,  "// 2
																						// -
																						// Quantidade
																						// Acumulada
																						// Período
					+ "   sum(itensServico.valorMedidoPeriodo) AS valorAcumuladoPeriodo  "// 3
																							// -
																							// Valor
																							// Acumulado
																							// Período
					+ " FROM (SELECT  "
					+ "      itse.itse_id AS idItemServico,  "
					+ "      itse.itse_dsitemservico AS descricaoServico, "
					+ "      1 AS quantidade,  "
					+ "      cbex.cbex_vlservico AS valorMedidoPeriodo  "
					+ "     FROM cobranca.cobr_boletim_exec cbex  "
					+ "      INNER JOIN cobranca.cobr_boletim_medicao cobm ON (cbex.cobm_id = cobm.cobm_id)  "
					+ "      INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id)  "
					+ "      INNER JOIN micromedicao.contrato_empresa_servico cese ON (cobc.cese_id = cese.cese_id AND cese.cese_id = :idContrato)  "
					+ "      INNER JOIN atendimentopublico.ordem_servico orse ON (cbex.orse_id = orse.orse_id)  "
					+ "      INNER JOIN micromedicao.item_contrato_servico_tipo icst ON (icst.svtp_id = orse.svtp_id)  "
					+ "      INNER JOIN micromedicao.item_servico_contrato itsc ON (cese.cese_id = itsc.cese_id AND icst.itsc_id = itsc.itsc_id)  "
					+ "      INNER JOIN micromedicao.item_servico itse ON (itsc.itse_id = itse.itse_id)  "
					+ "      LEFT OUTER JOIN atendimentopublico.ordem_servico_boletim orbo ON (cbex.orse_id = orbo.orse_id)  "
					+ "		 LEFT JOIN atendimentopublico.ATEND_MOTIVO_ENCMT amen on amen.amen_id = orse.amen_id "
					+ "     WHERE (itse.itse_cdconstantecalculo IN (2,6) AND orbo.orbo_icpavimento = 3) "
					+ "      OR (itse.itse_cdconstantecalculo IN (3,7,9,11,13) AND orbo.orbo_icpavimento = 2)  "
					+ "      OR (itse.itse_cdconstantecalculo IN (4,8,10,12,14) AND orbo.orbo_icpavimento = 1)  "
					+ "      OR (itse.itse_cdconstantecalculo IN (1,5)) "
					+ "      OR (itse.itse_cdconstantecalculo IN (1,5))  "
					+ " 	 OR (itse.itse_cdconstantecalculo IN (18) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=1) "
					+ "		 OR (itse.itse_cdconstantecalculo IN (19) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=2) "
					+ "		 OR (itse.itse_cdconstantecalculo IN (20) AND orbo.orbo_icpavimento = 2 AND orbo_iccalcada=2) "
					+ " 	 OR (itse.itse_cdconstantecalculo IN (21) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=2 and orbo_iccalcada=2) "
					+ " 	 OR (itse.itse_cdconstantecalculo IN (22) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=2 and orbo_iccalcada=1) "
					+ "		 OR (itse.itse_cdconstantecalculo IN (23) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=1 and orbo_iccalcada=2) "
					+ " 	 OR (itse.itse_cdconstantecalculo IN (24) AND orbo.orbo_icpavimento = 1 AND orbo_cdtipopavimento=1 and orbo_iccalcada=1) "
					+ " 	 OR (itse.itse_cdconstantecalculo = 25 and amen.AMEN_ICEXECUCAO = 2 and amen.AMEN_ICVISITAREALIZADA =1) "
					+ " 	 OR (itse.itse_cdconstantecalculo IN (26) AND orbo.orbo_icpavimento = 2 AND orbo_iccalcada=1) "
					+ "     ORDER BY idItemServico) itensServico  "
					+ " GROUP BY idItemServico, descricaoServico  "
					+ " UNION "
					+ " SELECT itensServico.idItemServico, "
					+ "   itensServico.descricaoServico, "
					+ "   ROUND(sum(itensServico.quantidade), 0) as quantidadeAcumuladaPeriodo, "
					+ "   (itensServico.valorMedidoPeriodo * ROUND(sum(itensServico.quantidade), 0)) AS valorAcumuladoPeriodo  "
					+ " FROM (SELECT  "
					+ "      itse.itse_id AS idItemServico,  "
					+ "      itse.itse_dsitemservico AS descricaoServico,  "
					+ "       (CASE WHEN itse.itse_cdconstantecalculo = 15 THEN orbo.orbo_nnrepasfalto  "
					+ " 	WHEN itse.itse_cdconstantecalculo = 16 THEN orbo.orbo_nnrepparalelo  "
					+ " 	WHEN itse.itse_cdconstantecalculo = 17 THEN orbo.orbo_nnrepcalcada END) AS quantidade,   "
					+ "      itsc.itsc_vlitemservcontr AS valorMedidoPeriodo  "
					+ "     FROM cobranca.cobr_boletim_exec cbex  "
					+ "      INNER JOIN cobranca.cobr_boletim_medicao cobm ON (cbex.cobm_id = cobm.cobm_id)  "
					+ "      INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id AND cobm.cese_id = :idContrato)   "
					+ "      INNER JOIN micromedicao.item_servico_contrato itsc ON (cobm.cese_id = itsc.cese_id)  "
					+ "      INNER JOIN micromedicao.item_servico itse ON (itsc.itse_id = itse.itse_id)  "
					+ "      LEFT  JOIN atendimentopublico.ordem_servico_boletim orbo ON (cbex.orse_id = orbo.orse_id) "

					+ "     WHERE (itse.itse_cdconstantecalculo > 14 and itse.itse_cdconstantecalculo < 18) "
					+ "     ORDER BY idItemServico) itensServico  "
					+ " GROUP BY idItemServico, descricaoServico, valorMedidoPeriodo  "
					+ " ORDER BY idItemServico ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricaoServico", Hibernate.STRING)
					.addScalar("quantidadeAcumuladaPeriodo", Hibernate.INTEGER)
					.addScalar("valorAcumuladoPeriodo", Hibernate.BIG_DECIMAL)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarTaxaSucessoBoletimMedicaoContrato(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		BigDecimal taxaSucesso = new BigDecimal("0.00");

		try {
			String consulta = " SELECT sum(cbsu.CBSU_VLTXSUCESSO) AS taxaSucesso "
					+ " FROM cobranca.COBR_BOLETIM_SUCESSO cbsu "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm on (cbsu.cobm_id = cobm.cobm_id) "
					+ "   INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id and cobc.cobc_id = :idBoletimContrato) "
					+ "   INNER JOIN micromedicao.contrato_empresa_servico cese on (cobc.cese_id = cese.cese_id and cese.cese_id = :idContrato) ";

			taxaSucesso = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("taxaSucesso", Hibernate.BIG_DECIMAL)
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato())
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return taxaSucesso;
	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * 
	 * @return Collection<BigDecimal>
	 * @throws ErroRepositorioException
	 */
	public Collection<BigDecimal> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidades(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {
		Collection<BigDecimal> relatorios = null;
		try {
			relatorios = this
					.filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesOSFiscalizacao(filtro);
			relatorios
					.addAll(this
							.filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesCorteSupressaoNaoRealizacaoServico(filtro));
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}
		return relatorios;
	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * 
	 * @return Collection<BigDecimal>
	 * @throws ErroRepositorioException
	 */
	private Collection<BigDecimal> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesOSFiscalizacao(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> relatorios = new ArrayList<Object[]>();
		Collection<BigDecimal> retorno = new ArrayList<BigDecimal>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "SELECT "
					+ "   SUM((SELECT cbde.cbde_vldesconto "
					+ "      FROM atendimentopublico.ordem_servico orse "
					+ "      WHERE orse.orse_id = cbde.orse_id AND orse.amen_id = 32)) AS penalidadeOS, "// 0
																											// -
																											// Penalidade
																											// OS
					+ "   SUM((SELECT cbde.cbde_vldesconto "
					+ "      FROM atendimentopublico.ordem_servico orse "
					+ "      WHERE orse.orse_id = cbde.orse_id AND orse.amen_id != 32)) AS penalidadeFiscalizacao "// 0
																													// -
																													// Penalidade
																													// Fiscalização
					+ " FROM cobranca.COBR_BOLETIM_DESC cbde "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm on (cbde.cobm_id = cobm.cobm_id) "
					+ "   INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id and cobc.cobc_id = :idBoletimContrato) "
					+ "   INNER JOIN micromedicao.CONTRATO_EMPRESA_SERVICO cese on (cobc.cese_id = cese.cese_id and cese.cese_id = :idContrato) ";

			relatorios = session
					.createSQLQuery(consulta)
					.addScalar("penalidadeOS", Hibernate.BIG_DECIMAL)
					.addScalar("penalidadeFiscalizacao", Hibernate.BIG_DECIMAL)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato()).list();

			Object[] penalidades = relatorios.iterator().next();
			BigDecimal penalidadeOS = new BigDecimal("0.00");
			if (penalidades[0] != null) {
				penalidadeOS = (BigDecimal) penalidades[0];
			}
			BigDecimal penalidadeFiscalizacao = new BigDecimal("0.00");
			if (penalidades[1] != null) {
				penalidadeFiscalizacao = (BigDecimal) penalidades[1];
			}
			retorno.add(penalidadeOS);
			retorno.add(penalidadeFiscalizacao);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * 
	 * @return Collection<BigDecimal>
	 * @throws ErroRepositorioException
	 */
	private Collection<BigDecimal> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesCorteSupressaoNaoRealizacaoServico(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> relatorios = new ArrayList<Object[]>();
		Collection<BigDecimal> retorno = new ArrayList<BigDecimal>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "SELECT "
					+ "   SUM((SELECT (cbex.cbex_vlservico) * 2 "
					+ "        FROM cobranca.motivo_nao_aceit_enc_os mnac "
					+ "        WHERE caon.mnac_id = mnac.mnac_id and mnac.mnac_nnmultdesccortesupindev IS NOT NULL)) AS penalidadeCorteSupressao, "
					+ "   SUM((SELECT (cbex.cbex_vlservico) * 2 "
					+ "        FROM cobranca.motivo_nao_aceit_enc_os mnac "
					+ "        WHERE caon.mnac_id = mnac.mnac_id and mnac.mnac_nnmultdescservnaoexec IS NOT NULL)) AS penalidadeNaoRealizacaoServico "
					+ " FROM cobranca.cobr_boletim_exec cbex "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm on (cbex.cobm_id = cobm.cobm_id) "
					+ "   INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id and cobc.cobc_id = :idBoletimContrato) "
					+ "   INNER JOIN micromedicao.contrato_empresa_servico cese on (cobc.cese_id = cese.cese_id and cese.cese_id = :idContrato) "
					+ "   INNER JOIN cobranca.cob_ac_os_nao_aceitas caon on (cbex.orse_id = caon.orse_id) ";

			relatorios = session
					.createSQLQuery(consulta)
					.addScalar("penalidadeCorteSupressao",
							Hibernate.BIG_DECIMAL)
					.addScalar("penalidadeNaoRealizacaoServico",
							Hibernate.BIG_DECIMAL)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato()).list();

			Object[] penalidades = relatorios.iterator().next();
			BigDecimal penalidadeCorteSupressao = new BigDecimal("0.00");
			if (penalidades[0] != null) {
				penalidadeCorteSupressao = (BigDecimal) penalidades[0];
			}
			BigDecimal penalidadeNaoRealizacaoServicos = new BigDecimal("0.00");
			if (penalidades[1] != null) {
				penalidadeNaoRealizacaoServicos = (BigDecimal) penalidades[1];
			}
			retorno.add(penalidadeCorteSupressao);
			retorno.add(penalidadeNaoRealizacaoServicos);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 23/11/2011
	 */
	public boolean existeParcelamentoQuantidadePrestacaoSituacaoLigacaoAgua(
			Integer idSituacaoLigacaoAgua,
			Integer idParcelamentoQuantidadePrestacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Integer quantidade = null;
		boolean retorno = false;

		try {
			consulta = "select pqps.id "
					+ " from ParcelamentoQuantidadePrestacaoSituacaoLigacaoAgua pqps "
					+ " where pqps.ligacaoAguaSituacao.id = :idSituacaoLigacaoAgua and "
					+ " pqps.parcelamentoQuantidadePrestacao.id = :idParcelamentoQuantidadePrestacao ";

			quantidade = (Integer) session
					.createQuery(consulta)
					.setInteger("idSituacaoLigacaoAgua", idSituacaoLigacaoAgua)
					.setInteger("idParcelamentoQuantidadePrestacao",
							idParcelamentoQuantidadePrestacao).setMaxResults(1)
					.uniqueResult();

			if (quantidade != null && quantidade > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna uma colecao de ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 28/11/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResolucaoDiretoria pesquisarResolucaoDiretoriaPortal()
			throws ErroRepositorioException {

		ResolucaoDiretoria retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from ResolucaoDiretoria rd "
					+ "where  "
					+ "(rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual) "
					+ "and rd.indicadorParcelamentoLojaVirtual = :indicadorParcelamentoLojaVirtual ";

			retorno = (ResolucaoDiretoria) session
					.createQuery(consulta)
					.setDate("dataAtual", new Date())
					.setShort("indicadorParcelamentoLojaVirtual",
							ConstantesSistema.SIM).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * Verifica a quantidade de boletim de contrato para o mês/ano
	 * 
	 * @author Mariana Victor
	 * @date 15/12/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeBoletimMedicaoContrato(Integer idContrato)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		Integer quantidade = null;

		try {
			String consulta = " select count(*) AS quantidade "
					+ " from cobranca.cobr_boletim_contrato "
					+ " where cobc_amreferencia = :amReferencia "
					+ " and cese_id = :idContrato ";

			quantidade = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("amReferencia",
							Util.recuperaAnoMesDaData(new Date()))
					.setInteger("idContrato", idContrato).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return quantidade;
	}

	/**
	 * [UC1257] - Gerar Relatório dos Imóveis e Contas Retirados das Empresas de
	 * Cobrança
	 * 
	 * @author: Hugo Azevedo
	 * @date: 19/12/2011
	 */
	public Collection obterRelatorioImoveisRetiradosEmpresasCobranca(
			Integer idEmpresa, int amReferenciaInicial, int amReferenciaFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {
			String sql = " select distinct irc.imov_id as idImovel, "
					+ // 1
					" irc.cecc_id as idComando, "
					+ // 2
					" imov.loca_id as idLocalidade, "
					+ // 3
					" sc.stcm_cdsetorcomercial as codSetorComercial, "
					+ // 4
					" q.qdra_nnquadra as numeroQuadra, "
					+ // 5
					" imov.imov_nnlote as numeroLote, "
					+ // 6
					" imov.imov_nnsublote as numeroSubLote, "
					+ // 7
					" cecc.cecc_dtexecucao as dataExecucao, "
					+ // 8
					" irc.imrc_dtretirada as dataRetirada, "
					+ // 9
					" mrc.mrcb_dsmotivoretirada as motivoRetirada "
					+ // 10
					" from cobranca.imovel_retirada_comando irc "
					+ " inner join cobranca.empresa_cobranca_conta ecc on (irc.imov_id = ecc.imov_id and irc.cecc_id = ecc.cecc_id) "
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on (ecc.cecc_id = cecc.cecc_id) "
					+ " inner join cadastro.imovel imov on (irc.imov_id = imov.imov_id) "
					+ " inner join cadastro.setor_comercial sc on (sc.stcm_id = imov.stcm_id) "
					+ " inner join cadastro.quadra q on (q.qdra_id = imov.qdra_id) "
					+ " inner join cadastro.motivo_retirada_cobranca mrc on (mrc.mrcb_id = irc.mrcb_id) "
					+ " where irc.imrc_dtretirada between :amReferenciaInicial and :amReferenciaFinal "
					+ " and cecc.empr_id = :codEmpresa "
					+ " order by irc.imov_id, irc.cecc_id";

			System.out.println(sql);

			retorno = session
					.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					// 1
					.addScalar("idComando", Hibernate.INTEGER)
					// 2
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 3
					.addScalar("codSetorComercial", Hibernate.INTEGER)
					// 4
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					// 5
					.addScalar("numeroLote", Hibernate.INTEGER)
					// 6
					.addScalar("numeroSubLote", Hibernate.INTEGER)
					// 7
					.addScalar("dataExecucao", Hibernate.DATE)
					// 8
					.addScalar("dataRetirada", Hibernate.DATE)
					// 9
					.addScalar("motivoRetirada", Hibernate.STRING)
					// 10
					.setDate(
							"amReferenciaInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(amReferenciaInicial))
					.setDate(
							"amReferenciaFinal",
							Util.gerarDataApartirAnoMesRefencia(amReferenciaFinal))
					.setInteger("codEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1257] - Gerar Relatório dos Imóveis e Contas Retirados das Empresas de
	 * Cobrança
	 * 
	 * @author: Hugo Azevedo
	 * @date: 19/12/2011
	 */
	public Integer obterQtdRelatorioImoveisRetiradosEmpresasCobranca(
			Integer idEmpresa, int amReferenciaInicial, int amReferenciaFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer retorno = new Integer(0);

		try {
			String sql = " select count(distinct irc.imov_id) as idImovel "
					+ " from cobranca.imovel_retirada_comando irc "
					+ " inner join cobranca.empresa_cobranca_conta ecc on (irc.imov_id = ecc.imov_id and irc.cecc_id = ecc.cecc_id) "
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on (ecc.cecc_id = cecc.cecc_id) "
					+ " where irc.imrc_dtretirada between :amReferenciaInicial and :amReferenciaFinal "
					+ " and cecc.empr_id = :codEmpresa ";

			retorno = (Integer) session
					.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setDate(
							"amReferenciaInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(amReferenciaInicial))
					.setDate(
							"amReferenciaFinal",
							Util.gerarDataApartirAnoMesRefencia(amReferenciaFinal))
					.setInteger("codEmpresa", idEmpresa).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1257] - Gerar Relatório dos Imóveis e Contas Retirados das Empresas de
	 * Cobrança
	 * 
	 * @author: Hugo Azevedo
	 * @date: 19/12/2011
	 */
	public Collection obterRelatorioContasRetiradasEmpresasCobranca(
			Integer idImovel, Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {

			String sql = " select "
					+ " ecc.ecco_amreferenciaconta as amreferencia, "
					+ // 1
					" ecc.ecco_vloriginalconta as valorOriginal, "
					+ // 2
					" ecc.ecco_dtenvioconta as dataEnvio, "
					+ // 3
					" ecc.ecco_dtretiradaconta as dataRetirada, "
					+ // 4
					" mrc.mrcb_dsmotivoretirada as motivoRetirada "
					+ // 5
					" from cobranca.empresa_cobranca_conta ecc "
					+ " inner join cadastro.motivo_retirada_cobranca mrc on (mrc.mrcb_id = ecc.mrcb_id) "
					+ " where ecc.imov_id = :idImovel "
					+ " and ecc.cecc_id = :idComando "
					+ " and ecc.ecco_dtretiradaconta is not null "
					+ " order by ecc.ecco_amreferenciaconta";

			retorno = session.createSQLQuery(sql)
					.addScalar("amreferencia", Hibernate.INTEGER)
					// 1
					.addScalar("valorOriginal", Hibernate.BIG_DECIMAL)
					// 2
					.addScalar("dataEnvio", Hibernate.DATE)
					// 3
					.addScalar("dataRetirada", Hibernate.DATE)
					// 4
					.addScalar("motivoRetirada", Hibernate.STRING)
					// 5
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imoveis e COntas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa os comandos que podem ser retirados imoveis e
	 * cobrança
	 * 
	 * @author Raimundo Martins
	 * @date 13/12/2011
	 * */
	public Collection<ComandoEmpresaCobrancaConta> pesquisarDadosRetirarImoveisContasEmpresaCobranca(
			Integer idEmpresa, Date periodoIni, Date periodoFin,
			Integer numPaginas, Integer quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<ComandoEmpresaCobrancaConta> retorno = null;
		try {
			String hql = "SELECT c FROM ComandoEmpresaCobrancaConta c WHERE c.empresa.id = :idEmpresa "
					+ " AND c.dataExecucao is not null ";
			if (periodoIni != null && periodoFin != null) {
				hql += " AND c.dataExecucao >= :periodoIni AND c.dataExecucao <= :periodoFin";
			}
			hql += " ORDER BY c.id";
			Query q = session.createQuery(hql).setInteger("idEmpresa",
					idEmpresa);
			if (periodoIni != null && periodoFin != null) {
				q.setDate("periodoIni", periodoIni);
				q.setDate("periodoFin", periodoFin);
			}
			/*
			 * if(numPaginas != 0){ retorno =
			 * q.setMaxResults(quantidadeRegistros
			 * ).setFirstResult(numPaginas*quantidadeRegistros).list(); }else{
			 * retorno = q.list(); }
			 */

			retorno = q.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imoveis e COntas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa a quantidade de contas por comando cujo a data de
	 * retirada seja nula
	 * 
	 * @author Raimundo Martins
	 * @date 13/12/2011
	 * */
	public Integer pesquisarqtdContasPorComandoDtRetiradaComandoNulo(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String hql = "SELECT COUNT(DISTINCT ecco.contaGeral.id) FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando "
					+ " AND ecco.dataRetiradaConta is null "
					+ " AND ecco.cdIncluido is null";
			retorno = (Integer) session.createQuery(hql)
					.setInteger("idComando", idComando).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa a quantidade de comandos que podem ser retirados das
	 * empresas de cobrança
	 * 
	 * @author Raimundo Martins
	 * @date 14/12/2011
	 * */

	public Integer pesquisarDadosRetirarImoveisContasEmpresaCobrancaCount(
			Integer idEmpresa, Date periodoIni, Date periodoFin)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String hql = "SELECT COUNT(DISTINCT c.id) FROM ComandoEmpresaCobrancaConta c WHERE c.empresa.id = :idEmpresa "
					+ " AND c.dataExecucao is not null";
			if (periodoIni != null && periodoFin != null) {
				hql += " AND c.dataExecucao >= :periodoIni AND c.dataExecucao <= :periodoFin";
			}
			Query q = session.createQuery(hql).setInteger("idEmpresa",
					idEmpresa);
			if (periodoIni != null && periodoFin != null) {
				q.setDate("periodoIni", periodoIni);
				q.setDate("periodoFin", periodoFin);
			}
			retorno = (Integer) q.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa os imóveis que vão ser retirados de cobrança por
	 * empresa a partir do comando
	 * 
	 * @author Raimundo Martins
	 * @date 15/12/2011
	 * */

	public Collection<Imovel> pesquisarImoveisRetirarComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Imovel> retorno = null;
		try {
			String hql = "SELECT distinct ecco.imovel FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando "
					+ " AND ecco.dataRetiradaConta is null AND ecco.cdIncluido is null";
			retorno = session.createQuery(hql)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança [SB0005 -
	 * Verificar vencimento da conta]
	 * 
	 * Metodo que pesquisa as contas do imóveis que podem ser retirados
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */

	public Collection<Integer> pesquisarContasNaoVencidas(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Collection<Integer> retorno = new ArrayList<Integer>();
		retorno.addAll(this.pesquisarContasNaoVencidasEmConta(idComando,
				idImovel));
		retorno.addAll(this.pesquisarContasNaoVencidasEmContaHistorico(
				idComando, idImovel));
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança [SB0004 -
	 * Retirar Conta de Cobrança]
	 * 
	 * Metodo que retira as contas de cobrança
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public void retirarContasDeCobranca(Integer idComando, Integer idConta,
			Integer idMotivoRetirada) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "UPDATE gcom.cobranca.EmpresaCobrancaConta SET mrcb_id = :idMotivoRetirada, ecco_dtretiradaconta = :dataAtual, "
					+ " ecco_tmultimaalteracao = :dataAtual2 WHERE cecc_id = :idComando and cnta_id = :idConta AND ecco_cdincluido IS NULL";
			session.createQuery(sql).setInteger("idComando", idComando)
					.setInteger("idConta", idConta)
					.setDate("dataAtual", new Date())
					.setTimestamp("dataAtual2", new Date())
					.setInteger("idMotivoRetirada", idMotivoRetirada)
					.executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que verifica a quantidade de contas por comando e imovel
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public Integer quantidadeContasPorImovelEComando(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String sql = "SELECT COUNT(distinct ecco.cnta_id) as cont FROM cobranca.empresa_cobranca_conta ecco "
					+ " WHERE ecco.cecc_id = :idComando AND ecco.imov_id = :idImovel AND ecco.ecco_dtretiradaconta is null "
					+ " AND ecco.ecco_cdincluido is null";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("cont", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que verifica se as contas de determinado imóvel estão pagas ou em
	 * parcelamento
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public Collection<Integer> pesquisarContasPagasOuParceladas(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Collection<Integer> retorno = new ArrayList<Integer>();
		retorno.addAll(this.pesquisarContasPagas(idComando, idImovel));
		retorno.addAll(this.pesquisarContasParceladas(idComando, idImovel));
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que verifica se a conta esta paga
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public Boolean contaPaga(Integer idConta) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Boolean retorno = false;
		try {
			String sql = "SELECT pg.conta as id FROM ("
					+ "	SELECT pgmt.cnta_id as conta FROM arrecadacao.pagamento pgmt "
					+ "	UNION	"
					+ "	SELECT pghi.cnta_id FROM arrecadacao.pagamento_historico pghi"
					+ "	) pg " + " WHERE pg.conta = :idConta";

			id = (Integer) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idConta", idConta).uniqueResult();

			if (id != null && id > 0)
				retorno = true;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Boolean contaParcelada(Integer idConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Boolean retorno = false;
		try {
			String sql = "SELECT pg.conta as id FROM ("
					+ "	SELECT pgmt.cnta_id as conta FROM arrecadacao.pagamento pgmt "
					+ "	UNION	"
					+ "	SELECT pghi.cnta_id FROM arrecadacao.pagamento_historico pghi"
					+ "	) pg " + " WHERE pg.conta = :idConta";

			id = (Integer) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idConta", idConta).uniqueResult();

			if (id != null && id > 0)
				retorno = true;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa a data de envio do imóvel para cobrança
	 * 
	 * @author Raimundo Martins
	 * @date 19/12/2011
	 * */

	public Date pesquisarDataEnvioImovelCobranca(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Date retorno = null;
		try {
			String hql = "SELECT MIN(ecco.dataEnvioConta) FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando AND ecco.imovel.id = :idImovel AND ecco.cdIncluido is null";
			retorno = (Date) session.createQuery(hql)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa a data de envio do imóvel para cobrança
	 * 
	 * @author Raimundo Martins
	 * @date 19/12/2011
	 * */
	public Collection<Integer> pesquisarContasEmpresaCobrancaContaPorImovelComando(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id as id FROM cobranca.empresa_cobranca_conta ecco "
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND"
					+ " ecco.ecco_cdincluido is null";
			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa a quantidade de imovéis em cobrança para aquele
	 * comando
	 * 
	 * @author Raimundo Martins
	 * @date 19/12/2011
	 * */
	public Integer pesquisarqtdImoveisPorComandoDtRetiradaComandoNulo(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String hql = "SELECT COUNT(DISTINCT ecco.imovel) FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando "
					+ " AND ecco.cdIncluido is null "
					+ " AND ecco.imovel.id NOT IN (SELECT irc.imovel.id FROM ImovelRetiradaComando irc WHERE irc.comando.id = :idComando)";
			retorno = (Integer) session.createQuery(hql)
					.setInteger("idComando", idComando).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança [SB0005 -
	 * Verificar vencimento da conta]
	 * 
	 * Metodo que pesquisa as contas do imóveis que podem ser retirados na
	 * tabela conta
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasNaoVencidasEmConta(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT cnta.cnta_id AS id"
					+ " FROM  faturamento.conta cnta "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on cnta.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ " LEFT JOIN cobranca.cmd_empr_cobr_conta_ext ccce on ccce.ccce_id = ecco.ccce_id "
					+ " WHERE ecco.cecc_id = :idComando "
					+ " AND ecco.ecco_dtretiradaconta is null "
					+ " AND ecco.imov_id = :idImovel "
					+ " AND ecco.ecco_cdincluido is null"
					+ " AND ("
					+ "	CASE "
					+ "		WHEN ecco.ccce_id is not null and ccce.ccce_nndiasvencimentocontas is not null "
					+ "			THEN "
					+ "			cnta.cnta_dtvencimentooriginal > (to_date(:dataAtual,'YYYY-MM-DD') - ccce.ccce_nndiasvencimentocontas)	"
					+ "		WHEN cecc.cecc_qtddiasvencimento is not null "
					+ "			THEN		"
					+ "			cnta.cnta_dtvencimentooriginal > (to_date(:dataAtual,'YYYY-MM-DD') - cecc.cecc_qtddiasvencimento)"
					+ "	END )";
			SimpleDateFormat formatador = new SimpleDateFormat("yyyy-MM-dd");
			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel)
					.setString("dataAtual", formatador.format(new Date()))
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança [SB0005 -
	 * Verificar vencimento da conta]
	 * 
	 * Metodo que pesquisa as contas do imóveis que podem ser retirados na
	 * tabela conta historico
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasNaoVencidasEmContaHistorico(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT cnhi.cnta_id AS id"
					+ " FROM  faturamento.conta_historico cnhi "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on cnhi.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ " LEFT JOIN cobranca.cmd_empr_cobr_conta_ext ccce on ccce.ccce_id = ecco.ccce_id "
					+ " WHERE ecco.cecc_id = :idComando "
					+ " AND ecco.ecco_dtretiradaconta is null "
					+ " AND ecco.imov_id = :idImovel "
					+ " AND ecco.ecco_cdincluido is null"
					+ " AND ("
					+ "	CASE "
					+ "		WHEN ecco.ccce_id is not null and ccce.ccce_nndiasvencimentocontas is not null "
					+ "			THEN "
					+ "			cnhi.cnhi_dtvencimentooriginal > (to_date(:dataAtual,'YYYY-MM-DD') - ccce.ccce_nndiasvencimentocontas)	"
					+ "		WHEN cecc.cecc_qtddiasvencimento is not null "
					+ "			THEN		"
					+ "			cnhi.cnhi_dtvencimentooriginal > (to_date(:dataAtual,'YYYY-MM-DD') - cecc.cecc_qtddiasvencimento)"
					+ "	END )";

			SimpleDateFormat formatador = new SimpleDateFormat("yyyy-MM-dd");
			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel)
					.setString("dataAtual", formatador.format(new Date()))
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa as contas parceladas de determinado imovel
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasParceladas(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id as id FROM cobranca.empresa_cobranca_conta ecco "
					+ " INNER JOIN cobranca.parcelamento_item pcit on pcit.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cobranca.parcelamento parc on parc.parc_id = pcit.parc_id "
					+ " INNER JOIN cobranca.parcelamento_situacao pcst on pcst.pcst_id = parc.pcst_id "
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND "
					+ " ecco.ecco_cdincluido is null AND "
					+ " pcst.pcst_id = :situacaoParcelamento";

			retorno = session
					.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoParcelamento",
							ParcelamentoSituacao.NORMAL).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que pesquisa as contas pagas de determinado imovel
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasPagas(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id as id FROM  arrecadacao.pagamento pgmt "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on ecco.cnta_id = pgmt.cnta_id"
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND "
					+ " ecco.ecco_cdincluido is null ";

			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).list();

			sql = "SELECT ecco.cnta_id as id FROM  arrecadacao.pagamento_historico pghi "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on ecco.cnta_id = pghi.cnta_id"
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND "
					+ " ecco.ecco_cdincluido is null ";

			if (retorno != null && !retorno.isEmpty()) {
				Collection<Integer> retorno2 = session.createSQLQuery(sql)
						.addScalar("id", Hibernate.INTEGER)
						.setInteger("idComando", idComando)
						.setInteger("idImovel", idImovel).list();
				if (retorno2 != null && !retorno2.isEmpty()) {
					for (Integer idConta : retorno2) {
						if (!retorno.contains(idConta)) {
							retorno.add(idConta);
						}
					}
				}
			} else {
				retorno = session.createSQLQuery(sql)
						.addScalar("id", Hibernate.INTEGER)
						.setInteger("idComando", idComando)
						.setInteger("idImovel", idImovel).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança [SB0004 -
	 * Retirar Conta de Cobrança]
	 * 
	 * Metodo que retira as contas de cobrança através do imovel
	 * 
	 * @author Raimundo Martins
	 * @date 27/12/2011
	 * */
	public void retirarContasDeCobrancaPorImovel(Integer idComando,
			Integer idImovel, Integer idMotivoRetirada)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "UPDATE gcom.cobranca.EmpresaCobrancaConta SET mrcb_id = :idMotivoRetirada, ecco_dtretiradaconta = :dataAtual, "
					+ " ecco_tmultimaalteracao = :dataAtual2 WHERE cecc_id = :idComando and imov_id = :idConta and ecco_dtretiradaconta is null "
					+ " and ecco_cdincluido is null ";
			session.createQuery(sql).setInteger("idComando", idComando)
					.setInteger("idConta", idImovel)
					.setDate("dataAtual", new Date())
					.setTimestamp("dataAtual2", new Date())
					.setInteger("idMotivoRetirada", idMotivoRetirada)
					.executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0473] Consultar Dados Complementares do Imóvell
	 * 
	 * Metodo que pesquisa as contas enviadas para cobrança por imóvel
	 * 
	 * @author Raimundo Martins
	 * @date 27/12/2011
	 * */
	public Collection<Object[]> pesquisarContasEnviadasCobrancaPorImovel(
			Integer idImovel) throws ErroRepositorioException {
		Collection<Object[]> retorno = new ArrayList<Object[]>();
		retorno.addAll(pesquisarContasEnviadasCobrancaPorImovelEmConta(idImovel));
		retorno.addAll(pesquisarContasEnviadasCobrancaPorImovelEmContaHistorico(idImovel));
		return retorno;
	}

	private Collection<Object[]> pesquisarContasEnviadasCobrancaPorImovelEmConta(
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnta.cnta_amreferenciaconta as amRef, "
					+ "  ecco.ecco_vloriginalconta as vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao as descSitu "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta cnta "
					+ "ON ecco.cnta_id = cnta.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb "
					+ "ON iscb.iscb_dtimplantacaocobranca = cecc.cecc_dtexecucao "
					+ "AND iscb.imov_id                   = ecco.imov_id "
					+ "INNER JOIN COBRANCA.cobranca_situacao cbst ON cbst.cbst_id = iscb.cbst_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id             = cnta.dcst_idatual "
					+ "WHERE ecco.ecco_cdincluido IS NULL "
					+ "AND cbst.cbst_cdconstante = :conCobrancaSituacao "
					+ "AND ecco.imov_id            = :idImovel";
			retorno = session
					.createSQLQuery(sql)
					.addScalar("amRef", Hibernate.INTEGER)
					.addScalar("vlConta", Hibernate.BIG_DECIMAL)
					.addScalar("descSitu", Hibernate.STRING)
					.setInteger("conCobrancaSituacao",
							CobrancaSituacao.EMPRESA_DE_COBRANCA)
					.setInteger("idImovel", idImovel).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	private Collection<Object[]> pesquisarContasEnviadasCobrancaPorImovelEmContaHistorico(
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnhi.cnhi_amreferenciaconta  AS amRef, "
					+ "  ecco.ecco_vloriginalconta         AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta_historico cnhi "
					+ "ON ecco.cnta_id = cnhi.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb "
					+ "ON iscb.iscb_dtimplantacaocobranca = cecc.cecc_dtexecucao "
					+ "AND iscb.imov_id                   = ecco.imov_id "
					+ "INNER JOIN COBRANCA.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id             = cnhi.dcst_idatual "
					+ "WHERE ecco.ecco_cdincluido IS NULL "
					+ "AND cbst.cbst_cdconstante = :conCobrancaSituacao "
					+ "AND ecco.imov_id            = :idImovel";
			retorno = session
					.createSQLQuery(sql)
					.addScalar("amRef", Hibernate.INTEGER)
					.addScalar("vlConta", Hibernate.BIG_DECIMAL)
					.addScalar("descSitu", Hibernate.STRING)
					.setInteger("idImovel", idImovel)
					.setInteger("conCobrancaSituacao",
							CobrancaSituacao.EMPRESA_DE_COBRANCA).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0473] Consultar Dados Complementares do Imóvell
	 * 
	 * Metodo que pesquisa as contas pagas em cobrança por imóvel
	 * 
	 * @author Raimundo Martins
	 * @date 28/12/2011
	 * */
	public Collection<Object[]> pesquisarContasPagasEmCobrancaPorImovel(
			Integer idImovel) throws ErroRepositorioException {
		Collection<Object[]> retorno = new ArrayList<Object[]>();
		retorno.addAll(pesquisarContasPagasEmCobrancaPorImovelEmPagamento(idImovel));
		retorno.addAll(pesquisarContasPagasEmCobrancaPorImovelEmPagamentoHistorico(idImovel));
		return retorno;
	}

	private Collection<Object[]> pesquisarContasPagasEmCobrancaPorImovelEmPagamento(
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnta.cnta_amreferenciaconta  AS amRef, "
					+ "  pgmt.pgmt_vlpagamento         AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta cnta "
					+ "ON ecco.cnta_id = cnta.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb "
					+ "ON iscb.iscb_dtimplantacaocobranca = cecc.cecc_dtexecucao "
					+ "AND iscb.imov_id                   = ecco.imov_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id = cnta.dcst_idatual "
					+ "INNER JOIN ARRECADACAO.pagamento pgmt "
					+ "ON ecco.cnta_id             = pgmt.cnta_id "
					+ "AND ecco.imov_id            = pgmt.imov_id "
					+ "WHERE ecco.ecco_cdincluido IS NULL "
					+ "AND ecco.imov_id            = :idImovel";
			retorno = session.createSQLQuery(sql)
					.addScalar("amRef", Hibernate.INTEGER)
					.addScalar("vlConta", Hibernate.BIG_DECIMAL)
					.addScalar("descSitu", Hibernate.STRING)
					.setInteger("idImovel", idImovel).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	private Collection<Object[]> pesquisarContasPagasEmCobrancaPorImovelEmPagamentoHistorico(
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnta.cnta_amreferenciaconta  AS amRef, "
					+ "  pghi.pghi_vlpagamento             AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta cnta "
					+ "ON ecco.cnta_id = cnta.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb "
					+ "ON iscb.iscb_dtimplantacaocobranca = cecc.cecc_dtexecucao "
					+ "AND iscb.imov_id                   = ecco.imov_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id = cnta.dcst_idatual "
					+ "INNER JOIN ARRECADACAO.pagamento_historico pghi "
					+ "ON ecco.cnta_id             = pghi.cnta_id "
					+ "AND ecco.imov_id            = pghi.imov_id "
					+ "WHERE ecco.ecco_cdincluido IS NULL "
					+ "AND ecco.imov_id            = :idImovel";
			retorno = session.createSQLQuery(sql)
					.addScalar("amRef", Hibernate.INTEGER)
					.addScalar("vlConta", Hibernate.BIG_DECIMAL)
					.addScalar("descSitu", Hibernate.STRING)
					.setInteger("idImovel", idImovel).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1264] Incluir Contas em Cobrança
	 * 
	 * 1.1. Para cada parcelamento efetuado no mês 1.1.1. O sistema deverá
	 * verificar se o imóvel do parcelamento está associado a uma cobrança por
	 * resultado ou o parcelamento foi efetuado antes da data de retirada da
	 * cobrança por resultado 1.1.1.1. Para cada conta parcelada, o sistema
	 * deverá verificar se a mesma está em cobrança
	 * 
	 * @author Mariana Victor
	 * @date 27/12/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesArrecadacao
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarContasParceladasIncluirCobranca(
			Integer idLocalidade, Integer anoMesArrecadacao)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select cnta.imov_id AS imovel, "
					+ "   cnta.cnta_id AS conta, "
					+ "   cnta.cnta_amreferenciaconta AS referencia, "
					+ "   coalesce(cnta.cnta_vlagua, 0) "
					+ "    + coalesce(cnta.cnta_vlesgoto, 0) "
					+ "    + coalesce(cnta.cnta_vldebitos, 0) "
					+ "    - coalesce(cnta.cnta_vlcreditos, 0) "
					+ "    - coalesce(cnta.cnta_vlimpostos, 0) AS valorConta "
					+ " from cobranca.parcelamento parc "
					+ "   inner join cobranca.parcelamento_item pcit on parc.parc_id = pcit.parc_id "
					+ "   inner join faturamento.conta cnta on cnta.cnta_id = pcit.cnta_id "
					+ " where parc.loca_id = :idLocalidade "
					+ "   and parc.parc_tmparcelamento between :dataInicial and :dataFinal "
					+ "	  and parc.pcst_id = 1 "
					+ "   and exists (select iscb.imov_id "
					+ "           from cadastro.imovel_cobranca_situacao iscb "
					+ "             inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
					+ "           where iscb.imov_id = parc.imov_id "
					+ "             and cbst.cbst_cdconstante = 1 "
					+ "             and ((iscb.iscb_dtretiradacobranca is null "
					+ "				and (to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') >= iscb.iscb_dtimplantacaocobranca)) "
					+ "				or (iscb.iscb_dtretiradacobranca is not null "
					+ "                  and (to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') between "
					+ "                     iscb.iscb_dtimplantacaocobranca and iscb.iscb_dtretiradacobranca) "
					+ "                  )) "
					+ "				and not exists (select ecco.cnta_id "
					+ " 							from cobranca.empresa_cobranca_conta ecco "
					+ " 							inner join cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ " 								where ecco.cnta_id = pcit.cnta_id "
					+ " 									and (cecc.cecc_dtencerramento is null or to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and cecc.cecc_dtencerramento) "
					+ " 									and (ecco.ecco_dtretiradaconta is null or to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and ecco.ecco_dtretiradaconta)"
					+ " 								)"
					+ "					) "
					+ " group by cnta.imov_id, cnta.cnta_id, cnta.cnta_amreferenciaconta, "
					+ "   cnta.cnta_vlagua, cnta.cnta_vlesgoto, cnta.cnta_vldebitos, "
					+ "   cnta.cnta_vlcreditos, cnta.cnta_vlimpostos "
					+ " order by cnta.imov_id, cnta.cnta_id ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idLocalidade", idLocalidade)
					.setDate(
							"dataInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(anoMesArrecadacao))
					.setDate(
							"dataFinal",
							Util.gerarDataApartirAnoMesRefencia(anoMesArrecadacao))
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1264] Incluir Contas em Cobrança
	 * 
	 * @author Mariana Victor
	 * @date 27/12/2011
	 * 
	 * @param idImovel
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosImoveisIncluirCobranca(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select ecco.empr_id AS empresa,  "
					+ "   ecco.ecco_pcempresaconta AS percentual, "
					+ "   ecco.cecc_id AS comando, "
					+ "   ecco.orse_id AS ordemServico, "
					+ "   ecco.ccce_id AS comandoExtensao "
					+ " from cobranca.empresa_cobranca_conta ecco "
					+ " where ecco.imov_id = :idImovel "
					+ " order by ecco.ecco_tmultimaalteracao desc ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("empresa", Hibernate.INTEGER)
					.addScalar("percentual", Hibernate.BIG_DECIMAL)
					.addScalar("comando", Hibernate.INTEGER)
					.addScalar("ordemServico", Hibernate.INTEGER)
					.addScalar("comandoExtensao", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1250] Solicitar Geração/Emissão Boletim de Medição de Contratos
	 * 
	 * 1.6.2. O usuário informa o filtro e ao clicar no botão "Selecionar" o
	 * sistema deverá exibir, em uma tabela, todos os boletins de contrato
	 * 
	 * @author Mariana Victor
	 * @date 16/12/2011
	 * */
	public Collection<Object[]> pesquisarBoletimMedicaoContratoEmitir(
			Integer idContrato, Integer anoMes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = "select cobc.cobc_amreferencia AS anoMesRef, "
					+ "   cobc.cobc_id AS idBoletim, "
					+ "   cobc.cobc_dsboletimcontrato AS descricaoContrato  "
					+ " from cobranca.cobr_boletim_contrato cobc "
					+ " where cobc.cese_id = :idContrato "
					+ "   and cobc.cobc_amreferencia = :anoMes "
					+ " order by cobc.cobc_dsboletimcontrato ";

			return (Collection<Object[]>) session.createSQLQuery(sql)
					.addScalar("anoMesRef", Hibernate.INTEGER)
					.addScalar("idBoletim", Hibernate.INTEGER)
					.addScalar("descricaoContrato", Hibernate.STRING)
					.setInteger("idContrato", idContrato)
					.setInteger("anoMes", anoMes).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1264] Incluir Contas em Cobrança
	 * 
	 * 2.1.1. Para cada pagamento de conta efetuado no mês da arrecadação para
	 * os imóveis em situação de cobrança durante o mês 2.1.1.1. O sistema
	 * deverá verificar se a quantidade de dias do vencimento é diferente de
	 * nulo ou zero, caso seja, o sistema deverá verificar se o pagamento foi
	 * efetuado após a data de vencimento somando a quantidade de dias informada
	 * 2.1.1.2. Para cada conta que não exista na tabela EMPRESA_COBRANCA_CONTA
	 * 
	 * @author Mariana Victor
	 * @date 27/12/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesArrecadacao
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarContasPagasIncluirCobranca(
			Integer idLocalidade, Integer anoMesArrecadacao,
			Integer numeroDiasVencimentoCobrancaResultado,
			Integer numeroDiasEnvioContaEmpresaCobranca)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select cnta.imov_id AS imovel, "
					+ "   cnta.cnta_id AS conta, "
					+ "   cnta.cnta_amreferenciaconta AS referencia, "
					+ "   coalesce(cnta.cnta_vlagua, 0) "
					+ "    + coalesce(cnta.cnta_vlesgoto, 0) "
					+ "    + coalesce(cnta.cnta_vldebitos, 0) "
					+ "    - coalesce(cnta.cnta_vlcreditos, 0) "
					+ "    - coalesce(cnta.cnta_vlimpostos, 0) AS valorConta "
					+ " from arrecadacao.pagamento pgmt "
					+ "   inner join faturamento.conta cnta on cnta.cnta_id = pgmt.cnta_id "
					+ " where pgmt.loca_id = :idLocalidade "
					+ "   and pgmt.pgmt_dtpagamento between to_date(:dataInicial,'YYYY-MM-DD') and to_date(:dataFinal,'YYYY-MM-DD') "
					+ "	  and pgmt.pgst_idatual in(:CLASSIFICADO, :VALOR_NAO_CONFERE, :DOC_A_CONTABILIZAR) "
					+ "   and exists (select iscb.imov_id "
					+ "           from cadastro.imovel_cobranca_situacao iscb "
					+ "             inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
					+ "           where iscb.imov_id = pgmt.imov_id "
					+ "             and cbst.cbst_cdconstante = 1 "
					+ "             and ((iscb.iscb_dtretiradacobranca is null "
					+ "				and (to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') >= iscb.iscb_dtimplantacaocobranca)) "
					+ "				or (iscb.iscb_dtretiradacobranca is not null "
					+ "                  and (to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') between "
					+ "                     iscb.iscb_dtimplantacaocobranca and iscb.iscb_dtretiradacobranca) "
					+ "                  )) "
					+ "				and not exists (select ecco.cnta_id "
					+ "	                            from cobranca.empresa_cobranca_conta ecco "
					+ "	                              inner join cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ "	                            where ecco.cnta_id = pgmt.cnta_id "
					+ "									and (cecc.cecc_dtencerramento is null or to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and cecc.cecc_dtencerramento) "
					+ " 								and (ecco.ecco_dtretiradaconta is null  or to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and ecco.ecco_dtretiradaconta)"
					+ "	                           )" + "            ) ";

			// 2.1.1.1. O sistema deverá verificar se a quantidade de dias do
			// vencimento é diferente de nulo ou zero,
			// caso seja, o sistema deverá verificar se o pagamento foi efetuado
			// após a data de vencimento
			// somando a quantidade de dias informada
			if (numeroDiasVencimentoCobrancaResultado != null
					&& numeroDiasVencimentoCobrancaResultado
							.compareTo(new Integer(0)) > 0) {
				consulta = consulta
						+ "   and pgmt.pgmt_dtpagamento > (cnta.cnta_dtvencimentooriginal + :quantidadeDias) ";
			}

			// 2.1.1.2. Caso o indicador para incluir contas fora do vencimento
			// corresponda a não
			// 2.1.1.2.1. O sistema deverá verificar se a conta possui a
			// quantidade de dias de vencimento para cobrança
			if (numeroDiasEnvioContaEmpresaCobranca != null
					&& numeroDiasEnvioContaEmpresaCobranca
							.compareTo(new Integer(0)) > 0) {
				consulta = consulta
						+ "   and cnta.cnta_dtvencimentooriginal <= :dataComparacao ";
			}

			consulta = consulta
					+ " group by cnta.imov_id, cnta.cnta_id, cnta.cnta_amreferenciaconta, "
					+ "   cnta.cnta_vlagua, cnta.cnta_vlesgoto, cnta.cnta_vldebitos, "
					+ "   cnta.cnta_vlcreditos, cnta.cnta_vlimpostos "
					+ " order by cnta.imov_id, cnta.cnta_id ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idLocalidade", idLocalidade)
					.setDate(
							"dataInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(anoMesArrecadacao))
					.setDate(
							"dataFinal",
							Util.gerarDataApartirAnoMesRefencia(anoMesArrecadacao))
					.setInteger("CLASSIFICADO",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("VALOR_NAO_CONFERE",
							PagamentoSituacao.VALOR_NAO_CONFERE)
					.setInteger("DOC_A_CONTABILIZAR",
							PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);

			if (numeroDiasVencimentoCobrancaResultado != null
					&& numeroDiasVencimentoCobrancaResultado
							.compareTo(new Integer(0)) > 0) {
				query = query.setInteger("quantidadeDias",
						numeroDiasVencimentoCobrancaResultado);
			}
			if (numeroDiasEnvioContaEmpresaCobranca != null
					&& numeroDiasEnvioContaEmpresaCobranca
							.compareTo(new Integer(0)) > 0) {
				query = query.setDate("dataComparacao", Util
						.subtrairNumeroDiasDeUmaData(new Date(),
								numeroDiasEnvioContaEmpresaCobranca));
			}

			retorno = query.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0867] Atualizar Pagamentos Contas em Cobrança
	 * 
	 * Metodo que verifica o Documento de Cobranca pra uma conta paga
	 * 
	 * @author Raimundo Martins
	 * @date 28/12/2011
	 * */
	public Collection<Integer> pesquisarDocumentoCobrancaConta(
			Integer idPagamento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT pgmt.cbdo_id AS doc FROM ARRECADACAO.pagamento pgmt WHERE pgmt.pgmt_id = :idPagamento";
			retorno = session.createSQLQuery(sql)
					.addScalar("doc", Hibernate.INTEGER)
					.setInteger("idPagamento", idPagamento).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0867] Atualizar Pagamentos Contas em Cobrança
	 * 
	 * Metodo que pesquisa a data de retirada da conta de EmpresaCobrancaConta
	 * 
	 * @author Raimundo Martins
	 * @date 28/12/2011
	 * */
	public Date pesquisarDataRetiradaConta(Integer idEmpresaCobrancaConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Date retorno = null;
		try {
			String consulta = "select ecc.dataRetiradaConta "
					+ " from EmpresaCobrancaConta ecc "
					+ " inner join ecc.contaGeral cntaG "
					+ " where ecc.id = :idEmpresaCobrancaConta ";

			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idEmpresaCobrancaConta",
							idEmpresaCobrancaConta).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Metodo que verifica se o imovel ja foi retirado para aquele comando
	 * 
	 * @author Raimundo Martins
	 * @date 30/12/2011
	 * */
	public Boolean isImovelRetirado(Integer idImovel, Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Boolean retorno = false;
		try {
			String sql = "SELECT imrc.imov_id as id FROM cobranca.imovel_retirada_comando imrc "
					+ " WHERE imrc.imov_id = :idImovel AND imrc.cecc_id = :idComando";

			id = (Integer) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).uniqueResult();

			if (id != null && id > 0)
				retorno = true;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * Método que pesquisa se o comando possui setores associados na tabela
	 * cobranca.cmd_empr_cobr_conta_stcm
	 * 
	 * @author Raimundo Martins
	 * @date 02/12/2011
	 * 
	 * */
	public Collection<SetorComercial> pesquisarSetoresComerciaisComandoEmpresaCobrancaContaSetorComercial(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<SetorComercial> retorno = null;
		try {
			String sql = "SELECT cest.setorComercial FROM ComandoEmpresaCobrancaContaSetorComercial cest "
					+ " WHERE cest.comando.id = :idComando";
			retorno = session.createQuery(sql)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC 1256] Retirar Imóveis e Contas das Empresas de Cobrança
	 * 
	 * Método que atualiza a situação especial de cobrança do imovel
	 * 
	 * @author Raimundo Martins
	 * @date 02/02/2012
	 * */

	public void atualizarImovelSituacaoEspecialCobranca(Integer idImovel,
			String motivoRetirada, Integer anoMes)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "UPDATE gcom.cobranca.CobrancaSituacaoHistorico SET cbsh_dtfimsituacao = :dataAtual, "
					+ " cbsh_tmultimaalteracao = :dataAtual, cbsh_amcobrancaretirada = :anoMes, cbsh_dsobservacaoretira = :motivoRetirada "
					+ " WHERE imov_id = :idImovel AND cbsm_id = :idSituacaoMotivo AND cbsh_dtfimsituacao IS NULL";
			session.createQuery(sql)
					.setInteger("idImovel", idImovel)
					.setDate("dataAtual", new Date())
					.setInteger("anoMes", anoMes)
					.setString("motivoRetirada", motivoRetirada)
					.setInteger(
							"idSituacaoMotivo",
							CobrancaSituacaoMotivo.IMOVEIS_ENVIADOS_EMPRESA_TERCEIRIZADA)
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0896] Gerar Arquivo Texto das Contas em Cobrança por Empresa
	 * 
	 * Metodo que verifica a quantidade de contas para um determinado comando
	 * 
	 * @author Mariana Victor
	 * @date 09/02/2012
	 * */
	public Integer pesquisarQuantidadeContasComando(Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String sql = "SELECT COUNT(distinct ecco.cnta_id) as quantidade "
					+ " FROM cobranca.empresa_cobranca_conta ecco "
					+ " WHERE ecco.cecc_id = :idComando ";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idComando", idComando).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobrança por Empresa
	 * 
	 * [FS0006] - Verificar existência de dados para os comandos Caso algum dos
	 * comandos não tenha sido executado
	 * 
	 * @author Mariana Victor
	 * @date 09/02/2012
	 * */
	public boolean verificarComandoExecutado(Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		Integer quantidade = null;

		try {
			String sql = "SELECT COUNT(*) as quantidade "
					+ " FROM cobranca.cmd_empr_cobr_conta cecc "
					+ " WHERE cecc.cecc_id = :idComando "
					+ "       AND cecc.cecc_dtexecucao is not null ";

			quantidade = (Integer) session.createSQLQuery(sql)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idComando", idComando).uniqueResult();

			if (quantidade != null && quantidade > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Verifica se existem dados para serem gerados [UC1350] Gerar Arquivo Texto
	 * das Faturas Agrupadas
	 * 
	 * @author Amelia Pessoa
	 * @date 13/06/2012
	 */
	public Collection<Integer> verificarDadosFaturasAgrupadas(
			Integer anoMesInicial, Integer anoMesFinal,
			ArrayList<Integer> arvoreClientes) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {

			// Monta parte das faturas
			StringBuilder ids = new StringBuilder();
			for (int i = 0; i < arvoreClientes.size(); i++) {
				ids.append(arvoreClientes.get(i) + ",");
			}
			ids.delete(ids.length() - 1, ids.length()); // Retira a ultima
														// virgula

			String sql = "select ci.fitm_id as id from faturamento.fatura_item ci "
					+ " inner join Faturamento.fatura ff on ci.fatu_id = ff.fatu_id "
					+ " inner join faturamento.conta ct on ct.cnta_id = ci.cnta_id and dcst_idatual in (0,1,2) "
					+ " inner join cadastro.cliente cc on ff.clie_id = cc.clie_id  "
					+ " and ct.cnta_id not in (select pg.cnta_id from arrecadacao.pagamento pg where pg.cnta_id = ci.cnta_id)  "
					+ " where ff.fatu_amreferencia BETWEEN :anoMesInicial AND :anoMesFinal  "
					+ " and cc.clie_id in ( "
					+ " WITH RECURSIVE arvore_clientes (CLIE_ID,depth,path,cycle) AS (  "
					+ " SELECT CLIE_ID, 1, ARRAY[CLIE_ID], FALSE FROM CADASTRO.CLIENTE WHERE CLIE_ID IN ( "
					+ ids.toString()
					+ " ) "
					+ " UNION ALL  "
					+ " SELECT cc.CLIE_ID, c.depth+1, path || cc.CLIE_ID, cc.CLIE_ID = ANY(path)  FROM CADASTRO.CLIENTE cc  "
					+ " INNER JOIN arvore_clientes c ON cc.CLIE_CDCLIENTERESPONSAVEL = c.CLIE_ID AND NOT cycle)  "
					+ " SELECT CLIE_ID FROM arvore_clientes )";

			retorno = (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("anoMesInicial", anoMesInicial)
					.setInteger("anoMesFinal", anoMesFinal).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa quais os clientes existentes dado um intervalo de codigos
	 * [UC1350] Gerar Arquivo Texto das Faturas Agrupadas
	 * 
	 * @author Amelia Pessoa
	 * @date 13/06/2012
	 * @return Collection<Integer> com os ids dos clientes existentes
	 */
	public Collection<Integer> pesquisarClientes(Integer idClienteInicial,
			Integer idClienteFinal) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {

			String sql = "select CLIE_ID as id from CADASTRO.CLIENTE "
					+ " where CLIE_ID BETWEEN :idClienteInicial AND :idClienteFinal  ";

			retorno = (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idClienteInicial", idClienteInicial)
					.setInteger("idClienteFinal", idClienteFinal).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Busca os dados para serem gerados [UC1350] Gerar Arquivo Texto das
	 * Faturas Agrupadas
	 * 
	 * @author Amelia Pessoa
	 * @date 13/06/2012
	 */
	public Collection<FaturaItem> pesquisarFaturasAgrupadas(
			Integer anoMesInicial, Integer anoMesFinal,
			ArrayList<Integer> faturas) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<FaturaItem> retorno = null;
		try {

			String sql = "select fat from FaturaItem fat \n " + // 0
					" left join fetch fat.fatura ff \n " + // 1
					" left join fetch fat.imovel i \n " + // 2
					" left join fetch i.logradouroBairro lb \n " + // 2
					" left join fetch i.localidade \n " + // 2
					" left join fetch lb.bairro b \n " + // 2
					" left join fetch b.municipio \n m " + // 2
					" left join fetch m.unidadeFederacao \n " + // 2
					" left join fetch i.enderecoReferencia \n " + // 2
					" left join fetch i.logradouroCep lc \n " + // 3
					" left join fetch lc.cep \n " + // 3
					" left join fetch lc.logradouro l \n " + // 3
					" left join fetch l.logradouroTitulo lt \n " + // 3
					" left join fetch l.logradouroTipo ltt \n " + // 3
					" left join fetch fat.contaGeral cg \n " + // 4
					" left join fetch ff.cliente cc \n " + // 5
					" left join cg.conta ct  " + // 6
					" where  \n " + // 7
					" fat.id in ( "; // 12

			StringBuilder ids = new StringBuilder();
			for (int i = 0; i < faturas.size(); i++) {
				ids.append(faturas.get(i) + ",");
			}
			ids.delete(ids.length() - 1, ids.length()); // Retira a ultima
														// virgula

			sql += ids.toString() + " )";

			retorno = session.createQuery(sql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Obter nome do cliente [UC1350] Gerar Arquivo Texto das Faturas Agrupadas
	 * 
	 * @author Amelia Pessoa
	 * @date 13/06/2012
	 */
	public String obterNomeCliente(Integer clienteId)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String retorno = null;
		try {
			String sql = "SELECT nome FROM Cliente "
					+ " WHERE id = :clienteId ";

			retorno = (String) session.createQuery(sql)
					.setInteger("clienteId", clienteId).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Obtem os valores e percentuais de desconto por tipo de débito
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> obterValorEPercDescontoPorTipoDebitoPagParcelado(
			Integer idPerfilParc, Collection<Integer> colecaoIdContas)
			throws ErroRepositorioException {

		Collection<Object[]> retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select sum(dbcb_vlprestacao) as valorCobrado,"
					+ " dbcb.dbtp_id as idDebitoTipo,"
					+ " ppde_pcdescontoparcelado as percDescontoParcelado"
					+ " from faturamento.debito_cobrado dbcb"
					+ " inner join faturamento.conta cnta on cnta.cnta_id = dbcb.cnta_id"
					+ " inner join cobranca.parc_perfil_debitos ppde on ppde.dbtp_id = dbcb.dbtp_id"
					+ " where ppde.pcpf_id = :idPerfilParc"
					+ " and ppde_pcdescontoparcelado is not null"
					+ " and cnta.cnta_id in (:idContas)"
					+ " group by dbcb.dbtp_id,ppde_pcdescontoparcelado";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta)
					.addScalar("valorCobrado", Hibernate.BIG_DECIMAL)
					.addScalar("idDebitoTipo", Hibernate.INTEGER)
					.addScalar("percDescontoParcelado", Hibernate.BIG_DECIMAL)
					.setInteger("idPerfilParc", idPerfilParc)
					.setParameterList("idContas", colecaoIdContas).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 27/06/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterValorDebitoCobradoParcelamento(Integer idConta,
			Collection<Integer> idsTipoFinanciamento)
			throws ErroRepositorioException {

		BigDecimal retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select sum(debCobrado.valorPrestacao) "// 0
					+ "from DebitoCobrado debCobrado "
					+ "inner join debCobrado.financiamentoTipo finTipo "
					+ "inner join debCobrado.conta conta "
					+ "where conta.id = :idConta "
					+ "and finTipo.id in (:idsTipoFinanciamento)";

			retorno = (BigDecimal) session
					.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setParameterList("idsTipoFinanciamento",
							idsTipoFinanciamento).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 27/06/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterValorCreditoRealizadoParcelamento(Integer idConta,
			Collection<Integer> idsCreditoTipo) throws ErroRepositorioException {

		BigDecimal retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "SELECT  sum(crrz.valorCredito) "
					+ "FROM CreditoRealizado crrz "
					+ "INNER JOIN crrz.conta cnta "
					+ "INNER JOIN crrz.creditoTipo crtp "
					+ "WHERE  cnta.id = :idConta "
					+ "and crtp.id in (:idsCreditoTipo)";

			retorno = (BigDecimal) session.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setParameterList("idsCreditoTipo", idsCreditoTipo)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [UC0349] Emitir Documento de
	 * Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @data 06/07/2012
	 */
	public CobrancaDocumento pesquisarCobrancaDocumentoParaEmitirEntradaParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {

		CobrancaDocumento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.localidade loca "
					+ "LEFT JOIN fetch cbdo.imovel imov "
					+ "LEFT JOIN fetch cbdo.imovelPerfil "
					+ "WHERE cbdo.parcelamento.id = :idParcelamento";

			retorno = (CobrancaDocumento) session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [UC0349] Emitir Documento de
	 * Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @data 06/07/2012
	 */
	public Cliente pesquisarClienteDoParcelamento(Integer idParcelamento)
			throws ErroRepositorioException {

		Cliente retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT clie  " + "FROM Parcelamento parc "
					+ "INNER JOIN parc.cliente clie "
					+ "WHERE parc.id = :idParcelamento ";

			retorno = (Cliente) session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos [UC0349] Emitir Documento de
	 * Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @data 06/07/2012
	 */
	public Integer existeCobrancaDocumentoParaEntradaParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo.id " + "FROM CobrancaDocumento cbdo "
					+ "WHERE cbdo.parcelamento.id = :idParcelamento "
					+ "and cbdo.documentoTipo.id = :documentoTipo";

			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("documentoTipo",
							DocumentoTipo.EXTRATO_ENTRADA_PARCELAMENTO)
					.setInteger("idParcelamento", idParcelamento)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 1351] Retirar Contas Revisão Extrato Entrada de Parcelamento
	 * 
	 * @author Davi Menezes
	 * @date 02/07/2012
	 */
	public Collection<Object[]> pesquisarContasRevisaoEntradaParcelamentoDataLimite(
			Date novaData, Integer idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Object[]> colecaoRetorno = null;

		try {
			String sql = "Select cnta.cnta_id as idConta, cbdo.cbdo_id as idDocumento "
					+ "from cobranca.cobranca_documento cbdo "
					+ "inner join cobranca.cobranca_documento_item cbdi on cbdi.cbdo_id = cbdo.cbdo_id "
					+ "inner join faturamento.conta cnta on cnta.cnta_id = cbdi.cnta_id "
					+ "where cbdo.loca_id = :idLocalidade "
					+ "and cbdo.dotp_id = :documentoTipo "
					+ "and cbdo.cdst_id = :situacaoPendente "
					+ "and cnta.cmrv_id = :motivoRevisao "
					+ "and cbdo.cbdo_dtvalidade <= :data "
					+ "and not exists (select pag.pgmt_id from arrecadacao.pagamento pag where pag.cnta_id = cnta.cnta_id) ";

			colecaoRetorno = (Collection<Object[]>) session
					.createSQLQuery(sql)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("idDocumento", Hibernate.INTEGER)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("documentoTipo",
							ConstantesSistema.EXTRATO_ENTRADA_PARCELAMENTO)
					.setInteger(
							"situacaoPendente",
							Integer.parseInt(ConstantesSistema.SITUACAO_PENDENTE))
					.setInteger(
							"motivoRevisao",
							ConstantesSistema.MOTIVO_REVISAO_ENTRADA_PARCELAMENTO)
					.setDate("data", novaData).list();

			return colecaoRetorno;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	public void atualizarSituacaoDebitoDocumentoCobranca(
			Integer idDocumentoCobranca) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		try {
			String sql = "update gcom.cobranca.CobrancaDocumento "
					+ "set cdst_id = :tipoCancelado, "
					+ "cbdo_tmultimaalteracao = :ultimaAlteracao "
					+ "where cbdo_id = :idCobrancaDocumento ";

			session.createQuery(sql)
					.setInteger("tipoCancelado", ConstantesSistema.CANCELADO)
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("idCobrancaDocumento", idDocumentoCobranca)
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Obtem os valores e percentuais de desconto por tipo de débito
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> obterValorEPercDescontoPorTipoDebitoPagAVista(
			Integer idPerfilParc, Collection<Integer> colecaoIdContas)
			throws ErroRepositorioException {

		Collection<Object[]> retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select sum(dbcb_vlprestacao) as valorCobrado,"
					+ " dbcb.dbtp_id as idDebitoTipo,"
					+ " ppde_pcdescontoavista as percDescontoAVista"
					+ " from faturamento.debito_cobrado dbcb"
					+ " inner join faturamento.conta cnta on cnta.cnta_id = dbcb.cnta_id"
					+ " inner join cobranca.parc_perfil_debitos ppde on ppde.dbtp_id = dbcb.dbtp_id"
					+ " where ppde.pcpf_id = :idPerfilParc"
					+ " and ppde.ppde_pcdescontoavista is not null"
					+ " and cnta.cnta_id in (:idContas)"
					+ " group by dbcb.dbtp_id,ppde_pcdescontoavista";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta)
					.addScalar("valorCobrado", Hibernate.BIG_DECIMAL)
					.addScalar("idDebitoTipo", Hibernate.INTEGER)
					.addScalar("percDescontoAVista", Hibernate.BIG_DECIMAL)
					.setInteger("idPerfilParc", idPerfilParc)
					.setParameterList("idContas", colecaoIdContas).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 14/07/2012
	 */
	public BigDecimal pesquisarDescontoParaEntradaParcelamentoCobrancaDocumento(
			Integer idParcelamento) throws ErroRepositorioException {

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo.valorDesconto "
					+ "FROM CobrancaDocumento cbdo "
					+ "WHERE cbdo.parcelamento.id = :idParcelamento "
					+ "and cbdo.documentoTipo.id = :documentoTipo";

			retorno = (BigDecimal) session
					.createQuery(consulta)
					.setInteger("documentoTipo",
							DocumentoTipo.EXTRATO_ENTRADA_PARCELAMENTO)
					.setInteger("idParcelamento", idParcelamento)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento Arrecadador
	 * 
	 * [SB0020] - Processar Registro código F do Cliente Responsável
	 * 
	 * @author Ana Maroa
	 * @data 20/07/2012
	 */
	public Object[] obterDadosPrestacaoContratoParcelamento(Integer idPrestacao)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cppr.cppr_vlprestacao AS valorItem, "
					+ "cppr.cppr_nnprestacao AS numeroPrestacao, "
					+ "cppr.cpar_id AS idContrato "
					+ "FROM cobranca.contrato_parcel_prest cppr "
					+ "WHERE cppr.cppr_id = :idPrestacao ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacao", Hibernate.INTEGER)
					.addScalar("idContrato", Hibernate.INTEGER)
					.setInteger("idPrestacao", idPrestacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * [UC1367] Registrar Movimento do Programa Especial [SB0003] Suspender
	 * Imóveis em Programa Especial
	 * 
	 * @author Hugo Azevedo
	 * @date 21/08/2012
	 * 
	 */
	public CobrancaSituacaoHistorico obterSituacaoEspecialCobrancaHistorico(
			Integer idImovel) throws ErroRepositorioException {

		CobrancaSituacaoHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			String sql = " select cbsh "
					+ " from CobrancaSituacaoHistorico cbsh "
					+ " where cbsh.imovel.id = :idImovel "
					+ " and cbsh.anoMesCobrancaRetirada is null";

			retorno = (CobrancaSituacaoHistorico) session.createQuery(sql)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar as Ações de Cobrança
	 * 
	 * [UC 1370] Consultar Ações de Cobrança por Imóvel
	 * 
	 * @author Davi Menezes
	 * @date 15/08/2012
	 * 
	 */
	public Collection pesquisarAcoesCobrancaImovel(Integer idImovel,
			String periodoInicialAcao, String periodoFinalAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "Select cd.cbdo_id AS idCobrancaDocumento, cd.cbdo_vldocumento AS valorDocumento, "
					+ "cd.cbdo_dtvalidade AS dataValidade, cd.cdst_id AS idSituacaoCobrancaDebito, "
					+ "cd.cbdo_dtsituacaodebito AS dataSituacao, cd.caac_id AS idCobrancaAcaoAtividadeCronograma, "
					+ "cd.cacm_id AS idCobrancaAcaoAtivadeComando, acao.cbac_dscobrancaacao AS descricaoCobrancaAcao, "
					+ "acao.cbac_id AS idCobrancaAcao "
					+ "from cobranca.cobranca_documento cd "
					+ "left join cobranca.cobranca_acao_ativ_crg caac ON cd.caac_id = caac.caac_id "
					+ "left join cobranca.cobranca_acao_ativ_cmd cacm ON cd.cacm_id = cacm.cacm_id "
					+ "left join cobranca.cobranca_acao acao ON acao.cbac_id = cd.cbac_id "
					+ "where cd.imov_id = :idImovel ";

			if (periodoInicialAcao != null && !periodoInicialAcao.equals("")
					&& periodoFinalAcao != null && !periodoFinalAcao.equals("")) {

				Date dataInicial = Util.formatarDataInicial(Util
						.converteStringParaDate(periodoInicialAcao));
				Date dataFinal = Util.formatarDataFinal(Util
						.converteStringParaDate(periodoFinalAcao));
				consulta += "and ((cd.caac_id is not null and caac.caac_tmrealizacao between :dataInicio and :dataFinal) "
						+ "or  (cd.cacm_id is not null and cacm.cacm_tmrealizacao between :dataInicio and :dataFinal)) "
						+ "order by cd.cbdo_tmemissao ";

				retorno = (Collection) session
						.createSQLQuery(consulta)
						.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
						// 0
						.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
						// 1
						.addScalar("dataValidade", Hibernate.DATE)
						// 2
						.addScalar("idSituacaoCobrancaDebito",
								Hibernate.INTEGER)
						// 3
						.addScalar("dataSituacao", Hibernate.DATE)
						// 4
						.addScalar("idCobrancaAcaoAtividadeCronograma",
								Hibernate.INTEGER)
						// 5
						.addScalar("idCobrancaAcaoAtivadeComando",
								Hibernate.INTEGER)
						// 6
						.addScalar("descricaoCobrancaAcao", Hibernate.STRING)
						// 7
						.addScalar("idCobrancaAcao", Hibernate.INTEGER)
						// 8
						.setInteger("idImovel", idImovel)
						.setTimestamp("dataInicio", dataInicial)
						.setTimestamp("dataFinal", dataFinal).list();
			} else {
				consulta += "and (cd.caac_id is not null or cd.cacm_id is not null) "
						+ "order by cd.cbdo_tmemissao ";

				retorno = (Collection) session
						.createSQLQuery(consulta)
						.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
						// 0
						.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
						// 1
						.addScalar("dataValidade", Hibernate.DATE)
						// 2
						.addScalar("idSituacaoCobrancaDebito",
								Hibernate.INTEGER) // 3
						.addScalar("dataSituacao", Hibernate.DATE) // 4
						.addScalar("idCobrancaAcaoAtividadeCronograma",
								Hibernate.INTEGER) // 5
						.addScalar("idCobrancaAcaoAtivadeComando",
								Hibernate.INTEGER) // 6
						.addScalar("descricaoCobrancaAcao", Hibernate.STRING) // 7
						.addScalar("idCobrancaAcao", Hibernate.INTEGER) // 8
						.setInteger("idImovel", idImovel).list();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar Valor Taxa Serviço
	 * 
	 * [UC 1370] Consultar Ações de Cobrança por Imóvel
	 * 
	 * @author Davi Menezes
	 * @date 16/08/2012
	 * 
	 */
	public Object[] pesquisarValorTaxaServico(Integer idImovel,
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "SELECT cbs.cbsu_vltxsucesso AS valorTaxaSucesso, "
					+ "cb.cbex_vlservico AS valorTaxaServico  "
					+ "FROM cobranca.cobr_boletim_exec cb "
					+ "INNER JOIN atendimentopublico.ordem_servico os ON cb.orse_id = os.orse_id "
					+ "INNER JOIN cobranca.cobr_boletim_sucesso cbs ON cbs.cobm_id = cb.cobm_id "
					+ "WHERE cbs.imov_id = :idImovel "
					+ "AND os.cbdo_id = :idCobrancaDocumento ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("valorTaxaSucesso", Hibernate.BIG_DECIMAL)
					.addScalar("valorTaxaServico", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar Ordem Serviço da Ação de Cobrança
	 * 
	 * [UC 1370] Consultar Ações de Cobrança por Imóvel
	 * 
	 * @author Davi Menezes
	 * @date 20/08/2012
	 */
	public Object[] pesquisarOrdemServicoAcaoCobranca(
			Integer idCobrancaDocumento, Integer idAcaoCobranca)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT distinct os.orse_id AS numeroOS, amen.amen_dsmotivoencerramento AS motivoEncerramento, "
					+ "os.orse_tmencerramento AS dataEncerramento, os.orse_dsobservacao AS descricaoObservacao, "
					+ "os.orse_cdsituacao AS codigoSituacao "
					+ "FROM atendimentopublico.ordem_servico os "
					+ "LEFT JOIN atendimentopublico.atend_motivo_encmt amen ON os.amen_id = amen.amen_id "
					+ "INNER JOIN cobranca.cobranca_documento cob ON cob.cbdo_id = os.cbdo_id "
					+ "WHERE os.cbdo_id = :idCobrancaDocumento ";

			if (idAcaoCobranca != null) {
				consulta += "AND cob.cbac_id = :idAcaoCobranca ";

				retorno = (Object[]) session
						.createSQLQuery(consulta)
						.addScalar("numeroOS", Hibernate.INTEGER)
						// 0
						.addScalar("motivoEncerramento", Hibernate.STRING)
						// 1
						.addScalar("dataEncerramento", Hibernate.DATE)
						// 2
						.addScalar("descricaoObservacao", Hibernate.STRING)
						// 3
						.addScalar("codigoSituacao", Hibernate.SHORT)
						// 4
						.setInteger("idCobrancaDocumento", idCobrancaDocumento)
						.setInteger("idAcaoCobranca", idAcaoCobranca)
						.uniqueResult();
			} else {
				retorno = (Object[]) session.createSQLQuery(consulta)
						.addScalar("numeroOS", Hibernate.INTEGER)
						// 0
						.addScalar("motivoEncerramento", Hibernate.STRING)
						// 1
						.addScalar("dataEncerramento", Hibernate.DATE)
						// 2
						.addScalar("descricaoObservacao", Hibernate.STRING)
						// 3
						.addScalar("codigoSituacao", Hibernate.SHORT)
						// 4
						.setInteger("idCobrancaDocumento", idCobrancaDocumento)
						.setInteger("idAtendimentoRelacaoTipo",
								AtendimentoRelacaoTipo.ENCERRAR).uniqueResult();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar Usuario e a unidade de encerramento da Ordem de Servico
	 * 
	 * [UC 1370] Consultar Ações de Cobrança por Imóvel
	 * 
	 * @author Arthur Carvalho
	 * @date 06/09/2012
	 * 
	 * @param idCobrancaDocumento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarUsuarioEmpresaDaOrdemServicoEncerrada(
			Integer idOrdemServico) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT usu.usur_nmusuario AS nomeUsuario, emp.empr_nmempresa AS nomeEmpresa "
					+ "FROM  atendimentopublico.ordem_servico os "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu ON osu.orse_id = os.orse_id "
					+ "INNER JOIN seguranca.usuario usu ON usu.usur_id = osu.usur_id "
					+ "INNER JOIN cadastro.empresa emp ON emp.empr_id = usu.empr_id "
					+ "WHERE os.orse_id = :idOrdemServico "
					+ "AND osu.attp_id = :idAtendimentoRelacaoTipo "
					+ "AND osu.osun_tmultimaalteracao = (SELECT max(osun.osun_tmultimaalteracao) "
					+ "FROM  atendimentopublico.ordem_servico_unidade osun "
					+ "inner join atendimentopublico.ordem_servico orse on orse.orse_id = osun.orse_id "
					+ "WHERE orse.orse_id = :idOrdemServico and osun.attp_id = :idAtendimentoRelacaoTipo ) ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("nomeUsuario", Hibernate.STRING)
					// 1
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 2
					.setInteger("idOrdemServico", idOrdemServico)
					.setInteger("idAtendimentoRelacaoTipo",
							AtendimentoRelacaoTipo.ENCERRAR).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar Ação de Cobrança Cronograma
	 * 
	 * [UC 1370] Consultar Ações de Cobrança por Imóvel
	 * 
	 * @author Davi Menezes
	 * @date 20/08/2012
	 */
	public Object[] pesquisarAcoesCobrancaCronograma(Integer idCobrancaDocumento)
			throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "SELECT cbcm.cbgr_id AS idGrupoCobranca, cbcm.cbcm_amreferencia AS anoMesReferencia, "
					+ "caac.caac_tmrealizacao AS dataExecucao "
					+ "FROM cobranca.cobranca_grupo_crg_mes cbcm "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma coac ON cbcm.cbcm_id = coac.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac ON caac.cbcr_id = coac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento cbdo ON cbdo.caac_id = caac.caac_id "
					+ "WHERE cbdo.cbdo_id = :idCobrancaDocumento ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("idGrupoCobranca", Hibernate.INTEGER)
					// 0
					.addScalar("anoMesReferencia", Hibernate.INTEGER)
					// 1
					.addScalar("dataExecucao", Hibernate.DATE)
					// 2
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Arthur Carvalho
	 * @created 12/12/2012
	 * 
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarParmsCobrancaDocumentoCliente(Integer idCliente,
			int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			// Verifica se já tem débito automático
			consulta = "SELECT cd.valorAcrescimos, cd.emissao,cd.id,"
					+ " loca.id, documentoTipo.id,cdst.id "
					+ "FROM CobrancaDocumento cd "
					+ "LEFT JOIN cd.cliente cliente "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.cobrancaDebitoSituacao cdst "
					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "cliente.id = :idCliente";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idCliente", idCliente.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Arthur Carvalho
	 * @created 12/12/2012
	 * 
	 * @param idCliente
	 * @param numeroSequencialDocumento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarLocalidadeDaGuiaPagamentoCliente(
			Integer idCliente, int numeroSequencialDocumento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		Object[] retornoFinal = new Object[1];
		String consulta = null;

		try {

			consulta = " SELECT localidadeConta.id, localidadeContaHistorico.id, localidadeGuiaPagamento.id, localidadeGuiaPagamentoHistorico.id, "
					+ "localidaDedebitoACobrar.id, localidadeDebitoACobrarHistorico.id "// 1
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.cliente clie "

					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN conta.localidade localidadeConta "
					+ "LEFT JOIN contaHistorico.localidade localidadeContaHistorico "

					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN guiaPagamento.localidade localidadeGuiaPagamento "
					+ "LEFT JOIN guiaPagamentoHistorico.localidade localidadeGuiaPagamentoHistorico "

					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN debitoACobrar.localidade localidaDedebitoACobrar "
					+ "LEFT JOIN debitoACobrarHistorico.localidade localidadeDebitoACobrarHistorico "

					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "clie.id = :idCliente order by cdi.documentoTipo.id ";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idCliente", idCliente.intValue())
					.setMaxResults(1).uniqueResult();

			for (int i = 0; i < retorno.length; i++) {

				if (retorno[i] != null) {
					retornoFinal[0] = retorno[i];
				}
			}

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoFinal;
	}

	/**
	 * 
	 * [UC0243] - Inserir Comando Ação de Cobrança [SB0007] - Inserir cobranca
	 * acao atividade comando
	 * 
	 * @author Hugo Azevedo
	 * @date 25/09/2012
	 * 
	 */
	public Collection obterImoveisComandoAtividadeImovel(Integer idImovel,
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			String sql = " select " + " cacm.imov_id as idImovel "
					+ " from cobranca.comando_ativ_imoveis cacm "
					+ " where cacm.cacm_id = :idComando ";

			if (idImovel != null)
				sql += " and cacm.imov_id = :idImovel ";

			Query q = session.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", idComando);

			if (idImovel != null)
				q.setInteger("idImovel", idImovel);

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0244] - Manter Comando Ação de Cobrança [SB0003] - Excluir Comando de
	 * Atividade Eventual de Ação de Cobrança
	 * 
	 * @author Hugo Azevedo
	 * @date 04/10/2012
	 * 
	 */
	public void removerImoveisComandoAtividadeImovel(Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			String sql = " delete " + " ComandoAtividadeImoveis cacm "
					+ " where cacm_id = :idComando ";

			Query q = session.createQuery(sql).setInteger("idComando",
					idComando);

			q.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * [UC1155] Gerar Relatório de Análise de Perdas com Crédito
	 * 
	 * 
	 * @author Paulo Diniz,Vivianne Sousa
	 * @date 16/03/2011, 14/01/2012
	 * 
	 * @param mesAno
	 *            para análise
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> gerarRelatorioAnalisePerdasCreditosTotal(
			String anoMesReferencia) throws ErroRepositorioException {
		RelatorioAnalisePerdasCreditosBean retorno = new RelatorioAnalisePerdasCreditosBean();
		Collection<Object[]> retornoBanco = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		SQLQuery query = null;

		try {

			consulta = " select  	 "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoAte180, "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoMais180, "
					+

					"  sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoAte360, "
					+ "  sum( case when (drrs.drrs_qtdiasvencidos > 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoMais360, "
					+

					" sum( case when (drrs.drrs_qtdiasvencidos <=0 or  drrs.drrs_qtdiasvencidos is null) "
					+ " then drfx.drfx_vldocumentos end) as a_vencer, "
					+ " sum(drfx.drfx_qtdocumentos) as qtd_documentos, "
					+ " sum(drfx.drfx_vldocumentos) as valor_total , "
					+ " fdrc.fdrc_vlfaixainicial as faixaInicial, "
					+ " fdrc.fdrc_vlfaixafinal as faixaFinal, "
					+ " fdrc.fdrc_id as idFaixa "
					+ " from  	financeiro.docs_a_rec_resumo drrs  "
					+ " inner join financeiro.doc_receber_faixa_resumo drfx on drfx.drrs_id = drrs.drrs_id "
					+ " inner join financeiro.faixa_docs_a_receber fdrc on fdrc.fdrc_id = drfx.fdrc_id"
					+ " where 	drrs.drrs_amreferenciarecebimentos = "
					+ anoMesReferencia
					+ " group by fdrc.fdrc_vlfaixainicial, fdrc.fdrc_vlfaixafinal,fdrc.fdrc_id "
					+ " order by fdrc.fdrc_vlfaixainicial";

			query = session.createSQLQuery(consulta);
			query.addScalar("vencidoAte180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoAte360", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais360", Hibernate.BIG_DECIMAL);
			query.addScalar("a_vencer", Hibernate.BIG_DECIMAL);
			query.addScalar("qtd_documentos", Hibernate.INTEGER);
			query.addScalar("valor_total", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaInicial", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaFinal", Hibernate.BIG_DECIMAL);
			query.addScalar("idFaixa", Hibernate.INTEGER);
			retornoBanco = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retornoBanco;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0004] Verificar Critério
	 * de Cobrança para Imóvel
	 * 
	 * @author Hugo Azevedo
	 * @created 17/10/12
	 * 
	 */
	public Collection obterImoveisSituacaoLigacaoNaoAlteradaDebito(
			Integer idImovel, Date dataInicialFisc, Date dataFinalFisc)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			String sql = " select "
					+ " orse.orse_id as idOS"
					+ " from atendimentopublico.ordem_servico orse "
					+ " where orse.imov_id = :idImovel "
					+ " and orse.orse_tmencerramento is not null "
					+ " and orse.orse_icimovelfiscaldebito = 1 "
					+ " and orse.orse_dtfiscalizacaosituacao between :dataInicialFisc and :dataFinalFisc ";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idOS", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setTimestamp("dataInicialFisc",
							Util.formatarDataInicial(dataInicialFisc))
					.setTimestamp("dataFinalFisc",
							Util.formatarDataFinal(dataFinalFisc));

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * RN2013066779 [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Sávio Luiz
	 * @created 11/09/2013
	 * 
	 */
	public Integer obterContasEmRevisaoComIndicadorBloqueioConta(
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {

			String sql = " select count(imov_id) countImovel from faturamento.conta ct "
					+ " inner join faturamento.conta_motivo_revisao mr on mr.cmrv_id = ct.cmrv_id and crmv_icbloqueiaaltconta = 1 "
					+ " where dcst_idatual in (0,1,2) and ct.imov_id = :idImovel";

			Query q = session.createSQLQuery(sql)
					.addScalar("countImovel", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel);

			retorno = (Integer) q.setMaxResults(1).uniqueResult();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Pesquisa o id do parcelamento associado ao débito cobrado
	 * 
	 * @author Rafael Corrêa
	 * @date 16/02/2014
	 */
	public Integer obterIdParcelamentoAssociadoDebitoCobrado(
			Integer idDebitoCobrado) throws ErroRepositorioException {

		Integer retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT CASE WHEN (debACobrar.dbac_id is not null) THEN debACobrar.parc_id ELSE debACobrarHist.parc_id END as parc_id " // 0
					+ "FROM faturamento.debito_cobrado debCobrado "
					+ "LEFT JOIN faturamento.debito_a_cobrar debACobrar on debACobrar.dbac_id = debCobrado.dbac_id "
					+ "LEFT JOIN faturamento.deb_a_cobrar_hist debACobrarHist on debACobrarHist.dbac_id = debCobrado.dbac_id "
					+ "WHERE debCobrado.dbcb_id = :idDebitoCobrado ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("parc_id", Hibernate.INTEGER)
					.setInteger("idDebitoCobrado", idDebitoCobrado)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Pesquisa o parcelamento associado a conta
	 * 
	 * @author Rafael Corrêa
	 * @date 17/02/2014
	 */
	public Parcelamento pesquisarParcelamentoConta(Integer idConta)
			throws ErroRepositorioException {
		Parcelamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT parc "
					+ "FROM ParcelamentoItem parcItem "
					+ "INNER JOIN parcItem.contaGeral conta "
					+ "INNER JOIN parcItem.parcelamento parc "
					+ "INNER JOIN parc.parcelamentoSituacao parcSituacao "
					+ "WHERE conta.id = :idConta AND parcSituacao.id = :situacaoNormal ";

			retorno = (Parcelamento) session.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setInteger("situacaoNormal", ParcelamentoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceï¿½ï¿½o para a prï¿½xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessï¿½o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Pesquisa o parcelamento associado ao débito a cobrar
	 * 
	 * @author Rafael Corrêa
	 * @date 18/02/2014
	 */
	public Parcelamento pesquisarParcelamentoDebitoACobrar(
			Integer idDebitoACobrar) throws ErroRepositorioException {
		Parcelamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT parc "
					+ "FROM ParcelamentoItem parcItem "
					+ "INNER JOIN parcItem.debitoACobrarGeral debitoACobrar "
					+ "INNER JOIN parcItem.parcelamento parc "
					+ "INNER JOIN parc.parcelamentoSituacao parcSituacao "
					+ "WHERE debitoACobrar.id = :idDebitoACobrar AND parcSituacao.id = :situacaoNormal ";

			retorno = (Parcelamento) session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setInteger("situacaoNormal", ParcelamentoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Atualiza os débitos de dívida ativa para voltar a situação antes da
	 * execução do batch
	 * 
	 * @author Rafael Corrêa
	 * @date 04/04/2014
	 */
	public void atualizarAmortizacoesDebitosDividaAtivaArrecadacao(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;

		try {
			con = session.connection();
			stmt = con.createStatement();

			String update = "UPDATE cobranca.divida_ativa_debito set dade_dtretirada = null, dade_vldebitoamortizado = dade_vldebitoamortizado - ( "
					+ " COALESCE((SELECT sum(daam.daam_vldebitoamortizado) "
					+ " FROM cobranca.divida_ativa_amortizacao daam "
					+ " WHERE dade_id = cobranca.divida_ativa_debito.dade_id and daat_id in ("
					+ DividaAtivaAmortizacaoTipo.PAGAMENTO
					+ ","
					+ DividaAtivaAmortizacaoTipo.CREDITO_ARRECADACAO
					+ ") and daam.daam_amreferencia = "
					+ anoMesReferenciaArrecadacao
					+ "), 0) ) "
					+ " WHERE dade_id in (SELECT dade_id FROM cobranca.divida_ativa_amortizacao daam WHERE dade_id = cobranca.divida_ativa_debito.dade_id and daat_id in ("
					+ DividaAtivaAmortizacaoTipo.PAGAMENTO
					+ ","
					+ DividaAtivaAmortizacaoTipo.CREDITO_ARRECADACAO
					+ ") and daam.daam_amreferencia = "
					+ anoMesReferenciaArrecadacao
					+ " and daam.daam_vldebitoamortizado > 0) ";

			stmt.executeUpdate(update);

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}

	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Deleta as amortizações dos débitos de dívida ativa para voltar a situação
	 * antes da execução do batch
	 * 
	 * @author Rafael Corrêa
	 * @date 04/04/2014
	 */
	public void deletarAmortizacoesDebitosDividaAtivaArrecadacao(
			Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;

		try {
			con = session.connection();
			stmt = con.createStatement();

			String delete = "DELETE FROM cobranca.divida_ativa_amortizacao WHERE daat_id in ("
					+ DividaAtivaAmortizacaoTipo.PAGAMENTO
					+ ","
					+ DividaAtivaAmortizacaoTipo.CREDITO_ARRECADACAO
					+ ") and daam_amreferencia = "
					+ anoMesReferenciaArrecadacao;

			stmt.executeUpdate(delete);

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}

	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Atualiza os débitos de dívida ativa para voltar a situação antes da
	 * execução do batch
	 * 
	 * @author Rafael Corrêa
	 * @date 04/04/2014
	 */
	public void atualizarAmortizacoesDebitosDividaAtivaFaturamento(
			Integer anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;

		try {
			con = session.connection();
			stmt = con.createStatement();

			String update = "UPDATE cobranca.divida_ativa_debito set dade_dtretirada = null, dade_vldebitoamortizado = dade_vldebitoamortizado - ( "
					+ " COALESCE((SELECT sum(daam.daam_vldebitoamortizado) "
					+ " FROM cobranca.divida_ativa_amortizacao daam "
					+ " WHERE dade_id = cobranca.divida_ativa_debito.dade_id and daat_id not in ("
					+ DividaAtivaAmortizacaoTipo.PAGAMENTO
					+ ","
					+ DividaAtivaAmortizacaoTipo.CREDITO_ARRECADACAO
					+ ") and daam.daam_amreferencia = "
					+ anoMesReferenciaFaturamento
					+ "), 0) ) "
					+ " WHERE dade_id in (SELECT dade_id FROM cobranca.divida_ativa_amortizacao daam WHERE dade_id = cobranca.divida_ativa_debito.dade_id and daat_id not in ("
					+ DividaAtivaAmortizacaoTipo.PAGAMENTO
					+ ","
					+ DividaAtivaAmortizacaoTipo.CREDITO_ARRECADACAO
					+ ") and daam.daam_amreferencia = "
					+ anoMesReferenciaFaturamento
					+ " and daam.daam_vldebitoamortizado > 0) ";

			stmt.executeUpdate(update);

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}

	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Deleta as amortizações dos débitos de dívida ativa para voltar a situação
	 * antes da execução do batch
	 * 
	 * @author Rafael Corrêa
	 * @date 04/04/2014
	 */
	public void deletarAmortizacoesDebitosDividaAtivaFaturamento(
			Integer anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;

		try {
			con = session.connection();
			stmt = con.createStatement();

			String delete = "DELETE FROM cobranca.divida_ativa_amortizacao WHERE daat_id not in ("
					+ DividaAtivaAmortizacaoTipo.PAGAMENTO
					+ ","
					+ DividaAtivaAmortizacaoTipo.CREDITO_ARRECADACAO
					+ ") and daam_amreferencia = "
					+ anoMesReferenciaFaturamento;

			stmt.executeUpdate(delete);

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}

	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Pesquisa o parcelamento associado a guia de pagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 18/02/2014
	 */
	public Parcelamento pesquisarParcelamentoGuiaPagamento(
			Integer idGuiaPagamento) throws ErroRepositorioException {
		Parcelamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT parc "
					+ "FROM ParcelamentoItem parcItem "
					+ "INNER JOIN parcItem.guiaPagamentoGeral guiaPagamento "
					+ "INNER JOIN parcItem.parcelamento parc "
					+ "INNER JOIN parc.parcelamentoSituacao parcSituacao "
					+ "WHERE guiaPagamento.id = :idGuiaPagamento AND parcSituacao.id = :situacaoNormal ";

			retorno = (Parcelamento) session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setInteger("situacaoNormal", ParcelamentoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC XXXX] - Processar amortização de dívida ativa
	 * 
	 * Pesquisa as contas que tiveram vencimento alterado para o próximo ano
	 * 
	 * @author Rafael Corrêa
	 * @date 09/04/2014
	 */
	public Collection<Conta> pesquisarContasVencimentoAlterado(
			Date dataVencimento, Integer idLocalidade, Integer numeroIndice,
			Integer quantidadeRegistros) throws ErroRepositorioException {
		Collection<Conta> retorno = null;

		// cria uma sessao com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variavel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "SELECT cnta " + "FROM DividaAtivaDebito dade "
					+ "INNER JOIN dade.conta cnta " + "WHERE "
					+ "cnta.localidade.id = :idLocalidade AND "
					+ "cnta.dataVencimentoConta >= :dataVencimento AND "
					+ "cnta.indicadorAlteracaoVencimento = "
					+ ConstantesSistema.SIM;

			retorno = session.createQuery(consulta)
					.setInteger("idLocalidade", idLocalidade)
					.setDate("dataVencimento", dataVencimento)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a excacao para a proxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1585] - Emitir Relatório Dívida Ativa Amortizada.
	 * 
	 * @author Anderson Cabral
	 * @created 17/02/2014
	 * 
	 */
	public Collection<Object[]> obterDadosAmortizacoesDividaAtiva(
			Date dataInscricaoInicial, Date dataInscricaoFinal,
			Date dataAmortizacaoInicial, Date dataAmortizacaoFinal,
			Integer idImovel, Short indicadorIntra)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			Map parameters = new HashMap();

			String sql = ""
					+ "SELECT 	loca.loca_id                      AS idLocalidade, "
					+ "       	loca.loca_nmlocalidade            AS nomeLocalidade, "
					+ "       	dacr.dacr_amreferenciaarrecadacao AS anoMesReferenciaArrecadacao, "
					+ "       	dacr.dacr_dtinscricao             AS dataInscricao, "
					+ "       	daam.daam_dtamortizacao           AS dataAmortizacao, "
					+ "       	daim.imov_id                      AS idImovel, "
					+ "       	dade.dade_amreferenciadebito	  AS anoMesReferenciaDebito, "
					+ "       	daat.daat_dstipoamortizacao       AS tipoAmortizacao, "
					+ "       	daam.daam_vldebitoamortizado      AS valorDebitoAmortizado, "
					+ "			CASE WHEN (dade.parc_id is not null) THEN 'PARC.' ELSE 'CONTA' END AS tipo, "
					+ "       	daat.daat_id				      AS idtipoAmortizacao "
					+ "FROM   	cobranca.divida_ativa_amortizacao daam "
					+ "       	INNER JOIN cobranca.divida_ativa_debito dade "
					+ "               	ON dade.dade_id = daam.dade_id "
					+ "       	INNER JOIN cobranca.divida_ativa_imovel daim "
					+ "               	ON daim.daim_id = dade.daim_id "
					+ "       	INNER JOIN cobranca.divida_ativa_criterio dacr "
					+ "               	ON dacr.dacr_id = daim.dacr_id "
					+ "       	INNER JOIN cobranca.div_atv_amortizacao_tipo daat "
					+ "               	ON daat.daat_id = daam.daat_id "
					+ "       	INNER JOIN cadastro.imovel imov "
					+ "               	ON imov.imov_id = daim.imov_id "
					+ "       	INNER JOIN cadastro.localidade loca "
					+ "               	ON loca.loca_id = imov.loca_id "
					+ "WHERE  " + "       	daam.daat_id <> :idDividaAtivaTipo ";
			
			if (indicadorIntra == 1 || indicadorIntra == 2){
				sql +=  " AND daim.daim_icintra = :indicadorIntra ";
				parameters.put("indicadorIntra", indicadorIntra);
			}

			if (dataInscricaoInicial != null && dataInscricaoFinal != null) {
				sql += " AND dacr.dacr_dtinscricao BETWEEN :dataInscricaoInicial AND :dataInscricaoFinal ";
				parameters.put("dataInscricaoInicial", dataInscricaoInicial);
				parameters.put("dataInscricaoFinal", dataInscricaoFinal);
			}

			if (dataAmortizacaoInicial != null && dataAmortizacaoFinal != null) {
				sql += " AND daam.daam_dtamortizacao BETWEEN :dataAmortizacaoInicial AND :dataAmortizacaoFinal ";
				parameters
						.put("dataAmortizacaoInicial", dataAmortizacaoInicial);
				parameters.put("dataAmortizacaoFinal", dataAmortizacaoFinal);
			}

			if (idImovel != null) {
				sql += " AND daim.imov_id = :idImovel ";
				parameters.put("idImovel", idImovel);
			}

			sql +=
			// " GROUP BY loca.loca_id, "
			// + "			loca.loca_nmlocalidade, "
			// + "			dacr.dacr_amreferenciaarrecadacao, "
			// + "			dacr.dacr_dtinscricao, "
			// + "			daam.daam_dtamortizacao, "
			// + "			daim.imov_id, "
			// + "			dade.dade_amreferenciadebito, "
			// + "			daat.daat_dstipoamortizacao, "
			// + "			daam.daam_vldebitoamortizado, "
			// +
			// "			CASE WHEN (dade.parc_id is not null) THEN 'PARC.' ELSE 'CONTA' END "
			" ORDER BY loca.loca_id, " + " 		 daim.imov_id, "
					+ " 		 dacr.dacr_dtinscricao ";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("anoMesReferenciaArrecadacao", Hibernate.STRING)
					.addScalar("dataInscricao", Hibernate.DATE)
					.addScalar("dataAmortizacao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("anoMesReferenciaDebito", Hibernate.STRING)
					.addScalar("tipoAmortizacao", Hibernate.STRING)
					.addScalar("valorDebitoAmortizado", Hibernate.BIG_DECIMAL)
					.addScalar("tipo", Hibernate.STRING)
					.addScalar("idtipoAmortizacao",Hibernate.INTEGER)
					.setInteger("idDividaAtivaTipo",DividaAtivaAmortizacaoTipo.PARCELAMENTO);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					q.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					q.setParameterList(key, collection);
				} else {
					q.setParameter(key, parameters.get(key));
				}
			}

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1586] - Emitir Relatório Dívida Ativa Parcelada.
	 * 
	 * @author Anderson Cabral
	 * @created 19/02/2014
	 * 
	 */
	public Collection<Object[]> obterDadosParcelamentosDividaAtiva(
			Date dataInscricaoInicial, Date dataInscricaoFinal,
			Date dataAmortizacaoInicial, Date dataAmortizacaoFinal,
			Integer idImovel, Short indicadorIntra)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			Map parameters = new HashMap();

			String sql = ""
					+ "SELECT loca.loca_id                                        AS idLocalidade, "
					+ "       loca.loca_nmlocalidade                              AS nomeLocalidade, "
					+ "       dacr.dacr_amreferenciaarrecadacao                   AS anoMesReferenciaArrecadacao, "
					+ "       dacr.dacr_dtinscricao                               AS dataInscricao, "
					// +
					// "       daam.daam_dtamortizacao                             AS dataAmortizacao, "
					+ "       daim.imov_id                                        AS idImovel, "
					+ "       dade.parc_id                                        AS idParcelamento, "

					+ "       ( COALESCE(Sum(dbac.dbac_vldebito / dbac.dbac_nnprestacaodebito * "
					+ "         (dbac.dbac_nnprestacaodebito - dbac.dbac_nnprestacaocobradas)), 0) "
					+ "         + COALESCE(Sum((SELECT Sum(dbcb.dbcb_vlprestacao) FROM "
					+ "         faturamento.debito_cobrado dbcb INNER JOIN faturamento.conta cnta ON "
					+ "         cnta.cnta_id = dbcb.cnta_id WHERE dbcb.dbac_id = dbac.dbac_id AND "
					+ "         cnta.cnta_dtvencimentoconta >= Now() AND "
					+ "         NOT EXISTS(SELECT * FROM arrecadacao.pagamento pag "
					+ " 		WHERE   pag.cnta_id = cnta.cnta_id)) ), 0) ) + "
					+ " COALESCE((SELECT sum(gpai.gpai_vldebito) "
					+ " 	 FROM faturamento.guia_pagamento gpag "
					+ " INNER JOIN faturamento.guia_pagamento_item gpai on gpai.gpag_id = gpag.gpag_id "
					+ " INNER JOIN faturamento.debito_tipo dbtp on dbtp.dbtp_id = gpai.dbtp_id "
					+ " WHERE gpag.parc_id = dade.parc_id and dbtp.dbtp_icdividaativa = 1 and gpag.gpag_dtvencimento >= Now() and "
					+ " NOT EXISTS(SELECT * FROM arrecadacao.pagamento pag WHERE pag.gpag_id = gpag.gpag_id) "
					+ " ),0) "
					+ " AS emDia, "

					+ "       ( COALESCE(Sum((SELECT Sum(dbcb.dbcb_vlprestacao) "
					+ "                       FROM   faturamento.debito_cobrado dbcb "
					+ "                              INNER JOIN faturamento.conta cnta "
					+ "                                      ON cnta.cnta_id = dbcb.cnta_id "
					+ "                       WHERE  dbcb.dbac_id = dbac.dbac_id "
					+ "                              AND cnta.cnta_dtvencimentoconta < Now() "
					+ "                              AND NOT EXISTS(SELECT * "
					+ "                                             FROM   arrecadacao.pagamento pag "
					+ "                                             WHERE  pag.cnta_id = cnta.cnta_id)) "
					+ "                  ), 0) ) + "
					+ " COALESCE((SELECT sum(gpai.gpai_vldebito) "
					+ " 	 FROM faturamento.guia_pagamento gpag "
					+ " 	 INNER JOIN faturamento.guia_pagamento_item gpai on gpai.gpag_id = gpag.gpag_id "
					+ " 	 INNER JOIN faturamento.debito_tipo dbtp on dbtp.dbtp_id = gpai.dbtp_id "
					+ " WHERE gpag.parc_id = dade.parc_id and dbtp.dbtp_icdividaativa = 1 and gpag.gpag_dtvencimento < Now() and "
					+ " NOT EXISTS(SELECT * FROM arrecadacao.pagamento pag WHERE pag.gpag_id = gpag.gpag_id) "
					+ " 	),0) "
					+ "                                                           AS emAtraso, "

					+ "       ( ( COALESCE(Sum((SELECT Sum(dbcbquitado.dbcb_vlprestacao) "
					+ "                         FROM   faturamento.debito_cobrado dbcbquitado "
					+ "                                INNER JOIN faturamento.conta cntaquitado "
					+ "                                        ON cntaquitado.cnta_id = "
					+ "                                           dbcbquitado.cnta_id "
					+ "                         WHERE  dbcbquitado.dbac_id = dbac.dbac_id "
					+ "                                AND EXISTS(SELECT pagquitado.cnta_id "
					+ "                                           FROM   arrecadacao.pagamento "
					+ "                                                  pagquitado "
					+ "                                           WHERE  pagquitado.cnta_id = "
					+ "                            cntaquitado.cnta_id))), 0) ) + ( COALESCE(Sum( "
					+ "         (SELECT Sum(dbhi.dbhi_vlprestacao) "
					+ "          FROM "
					+ "         faturamento.debito_cobrado_historico dbhi "
					+ "         INNER JOIN faturamento.conta_historico cohi "
					+ "                 ON cohi.cnta_id = dbhi.cnta_id "
					+ "              WHERE  dbhi.dbac_id = dbac.dbac_id)), 0) ) ) + "
					+ " 		COALESCE((SELECT sum(gpai.gpai_vldebito) "
					+ " 	 			  FROM faturamento.guia_pagamento gpag "
					+ " 				  INNER JOIN faturamento.guia_pagamento_item gpai on gpai.gpag_id = gpag.gpag_id "
					+ " 				  INNER JOIN faturamento.debito_tipo dbtp on dbtp.dbtp_id = gpai.dbtp_id "
					+ " 				  WHERE gpag.parc_id = dade.parc_id and dbtp.dbtp_icdividaativa = 1 and "
					+ " 				  EXISTS(SELECT * FROM arrecadacao.pagamento pag WHERE pag.gpag_id = gpag.gpag_id) "
					+ " 		),0) "
					+ " AS quitado "

					+ "FROM   cobranca.divida_ativa_debito dade "
					// + " 	  LEFT JOIN cobranca.divida_ativa_amortizacao daam "
					// + "               ON dade.dade_id = daam.dade_id "
					+ "       INNER JOIN cobranca.divida_ativa_imovel daim "
					+ "               ON daim.daim_id = dade.daim_id "
					+ "       INNER JOIN cobranca.divida_ativa_criterio dacr "
					+ "               ON dacr.dacr_id = daim.dacr_id "
					+ "       INNER JOIN cadastro.imovel imov "
					+ "               ON imov.imov_id = daim.imov_id "
					+ "       INNER JOIN cadastro.localidade loca "
					+ "               ON loca.loca_id = imov.loca_id "
					+ "       INNER JOIN faturamento.debito_a_cobrar dbac "
					+ "               ON dbac.parc_id = dade.parc_id "
					+ "       INNER JOIN faturamento.debito_tipo dbtp "
					+ "               ON dbac.dbtp_id = dbtp.dbtp_id "
					+ "WHERE  dade.parc_id IS NOT NULL "
					+ "       AND dbtp.dbtp_icdividaativa = 1 "
					+ "       AND daim.daim_icintra = :indicadorIntra ";

			if (dataInscricaoInicial != null && dataInscricaoFinal != null) {
				sql += " AND dacr.dacr_dtinscricao BETWEEN :dataInscricaoInicial AND :dataInscricaoFinal ";
				parameters.put("dataInscricaoInicial", dataInscricaoInicial);
				parameters.put("dataInscricaoFinal", dataInscricaoFinal);
			}

			// if (dataAmortizacaoInicial != null && dataAmortizacaoFinal !=
			// null) {
			// sql +=
			// " AND daam.daam_dtamortizacao BETWEEN :dataAmortizacaoInicial AND :dataAmortizacaoFinal ";
			// parameters.put("dataAmortizacaoInicial", dataAmortizacaoInicial);
			// parameters.put("dataAmortizacaoFinal", dataAmortizacaoFinal);
			// }

			if (idImovel != null) {
				sql += " AND daim.imov_id = :idImovel ";
				parameters.put("idImovel", idImovel);
			}

			sql += " GROUP BY loca.loca_id, " + "			loca.loca_nmlocalidade, "
					+ "			daim.imov_id, "
					+ "			dacr.dacr_amreferenciaarrecadacao, "
					+ "			dacr.dacr_dtinscricao, " + "			dade.parc_id "
					// + "			daam.daam_dtamortizacao "
					+ " ORDER BY loca.loca_id, " + " 		 daim.imov_id, "
					+ " 		 dacr.dacr_dtinscricao ";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("anoMesReferenciaArrecadacao", Hibernate.STRING)
					.addScalar("dataInscricao", Hibernate.DATE)
					// .addScalar("dataAmortizacao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.addScalar("emDia", Hibernate.BIG_DECIMAL)
					.addScalar("emAtraso", Hibernate.BIG_DECIMAL)
					.addScalar("quitado", Hibernate.BIG_DECIMAL)
					.setShort("indicadorIntra", indicadorIntra);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					q.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					q.setParameterList(key, collection);
				} else {
					q.setParameter(key, parameters.get(key));
				}
			}

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1588] Gerar Divida Ativa dos Imóveis [IT0001] Obter Comandos Dívida
	 * Ativa
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 14/02/2014
	 */
	public Collection<DividaAtivaCriterio> pesquisarComandosDividaAtiva()
			throws ErroRepositorioException {
		Collection<DividaAtivaCriterio> retorno = new ArrayList<DividaAtivaCriterio>();
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = " SELECT  dacr AS id "
					+ " FROM  DividaAtivaCriterio dacr "
					+ " WHERE dacr.indicadorProcessado = 2 ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1588] Gerar Divida Ativa dos Imóveis
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 14/02/2014
	 */
	public Collection<DividaAtivaCriterioEsferaPoder> pesquisarDividaAtivaEsferaPoderComando(
			Integer idDividaAtivaCriterio) throws ErroRepositorioException {
		Collection<DividaAtivaCriterioEsferaPoder> retorno = new ArrayList<DividaAtivaCriterioEsferaPoder>();
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = " SELECT  dace AS id "
					+ " FROM  DividaAtivaCriterioEsferaPoder dace "
					+ " WHERE dace.dividaAtivaCriterio.id = :idDividaAtivaCriterio ";

			retorno = session.createQuery(consulta)
					.setInteger("idDividaAtivaCriterio", idDividaAtivaCriterio)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1588] Gerar Divida Ativa dos Imóveis
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 14/02/2014
	 */
	public Collection<DividaAtivaCriterioClienteTipo> pesquisarDividaAtivaClienteTipoComando(
			Integer idDividaAtivaCriterio) throws ErroRepositorioException {
		Collection<DividaAtivaCriterioClienteTipo> retorno = new ArrayList<DividaAtivaCriterioClienteTipo>();
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = " SELECT  dact AS id "
					+ " FROM  DividaAtivaCriterioClienteTipo dact "
					+ " WHERE dact.dividaAtivaCriterio.id = :idDividaAtivaCriterio ";

			retorno = session.createQuery(consulta)
					.setInteger("idDividaAtivaCriterio", idDividaAtivaCriterio)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1588] Gerar Divida Ativa dos Imóveis [IT0002] Pesquisar Contas dos
	 * Imóveis para Divida Ativa
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 14/02/2014
	 */
	public Collection pesquisarContasImoveisDividaAtiva(
			DividaAtivaCriterio dividaAtivaCriterio,
			Collection<DividaAtivaCriterioEsferaPoder> dividaAtivaCriterioEsferasPoder,
			Collection<DividaAtivaCriterioClienteTipo> dividaAtivaCriterioClientesTipo,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		Date dataVencimentoMaximaConta = dividaAtivaCriterio
				.getDataMaximaVencimentoConta();

		try {

			consulta = "SELECT imov.imov_id as idImovel, cnta.cnta_id as idConta,  cnta.cnta_amreferenciaconta as referencia, "
					+ "(coalesce(cnta.cnta_vlagua, 0) + coalesce(cnta.cnta_vlesgoto, 0) + coalesce(cnta.cnta_vldebitos, 0) - "
					+ "coalesce(cnta.cnta_vlcreditos, 0) - coalesce(cnta.cnta_vlimpostos, 0)) as valorDebito,  "
					+ "clie.clie_id as idCliente, cltpResponsavel.cltp_id idClienteTipo, "
					+ "(cnta_vlagua+cnta_vlesgoto+cnta_vldebitos-cnta_vlcreditos-cnta_vlimpostos) + "
					+ "trunc(((cnta_vlagua+cnta_vlesgoto+cnta_vldebitos-cnta_vlcreditos-cnta_vlimpostos) * 0.02),2) + "
					+ "trunc((cnta_vlagua+cnta_vlesgoto+cnta_vldebitos-cnta_vlcreditos-cnta_vlimpostos) * "
					+ "((pow(1.0004 , cast((:dataVencimentoMaximaConta - cnta_dtvencimentoconta) as numeric)))-1), 2) as valorCorrigido "
					+ "FROM faturamento.conta cnta "
					+ "INNER JOIN cadastro.imovel imov on(cnta.imov_id = imov.imov_id) "
					+ "INNER JOIN cadastro.cliente_imovel clim on (imov.imov_id = clim.imov_id and clim.crtp_id = :usuario and clim.clim_dtrelacaofim is null) "
					+ "INNER JOIN cadastro.cliente clie on(clim.clie_id = clie.clie_id) "
					+ "INNER JOIN cadastro.cliente_tipo cltp on(clie.cltp_id = cltp.cltp_id) "
					+ "INNER JOIN cadastro.esfera_poder epod on(cltp.epod_id = epod.epod_id) "
					+ "LEFT JOIN cadastro.cliente_imovel climResponsavel on (imov.imov_id = climResponsavel.imov_id and climResponsavel.crtp_id = :responsavel and climResponsavel.clim_dtrelacaofim is null) "
					+ "LEFT JOIN cadastro.cliente clieResponsavel on(climResponsavel.clie_id = clieResponsavel.clie_id) "
					+ "LEFT JOIN cadastro.cliente_tipo cltpResponsavel on(clieResponsavel.cltp_id = cltpResponsavel.cltp_id) "
					+ "LEFT JOIN cadastro.esfera_poder epodResponsavel on(cltpResponsavel.epod_id = epodResponsavel.epod_id) "
					+ "WHERE cnta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida) "
					+ "and imov.imov_icexclusao = 2  "
					+ "and imov.last_id not in (:suprimido, :suprimidoParcPedido)"
					+ "and cnta.cnta_dtvencimentoconta  < :dataVencimentoMaximaConta "
					+ "and cnta.cnta_id not in (SELECT pgmt.cnta_id FROM arrecadacao.pagamento pgmt "
					+ "                         WHERE pgmt.cnta_id = cnta.cnta_id and pgmt_dtpagamento < :dataVencimentoMaximaConta) "
					+ "and cnta.cnta_id not in (SELECT dade.cnta_id FROM cobranca.divida_ativa_debito dade "
					+ "                         INNER JOIN cobranca.divida_ativa_imovel daim on(daim.daim_id = dade.daim_id)"
					+ "						 WHERE daim.dacr_id <> :idCriterio and dade.cnta_id = cnta.cnta_id) ";

			if (dividaAtivaCriterioEsferasPoder != null
					&& !dividaAtivaCriterioEsferasPoder.isEmpty()) {
				String idsEsferaPoder = "";

				Iterator iterator = dividaAtivaCriterioEsferasPoder.iterator();
				while (iterator.hasNext()) {
					DividaAtivaCriterioEsferaPoder dividaAtivaCriterioEsferaPoder = (DividaAtivaCriterioEsferaPoder) iterator
							.next();
					idsEsferaPoder = idsEsferaPoder
							+ dividaAtivaCriterioEsferaPoder.getEsferaPoder()
									.getId().toString() + ",";
				}

				idsEsferaPoder = idsEsferaPoder.substring(0,
						idsEsferaPoder.length() - 1);

				consulta = consulta
						+ "and ((epodResponsavel.epod_id is not null and epodResponsavel.epod_id in ("
						+ idsEsferaPoder + ")) ";
				consulta = consulta
						+ "or (epodResponsavel.epod_id is null and epod.epod_id in ("
						+ idsEsferaPoder + "))) ";
			}

			if (dividaAtivaCriterioClientesTipo != null
					&& !dividaAtivaCriterioClientesTipo.isEmpty()) {
				String idsClienteTipo = "";

				Iterator iterator = dividaAtivaCriterioClientesTipo.iterator();
				while (iterator.hasNext()) {
					DividaAtivaCriterioClienteTipo dividaAtivaCriterioClienteTipo = (DividaAtivaCriterioClienteTipo) iterator
							.next();
					idsClienteTipo = idsClienteTipo
							+ dividaAtivaCriterioClienteTipo.getClienteTipo()
									.getId().toString() + ",";
				}

				idsClienteTipo = idsClienteTipo.substring(0,
						idsClienteTipo.length() - 1);

				consulta = consulta
						+ "and ((cltpResponsavel.cltp_id is not null and cltpResponsavel.cltp_id in ("
						+ idsClienteTipo + ")) ";
				consulta = consulta
						+ "or (cltpResponsavel.cltp_id is null and cltp.cltp_id in ("
						+ idsClienteTipo + "))) ";
			}

			if (dividaAtivaCriterio.getValorMinimoDebito() != null
					&& !dividaAtivaCriterio.getValorMinimoDebito().equals("")) {
				consulta = consulta
						+ "and (coalesce(cnta.cnta_vlagua, 0) + coalesce(cnta.cnta_vlesgoto, 0) + coalesce(cnta.cnta_vldebitos, 0) - coalesce(cnta.cnta_vlcreditos, 0) - coalesce(cnta.cnta_vlimpostos, 0)) "
						+ " between "
						+ dividaAtivaCriterio.getValorMinimoDebito() + " and "
						+ dividaAtivaCriterio.getValorMaximoDebito();
			}

			consulta += " ORDER BY idImovel, referencia, idConta ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("idClienteTipo", Hibernate.INTEGER)
					.addScalar("valorCorrigido", Hibernate.BIG_DECIMAL)
					.setShort("usuario", ClienteRelacaoTipo.USUARIO)
					.setShort("responsavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada",
							DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida",
							DebitoCreditoSituacao.INCLUIDA)
					.setInteger("suprimido", LigacaoAguaSituacao.SUPRIMIDO)
					.setInteger("suprimidoParcPedido",
							LigacaoAguaSituacao.SUPR_PARC_PEDIDO)
					.setDate("dataVencimentoMaximaConta",
							dataVencimentoMaximaConta)
					.setInteger("idCriterio", dividaAtivaCriterio.getId())
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0204] Consultar Conta [SB0002] Pesquisar Conta na Divida Ativa
	 * 
	 * @author Anderson Cabral
	 * @throws ErroRepositorioException
	 * @date 24/02/2014
	 */
	public Date pesquisarDataInscricaoContaDividaAtiva(Integer idConta)
			throws ErroRepositorioException {
		Date retorno = new Date();
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "" + "SELECT dacr.dacr_dtinscricao AS datainscricao "
					+ "FROM   cobranca.divida_ativa_criterio dacr "
					+ "       INNER JOIN cobranca.divida_ativa_imovel daim "
					+ "               ON dacr.dacr_id = daim.dacr_id "
					+ "       INNER JOIN cobranca.divida_ativa_debito dade "
					+ "               ON dade.daim_id = daim.daim_id "
					+ "WHERE  dade.cnta_id = :idConta "
					+ "AND dade.dade_dtretirada IS null ";

			retorno = (Date) session.createSQLQuery(consulta)
					.addScalar("datainscricao", Hibernate.DATE)
					.setInteger("idConta", idConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a excecao para a proxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1590] - Gerar Relatório Demonstrativo Dívida Ativa
	 * 
	 * @author Anderson Cabral
	 * @throws ErroRepositorioException
	 * @date 11/03/2014
	 */
	public Collection<Object[]> obterDadosDemonstrativoDividaAtiva(
			short indicadorIntra, String anoMesDemonstrativo)
			throws ErroRepositorioException {
		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "SELECT clie.clie_id                       AS idCliente, "
					+ "       clie.clie_nmcliente                AS nomeCliente, "
					+ "    SUM(daan.daan_vldebitooriginal)    AS valorDebitoOriginal, "
					+ "    SUM(daan.daan_vldebitocomcorrecao) AS valorCorrigido, "
					+ "    SUM(daan.daan_vldebitoamortizado)  AS valorDebitoAmortizado "
					+ "FROM   cobranca.divida_ativa_analitico daan "
					+ "       INNER JOIN cadastro.cliente clie "
					+ "               ON clie.clie_id = daan.clie_id "
					+ "WHERE  daan.daan_amdividaativa = :anoMesDemonstrativo ";

			if (indicadorIntra == DividaAtivaAnalitico.INDICADOR_INTRA
					|| indicadorIntra == DividaAtivaAnalitico.INDICADOR_NAO_INTRA) {
				consulta = consulta + " AND daan.daan_icintra = "
						+ indicadorIntra;
			}

			consulta = consulta + "GROUP BY clie.clie_id, clie.clie_nmcliente "
					+ "ORDER BY clie.clie_nmcliente";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("valorDebitoOriginal", Hibernate.BIG_DECIMAL)
					.addScalar("valorCorrigido", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitoAmortizado", Hibernate.BIG_DECIMAL)
					.setString("anoMesDemonstrativo", anoMesDemonstrativo)
					.list();

		} catch (HibernateException e) {
			// levanta a excecao para a proxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1590] - Gerar Relatório Demonstrativo Dívida Ativa [IT0002] Obter
	 * Município da Empresa
	 * 
	 * @author Anderson Cabral
	 * @throws ErroRepositorioException
	 * @date 11/03/2014
	 */
	public String obterMunicipioDaEmpresa() throws ErroRepositorioException {
		String retorno = "";
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "" + "SELECT muni.muni_nmmunicipio AS nomeMunicipio "
					+ "FROM   cadastro.municipio muni "
					+ "       INNER JOIN cadastro.bairro bair "
					+ "               ON bair.muni_id = muni.muni_id "
					+ "       INNER JOIN cadastro.sistema_parametros parm "
					+ "               ON parm.bair_id = bair.bair_id";

			retorno = (String) session.createSQLQuery(consulta)
					.addScalar("nomeMunicipio", Hibernate.STRING)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a excecao para a proxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1591] Gerar Resumo Divida Atida Anual
	 * 
	 * [FE0003] Verificar Registros na Tabela para Resumo Anual
	 * 
	 * @author Ana Maria
	 * @date 13/03/2014
	 * */
	public void removerDadosResumoDividaAtivaAnual(Integer anoMesDividaAtiva,
			Integer idSetorComercial) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "DELETE DividaAtivaAnalitico daan "
					+ "WHERE daan.anoMesDividaAtiva = :anoMesDividaAtiva "
					+ "AND daan.imovel.id in (SELECT i.id FROM Imovel i "
					+ "WHERE i.setorComercial.id = :idSetorComercial and i.id = daan.imovel.id)";

			session.createQuery(sql)
					.setInteger("anoMesDividaAtiva", anoMesDividaAtiva)
					.setInteger("idSetorComercial", idSetorComercial)
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a excecao para a prÃ³xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1591] Gerar Resumo Divida Atida Anual
	 * 
	 * [IT0001] Obter Comandos Dívida Ativa
	 * 
	 * @author Ana Maria
	 * @date 13/03/2014
	 * */
	public Collection<DividaAtivaCriterio> pesquisarComandosDividaAtivaProcessadosDataReferencia(
			String anoMesDataReferencia) throws ErroRepositorioException {
		Collection<DividaAtivaCriterio> retorno = new ArrayList<DividaAtivaCriterio>();
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = " SELECT  dacr AS id "
					+ " FROM  DividaAtivaCriterio dacr "
					+ " WHERE dacr.anoMesArrecadacao <= :anoMesDataReferencia ";

			retorno = session.createQuery(consulta)
					.setString("anoMesDataReferencia", anoMesDataReferencia)
					.list();

		} catch (HibernateException e) {
			// levanta a excecao para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1591] Gerar Resumo Divida Atida Anual
	 * 
	 * [IT0002] Pesquisar Debitos em Divida Ativa
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 13/03/2014
	 */
	public Collection pesquisarDebitosDividaAtiva(
			DividaAtivaCriterio dividaAtivaCriterio, Date dataReferencia,
			Integer idSetorComercial) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT daim.imov_id as idImovel, imov.loca_id as idLocalidade, daim.clie_id as idCliente, daim.daim_icintra as indicadorIntra, "
					+ "dade_amreferenciadebito as referenciaDebito, cnta.cnta_id as idConta, 0 as idParcelamento, "
					+ "cnta_dtvencimentoconta as dataVencimento, "
					+ "dade_vldebitosemcorrecao as vlDebitoSemCorrecao, "
					+ "CASE WHEN (to_date(:dataReferencia,'yyyy-mm-dd') <= cnta_dtvencimentoconta) "
					+ "	THEN dade_vldebitosemcorrecao "
					+ "	ELSE dade_vldebitosemcorrecao + trunc((dade_vldebitosemcorrecao * 0.02),2) + trunc(dade_vldebitosemcorrecao * ((pow(1.0004 , cast((to_date(:dataReferencia,'yyyy-mm-dd') - cnta_dtvencimentoconta) as numeric)))-1) ,2) END "
					+ "as vlCorrigido, "
					+ "sum(daam_vldebitoamortizado) as valorAmortizado "
					+ "FROM cobranca.divida_ativa_debito dade  "
					+ "INNER JOIN cobranca.divida_ativa_imovel daim on (daim.daim_id = dade.daim_id) "
					+ "INNER JOIN cadastro.imovel imov on (daim.imov_id = imov.imov_id) "
					+ "INNER JOIN faturamento.conta cnta on (cnta.cnta_id = dade.cnta_id) "
					+ "LEFT JOIN cobranca.divida_ativa_amortizacao daam on(daam.dade_id = dade.dade_id and daam_dtamortizacao <= :dataReferencia) "
					+ "WHERE daim.dacr_id  = :idDdividaAtivaCriterio "
					+ "and (dade.dade_dtretirada is null or dade.dade_dtretirada > :dataReferencia)   "
					+ "and imov.stcm_id = :idSetorComercial "
					+ "GROUP BY idImovel, idLocalidade, idCliente, indicadorIntra, referenciaDebito, idConta, idParcelamento, dataVencimento, vlDebitoSemCorrecao, vlCorrigido "
					+ "UNION "
					+ "SELECT daim.imov_id as idImovel, imov.loca_id as idLocalidade, daim.clie_id as idCliente, daim.daim_icintra as indicadorIntra, "
					+ "dade_amreferenciadebito as referenciaDebito, 0 as idConta, parc.parc_id as idParcelamento, "
					+ "to_date(parc_tmparcelamento, 'yyyy-mm-dd') as dataVencimento, "
					+ "dade_vldebitosemcorrecao as vlDebitoSemCorrecao, "
					+ "dade_vldebitosemcorrecao as vlCorrigido, "
					+ "sum(daam_vldebitoamortizado) as valorAmortizado "
					+ "FROM cobranca.divida_ativa_debito dade  "
					+ "INNER JOIN cobranca.divida_ativa_imovel daim on (daim.daim_id = dade.daim_id) "
					+ "INNER JOIN cadastro.imovel imov on (daim.imov_id = imov.imov_id) "
					+ "INNER JOIN cobranca.parcelamento parc on(parc.parc_id = dade.parc_id and to_date(parc_tmparcelamento, 'yyyy-mm-dd') <= :dataReferencia) "
					+ "LEFT JOIN cobranca.divida_ativa_amortizacao daam on(daam.dade_id = dade.dade_id and daam_dtamortizacao <= :dataReferencia) "
					+ "WHERE daim.dacr_id  = :idDdividaAtivaCriterio "
					+ "and (dade.dade_dtretirada is null or dade.dade_dtretirada > :dataReferencia) "
					+ "and imov.stcm_id = :idSetorComercial "
					+ "GROUP BY idImovel, idLocalidade, idCliente, indicadorIntra, referenciaDebito, idConta, idParcelamento, dataVencimento, vlDebitoSemCorrecao, vlCorrigido ";

			consulta += "ORDER BY idImovel, referenciaDebito";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("indicadorIntra", Hibernate.SHORT)
					.addScalar("referenciaDebito", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("vlDebitoSemCorrecao", Hibernate.BIG_DECIMAL)
					.addScalar("vlCorrigido", Hibernate.BIG_DECIMAL)
					.addScalar("valorAmortizado", Hibernate.BIG_DECIMAL)
					.setInteger("idDdividaAtivaCriterio",
							dividaAtivaCriterio.getId())
					.setDate("dataReferencia", dataReferencia)
					.setInteger("idSetorComercial", idSetorComercial).list();

		} catch (HibernateException e) {
			// levanta a excecao para a prÃ³xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * MA20140610677 - Alterar vencimentos para contas negativadas
	 * 
	 * @author Diogo Luiz
	 * @date 23/06/2014 RM11231 - [UC0146] - Manter Conta
	 */
	public Short pesquisarIndicadorAlterarVencimentoConta(Conta conta)
			throws ErroRepositorioException {

		Short retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = " select cbst_icbloqalterarvenctoconta as indicadorAlterarVencimentoConta "
					+ " from cobranca.cobranca_situacao cbst "
					+ " inner join cobranca.negatd_movimento_reg nmrg on cbst.cbst_id = nmrg.cbst_id "
					+ " inner join cobranca.negatd_mov_reg_item nmri on nmri.nmrg_id = nmrg.nmrg_id "
					+ " where nmrg.nmrg_cdexclusaotipo is null and (nmrg.nmrg_icaceito = 1 or nmrg.nmrg_icaceito is null) "
					+ " and nmri.cdst_id = 1 and nmri.cnta_id = "
					+ conta.getId();

			retorno = (Short) session
					.createSQLQuery(consulta)
					.addScalar("indicadorAlterarVencimentoConta",
							Hibernate.SHORT).uniqueResult();

			return retorno;

		} catch (HibernateException e) {
			// levanta a excecao para a prÃ³xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<Empresa> obterEmpresasCobranca(Short indicadorUso,
			String dataCorrente) throws ErroRepositorioException {
		Collection<Empresa> retorno = null;
		Session session = HibernateUtil.getSession();
		String scriptSQL;

		try {

			scriptSQL = "SELECT DISTINCT empresa"
					+ " FROM ContratoEmpresaServico contratoEmpresaServico"
					+ " INNER JOIN contratoEmpresaServico.empresa AS empresa"
					+ " WHERE empresa.indicadorUso = :indicadorUso"
					+ " AND "
					+ "  (contratoEmpresaServico.dataFimContrato IS NULL"
					+ "  OR contratoEmpresaServico.dataFimContrato >= TO_DATE(:dataCorrente,'YYYY-MM-DD'))";

			retorno = session.createQuery(scriptSQL)
					.setShort("indicadorUso", indicadorUso)
					.setString("dataCorrente", dataCorrente).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<CobrancaAcaoGrupoContrato> obterCobrancaAcaoGrupoContrato(
			Integer idGrupo, Integer idEmpresa, Integer idContrato,
			Integer idAcaoCobranca) throws ErroRepositorioException {

		Collection<CobrancaAcaoGrupoContrato> retorno = null;
		Session session = HibernateUtil.getSession();
		Query query = null;
		String scriptSQL;

		try {

			scriptSQL = "SELECT cobrancaAcaoGrupoContrato"
					+ " FROM CobrancaAcaoGrupoContrato cobrancaAcaoGrupoContrato"
					+ " INNER JOIN FETCH cobrancaAcaoGrupoContrato.cobrancaGrupo AS cobrancaGrupo"
					+ " INNER JOIN FETCH cobrancaAcaoGrupoContrato.cobrancaAcao AS cobrancaAcao"
					+ " INNER JOIN FETCH cobrancaAcaoGrupoContrato.contratoEmpresaServico AS contratoEmpresaServico"
					+ " INNER JOIN FETCH cobrancaAcaoGrupoContrato.contratoEmpresaServico.empresa AS empresa";

			scriptSQL += " WHERE cobrancaAcaoGrupoContrato.cobrancaGrupo = :idGrupo";

			if (idEmpresa != null && idEmpresa.compareTo(-1) != 0) {
				scriptSQL += " AND cobrancaAcaoGrupoContrato.contratoEmpresaServico.empresa = :idEmpresa";
			}

			if (idContrato != null && idContrato.compareTo(-1) != 0) {
				scriptSQL += " AND cobrancaAcaoGrupoContrato.contratoEmpresaServico = :idContrato";
			}

			if (idAcaoCobranca != null && idAcaoCobranca.compareTo(-1) != 0) {
				scriptSQL += " AND cobrancaAcaoGrupoContrato.cobrancaAcao = :idAcaoCobranca";
			}

			query = session.createQuery(scriptSQL);

			query.setInteger("idGrupo", idGrupo);

			if (idEmpresa != null && idEmpresa.compareTo(-1) != 0) {
				query.setInteger("idEmpresa", idEmpresa);
			}

			if (idContrato != null && idContrato.compareTo(-1) != 0) {
				query.setInteger("idContrato", idContrato);
			}

			if (idAcaoCobranca != null && idAcaoCobranca.compareTo(-1) != 0) {
				query.setInteger("idAcaoCobranca", idAcaoCobranca);
			}

			retorno = query.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0005] Gerar Documento de
	 * Cobrança [SB0010] Obter Empresa do Contrato
	 * 
	 * @author Vivianne Sousa
	 * @date 13/06/2014
	 */
	public Empresa obterEmpresaContrato(
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Empresa retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select cese.empresa "
					+ "from CobrancaAcaoAtividadeCronograma caac "
					+ "inner join caac.cobrancaAcaoCronograma cbcr "
					+ "inner join cbcr.contratoEmpresaServico cese "
					+ "where caac.id = :idCobrancaAcaoAtividadeCronograma ";

			retorno = (Empresa) session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeCronograma",
							idCobrancaAcaoAtividadeCronograma).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0312] Inserir Cronograma de Cobrança [SB0002] Obter Contrato da Ação
	 * 
	 * @author Ana Maria
	 * @date 13/06/2014
	 */
	public ContratoEmpresaServico obterContratoAcaoCobranca(
			Integer idGrupoCobranca, Integer idAcaoCobranca)
			throws ErroRepositorioException {
		ContratoEmpresaServico retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cese " + "FROM CobrancaAcaoGrupoContrato cagc "
					+ "INNER JOIN cagc.contratoEmpresaServico cese "
					+ "WHERE cagc.cobrancaGrupo.id = :idGrupoCobranca "
					+ "AND cagc.cobrancaAcao.id = :idAcaoCobranca ";

			retorno = (ContratoEmpresaServico) session.createQuery(consulta)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0312] Inserir Cronograma de Cobrança [SB0001] Obter Contrato ddo Grupo
	 * 
	 * @author Ana Maria
	 * @date 19/06/2014
	 */
	public ContratoEmpresaServico obterContratoGrupo(Integer idGrupoCobranca)
			throws ErroRepositorioException {
		ContratoEmpresaServico retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cese " + "FROM CobrancaGrupo cbgr "
					+ "INNER JOIN cbgr.contratoEmpresaServico cese "
					+ "WHERE cbgr.id = :idGrupoCobranca ";

			retorno = (ContratoEmpresaServico) session.createQuery(consulta)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1615] Prepara dados SMS/EMAIL cobrança de conta
	 * 
	 * @author Hugo Azevedo
	 * @date 08/08/2014
	 */
	public Collection<Object[]> selecionarDocumentosCobrancaSMSEmail(
			Integer idAcaoCobranca, Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT "
					+ " cd.imov_id               as  imovel, "
					+ " cl.clie_id               as  codigo_cliente, "
					+ " cl.clie_nmcliente        as  nome_cliente_usuario, "
					+ " cfon_cdddd||cfon_nnfone  as  fonesms_cliente, "
					+ " clie_dsemail             as  email_cliente,  "
					+ " cbdo_vldocumento         as  valor_documento, "
					+ " cbdo_dtvalidade          as  validade_documento, "
					+ " case "
					+ " 		when clie_icenviasms = 1 and cfon_nnfone > 0 "
					+ " 		then 1 "
					+ " 		else 2 "
					+ " end as indicador_sms, "
					+ " case	 "
					+ " 		when clie_icenviaemail = 1 and clie_dsemail is not null and clie_dsemail <> ' ' "
					+ " 		then 1 "
					+ " 		else 2 "
					+ " end as indicador_email, "
					+ " cbac_dstextosms          as  texto_sms,"
					+ " cbac_dstextoemail        as  texto_email,"
					+ " cd.loca_id 			   as  localidade,"
					+ " cd.cbdo_nnsequenciadocumento as sequencial_doc,"
					+ " cd.dotp_id			   as doc_tipo, "
					+ " cd.cbdo_id 			   as doc_cobranca "
					+ " FROM cobranca.cobranca_acao_ativ_cmd ac "
					+ " inner join cobranca.cobranca_acao ca      on ca.cbac_id = ac.cbac_id and (cbac_icenviasms = 1 or cbac_icenviaemail=1) "
					+ " inner join cobranca.cobranca_documento cd on cd.cacm_id = ac.cacm_id "
					+ " inner join cadastro.imovel im             on im.imov_id = cd.imov_id and im.iper_id <> (select ps.iper_idprogramaespecial from cadastro.sistema_parametros ps) "
					+ " inner join cadastro.cliente_imovel ci     on ci.imov_id = im.imov_id and ci.crtp_id = 2 and ci.clim_dtrelacaofim is null  "
					+ " inner join cadastro.cliente cl            on cl.clie_id = ci.clie_id  "
					+ " left  join cadastro.cliente_fone cf       on cf.clie_id = cl.clie_id and cf.cfon_icfonesms = 1 and cf.cfon_nnfone > 0 "
					+ " where ac.cacm_id = :idCobrancaAcaoAtividadeComando"
					+ " and ac.cbac_id  = :idAcaoCobranca ";

			retorno = (Collection<Object[]>) session
					.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.INTEGER)
					// 0
					.addScalar("codigo_cliente", Hibernate.INTEGER)
					// 1
					.addScalar("nome_cliente_usuario", Hibernate.STRING)
					// 2
					.addScalar("fonesms_cliente", Hibernate.STRING)
					// 3
					.addScalar("email_cliente", Hibernate.STRING)
					// 4
					.addScalar("valor_documento", Hibernate.BIG_DECIMAL)
					// 5
					.addScalar("validade_documento", Hibernate.DATE)
					// 6
					.addScalar("indicador_sms", Hibernate.SHORT)
					// 7
					.addScalar("indicador_email", Hibernate.SHORT)
					// 8
					.addScalar("texto_sms", Hibernate.STRING)
					// 9
					.addScalar("texto_email", Hibernate.STRING)
					// 10
					.addScalar("localidade", Hibernate.INTEGER)
					// 11
					.addScalar("sequencial_doc", Hibernate.STRING)
					// 12
					.addScalar("doc_tipo", Hibernate.INTEGER)
					// 13
					.addScalar("doc_cobranca", Hibernate.INTEGER)
					// 14
					.setInteger("idCobrancaAcaoAtividadeComando",
							idCobrancaAcaoAtividadeComando)
					.setInteger("idAcaoCobranca", idAcaoCobranca).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1615] Prepara dados SMS/EMAIL cobrança de conta
	 * 
	 * @author Hugo Azevedo
	 * @date 08/08/2014
	 */
	public void excluirMensagensReferencia(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String sql;

		try {

			sql = " delete from gcom.cadastro.MensagemSMSFaturamentoCobranca msg"
					+ " where cacm_id =  :idComando ";

			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();

			sql = " delete from gcom.cadastro.MensagemEmailFaturamentoCobranca msg"
					+ " where cacm_id = :idComando ";

			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	public Collection pesquisarDataPrevista(CobrancaGrupo cobrancaGrupo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		String sql;

		try {
			sql = " select caac_dtprevista as data_prevista from cobranca.cobranca_acao_ativ_crg caac "
					+ " inner join cobranca.cobranca_acao_cronograma cbcr on cbcr.cbcr_id = caac.cbcr_id "
					+ " inner join cobranca.cobranca_grupo_crg_mes cbcm on cbcm.cbcm_id = cbcr.cbcm_id "
					+ " inner join cobranca.cobranca_grupo cbgr on cbgr.cbgr_id = cbcm.cbgr_id "
					+ " inner join cobranca.cobranca_atividade cbat on cbat.cbat_id = caac.cbat_id "
					+ " where cbgr.cbgr_id = "
					+ cobrancaGrupo.getId()
					+ " and cbat.cbat_nnordemrealizacao = 1 and cbcr.cbac_id = :cobrancaAcao"
					+ " order by caac_dtprevista desc limit 1";

			retorno = (Collection) session.createSQLQuery(sql)
					.addScalar("data_prevista", Hibernate.STRING)
					.setInteger("cobrancaAcao", CobrancaAcao.VISITA_COBRANCA)
					.list();

			return retorno;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC1668] Atualizar Dados nas Tabelas Resumos Gerenciais Arrecadação
	 * @author Fábio Aguiar
	 * @date 29/01/2015
	 * 
	 * @throws ErroRepositorioException
	 * @throws SQLException
	 */
	public void gerarResumoCobrancaAtualizaDados() throws ErroRepositorioException, SQLException {

		Session session = HibernateUtil.getSessionGerencial();
		Connection con = null;
		String sql = "";
		try {
			con = session.connection();
			sql = " SELECT cobranca.sp_un_cobranca_atualiza_dados() ";
			PreparedStatement pstm = con.prepareStatement(sql);
			pstm.executeQuery();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(	e,
												"Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}
	
	
	/**
	 * [UC1669] Atualizar Dados nas Tabelas Resumos Gerenciais Faturamento
	 * @author Fábio Aguiar
	 * @date 04/02/2015
	 * 
	 * @throws ErroRepositorioException
	 * @throws SQLException
	 */
	public void gerarResumoParcelamentoAtualizaDados() throws ErroRepositorioException, SQLException {

		Session session = HibernateUtil.getSessionGerencial();
		Connection con = null;
		String sql = "";
		try {
			con = session.connection();
			sql = " SELECT cobranca.sp_un_parcelamento_atualiza_dados() ";
			PreparedStatement pstm = con.prepareStatement(sql);
			pstm.executeQuery();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(	e,
												"Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}
	
	/**
	 * [UC1669] Atualizar Dados nas Tabelas Resumos Gerenciais Faturamento
	 * @author Fábio Aguiar
	 * @date 31/03/2015
	 * 
	 * @throws ErroRepositorioException
	 * @throws SQLException
	 */
	public Integer pesquisaUsuarioLogadoPossuiAcessoFuncionalidade(Integer idUsuario) throws ErroRepositorioException{
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		String sql;
		
		try {
			sql = " SELECT count(*) as n " +
					" FROM seguranca.usuario_grupo ug " +
					" INNER JOIN seguranca.grupo_func_operacao gfo ON ug.grup_id=gfo.grup_id " +
					" WHERE usur_id= " + idUsuario +
					" and gfo.fncd_id=1221";
			

			retorno = (Integer) session.createSQLQuery(sql).addScalar("n", Hibernate.INTEGER).uniqueResult();
			
//			Query query =  session.createSQLQuery(consulta)
//                    .addScalar("dataTramite",        Hibernate.DATE)
//                    .addScalar("descricaoUnidade",        Hibernate.STRING)
//                    .setString("idRegistroAtendimento", idRegistroAtendimento);

			
			

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
	
	/**
	 * [UC1675] - Gerar relatório consultar Débitos
	 * 
	 * @author Fábio Aguiar
	 * @date 14/04/2014
	 * 
	 * @throws ErroRepositorioException
	 */
	
	public Object[] pesquisarClienteResponsavel(Integer idImovel) throws ErroRepositorioException{

	Object[] retorno = null;
	Session sessao = HibernateUtil.getSession();
	String consulta = "";

			try{
				
				consulta = "SELECT cl.clie_id AS id_cliente_superior, "
						+ " cl.clie_nmcliente AS nome_cliente_superior, "
						+ " CASE WHEN cl.clie_nncnpj IS NOT NULL THEN cl.clie_nncnpj "
						+ " WHEN cl.clie_nncpf IS NOT NULL THEN cl.clie_nncpf "
						+ " END AS cnpjcpf "
						+ " FROM cadastro.cliente_imovel ci "
						+ " INNER JOIN cadastro.cliente cl ON cl.clie_id = ci.clie_id "
						+ " WHERE imov_id = :idImovel "
						+ " AND clim_dtrelacaofim IS NULL "
						+ " AND crtp_id = 3 ";
				
				retorno = (Object[]) sessao.createSQLQuery(consulta)
						.addScalar("id_cliente_superior", Hibernate.INTEGER)
						.addScalar("cnpjcpf", Hibernate.STRING)
						.addScalar("nome_cliente_superior", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setMaxResults(1).uniqueResult();
					
					
			} catch (HibernateException e) {
				// levanta a exce??o para a pr?xima camada
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				// fecha a sess?o
				HibernateUtil.closeSession(sessao);
			}

		return retorno;				
	}
	
	/**
	 * Obtém os parcelamentos ativos de um imóvel
	 * 
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Rafael Corrêa
	 * @date 01/06/2015
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> obterParcelamentosAtivosImovel(Integer idImovel) throws ErroRepositorioException {
		
		Collection<Integer> retorno = null;
		Session sessao = HibernateUtil.getSession();
		String consulta = "";

		try{
			
			consulta = "SELECT dac.parc_id "
					+ " FROM faturamento.debito_a_cobrar dac "
					+ " LEFT JOIN arrecadacao.pagamento p on p.dbac_id = dac.dbac_id "
					+ " WHERE dac.parc_id is not null " 
					+ " and dac.imov_id = :idImovel "
					+ " and dac.dcst_idatual = :normal " 
					+ " and p.pgmt_id is null "
					+ " UNION "
					+ " SELECT coalesce(dac.parc_id, dach.parc_id) as parc_id "
					+ " FROM faturamento.conta c "
					+ " INNER JOIN faturamento.debito_cobrado dc on dc.cnta_id = c.cnta_id "
					+ " LEFT JOIN faturamento.debito_a_cobrar dac on dac.dbac_id = dc.dbac_id "
					+ " LEFT JOIN faturamento.deb_a_cobrar_hist dach on dach.dbac_id = dc.dbac_id "
					+ " LEFT JOIN arrecadacao.pagamento p on p.cnta_id = c.cnta_id "
					+ " WHERE (dac.parc_id is not null or dach.parc_id is not null) " 
					+ " and c.dcst_idatual in (:normal, :retificada, :incluida) " 
					+ " and c.imov_id = :idImovel "
					+ " and p.pgmt_id is null";
			
			retorno = (Collection<Integer>) sessao.createSQLQuery(consulta)
					.addScalar("parc_id", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.list();
				
				
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(sessao);
		}

		return retorno;
	}

	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * [SB0003] - Inserir Guia de Pagamento Cliente 
	 *
	 * @author Vivianne Sousa
	 * @date 04/05/2015
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarParcelamento(Integer idParcelamento, Integer idDebitoCreditoSituacao)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<DebitoACobrar> retorno = null;
		String consulta;
		try {
			consulta = "SELECT dbac FROM DebitoACobrar dbac "
					+ "INNER JOIN FETCH dbac.debitoTipo dbtp "
					+ "WHERE dbac.parcelamento.id = :idParcelamento " 
					+ "AND dbac.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao ";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamento",idParcelamento)
					.setInteger("idDebitoCreditoSituacao", idDebitoCreditoSituacao).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * [SB0003] - Inserir Guia de Pagamento Cliente 
	 *
	 * @author Vivianne Sousa
	 * @date 04/05/2015
	 */
	public Collection<CreditoARealizar> pesquisarCreditoARealizarParcelamento(Integer idParcelamento, Integer idDebitoCreditoSituacao)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<CreditoARealizar> retorno = null;
		String consulta;
		try {
			consulta = "SELECT crar FROM CreditoARealizar crar "
					+ "INNER JOIN FETCH crar.creditoTipo crtp "
					+ "WHERE crar.parcelamento.id = :idParcelamento "
					+ "AND crar.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao ";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamento",idParcelamento)
					.setInteger("idDebitoCreditoSituacao", idDebitoCreditoSituacao).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 * [SB0001] - Incluir Dados da Confirmação do Parcelamento
	 *
	 * @author Vivianne Sousa
	 * @date 07/05/2015
	 */
	public Parcelamento pesquisarParcelamento(Integer idParcelamento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Parcelamento retorno = null;
		String consulta;
		try {
			consulta = "SELECT parc FROM Parcelamento parc "
					+ "WHERE parc.id = :idParcelamento ";

			retorno = (Parcelamento)session.createQuery(consulta)
					.setInteger("idParcelamento",idParcelamento).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0213] Desfazer Parcelamentos Débito
	 * 
	 * @author Vivianne Sousa
	 * @date 11/05/2015
	 */
	public void deletarGuiaPagamentoParcelamentoCartao(Integer idParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String sql;
		try {
			sql = " delete from gcom.arrecadacao.pagamento.GuiaPagamentoParcelamentoCartao "
					+ " where parc_id =  :idParcelamento ";
			session.createQuery(sql).setInteger("idParcelamento", idParcelamento).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0213] Desfazer Parcelamentos Débito
	 * 
	 * @author Vivianne Sousa
	 * @date 11/05/2015
	 */
	public void deletarParcelamentoPagamentoCartaoCredito(Integer idParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String sql;
		try {
			sql = " delete from gcom.cobranca.parcelamento.ParcelamentoPagamentoCartaoCredito "
					+ " where parc_id =  :idParcelamento ";
			session.createQuery(sql).setInteger("idParcelamento", idParcelamento).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0213] Desfazer Parcelamentos Débito
	 * 
	 * @author Vivianne Sousa
	 * @date 11/05/2015
	 */
	public Collection pesquisarIdGuiaPagamentoParcelamentoCartao(Integer idParcPagCartaoCredito)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		String consulta;
		try {
			consulta = "SELECT pcci.guiaPagamentoGeral.id "
					+ "FROM PagamentoCartaoCreditoItem pcci "
					+ "WHERE pcci.parcelamentoPagamentoCartaoCredito.id = :idParcPagCartaoCredito ";

			retorno = session.createQuery(consulta)
					.setInteger("idParcPagCartaoCredito",idParcPagCartaoCredito).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0213] Desfazer Parcelamentos Débito
	 * 
	 * @author Vivianne Sousa
	 * @date 11/05/2015
	 */
	public void removerGuiaPagamento(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String remover;
		String consulta;

		try {
			//deleta as categorias da guia de pagamento
			remover = "delete GuiaPagamentoCategoria guiaPagamentoCategoria "
					+ "where guiaPagamentoCategoria.guiaPagamento.id = :idGuiaPagamento ";
			session.createQuery(remover).setInteger("idGuiaPagamento", idGuiaPagamento).executeUpdate();
			//deleta os clientes da guia de pagamento
			remover = "delete ClienteGuiaPagamento clienteGuiaPagamento "
					+ "where clienteGuiaPagamento.guiaPagamento.id = :idGuiaPagamento ";
			session.createQuery(remover).setInteger("idGuiaPagamento", idGuiaPagamento).executeUpdate();

			consulta = "select gpi.id  "
					+ "from GuiaPagamentoItem gpi "
					+ "where gpi.guiaPagamentoGeral.id = :idGuiaPagamento";
			Collection<Integer> colecaoIdGuiaItem = session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento).list();
			
			if(!Util.isVazioOrNulo(colecaoIdGuiaItem)){
				for (Integer idGuiaItem : colecaoIdGuiaItem) {
					// deleta as categorias dos itens
					remover = "delete GuiaPagamentoItemCategoria guiaPagamentoItemCategoria "
							+ "where guiaPagamentoItemCategoria.guiaPagamentoItem.id = :idGuiaItem ";
					session.createQuery(remover).setInteger("idGuiaItem", idGuiaItem).executeUpdate();

					// deleta os itens
					remover = "delete GuiaPagamentoItem  guiaPagamentoItem "
							+ "where guiaPagamentoItem.id = :idGuiaItem ";
					session.createQuery(remover).setInteger("idGuiaItem", idGuiaItem).executeUpdate();
				}
			}
			
			// deleta cobrança documento item
			consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.guiaPagamentoGeral.id = :idGuiaPagamento ";
			session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento).executeUpdate();

			// deleta a guia de pagamento
			remover = "delete GuiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :idGuiaPagamento ";
			session.createQuery(remover).setInteger("idGuiaPagamento", idGuiaPagamento).executeUpdate();

			//delete guia de pagamento geral
			remover = "delete GuiaPagamentoGeral guiaPagamentoGeral "
					+ "where guiaPagamentoGeral.guiaPagamento.id = :idGuiaPagamento ";
			session.createQuery(remover).setInteger("idGuiaPagamento",idGuiaPagamento).executeUpdate();
					
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	/**
	 * [UC0927] - Confirmar Cartão de Crédito/Débito
	 *
	 * @author Vivianne Sousa
	 * @date 16/09/2015
	 */
	public ParcelamentoPagamentoCartaoCredito pesquisarParcelamentoPagamentoCartaoCredito(Integer idParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		ParcelamentoPagamentoCartaoCredito retorno = null;
		String consulta;
		try {
			consulta = "SELECT pacc FROM ParcelamentoPagamentoCartaoCredito pacc "
					+ "WHERE pacc.parcelamento.id = :idParcelamento ";

			retorno = (ParcelamentoPagamentoCartaoCredito)session.createQuery(consulta)
					.setInteger("idParcelamento",idParcelamento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * [UC0213] Desfazer Parcelamentos Débito
	 * 
	 * @author Vivianne Sousa
	 * @date 06/10/2015
	 */
	public void deletarPagamentoCartaoCreditoItem(Integer idParcPagCartaoCredito)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String sql;
		try {
			sql = " delete from gcom.cobranca.parcelamento.PagamentoCartaoCreditoItem "
					+ " where pacc_id =  :idParcPagCartaoCredito ";
			session.createQuery(sql).setInteger("idParcPagCartaoCredito", idParcPagCartaoCredito).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
    /**
	 * [UC1691] Confirmar Pagamento Cartão de Crédito
	 * 
	 * Pesquisa a data do parcelamento de uma guia de pagamento
	 * 
	 * @author Jean Varela
	 * @date 07/10/2015
	 */
	public Date pesquisarDataParcelamentoGuiaPagamento(int idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			 consulta = "select parc_tmparcelamento from  faturamento.guia_pagamento guia "
			         + "INNER JOIN cobranca.parcelamento parc on guia.parc_id=parc.parc_id "
			         + "where gpag_id= :idGuiaPagamento";

			
			  retorno = (Date) ((SQLQuery) session.createSQLQuery(consulta))
					    .addScalar("parc_tmparcelamento", Hibernate.DATE)
					    .setInteger("idGuiaPagamento", idGuiaPagamento)
					    .setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC1691] Confirmar Pagamento Cartão de Crédito
	 * 
	 * Pesquisa o identificador transação para um determinado pagamento de guia de pagamento
	 * 
	 * @author Jean Varela
	 * @date 07/10/2015
	 */
	public String pesquisarIdentificadorTransacaoParaPagamentoGuiaPagamento(int idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String retorno = null;
		String consulta = null;

		try {
			 consulta = "select pacc_nnidentificadortransacao from  faturamento.guia_pagamento guia "
			         + "INNER JOIN cobranca.parcelamento parc on guia.parc_id=parc.parc_id "
			         + "where gpag_id= :idGuiaPagamento";

			
			  retorno = (String) ((SQLQuery) session.createSQLQuery(consulta))
					    .addScalar("pacc_nnidentificadortransacao", Hibernate.DATE)
					    .setInteger("idGuiaPagamento", idGuiaPagamento)
					    .setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * Consultar Arquivo Texto Retorno Cobranca
	 * [UC????]
	 * 
	 * Pesquisa os dados necessários para a geração do relatório
	 * 
	 * @author Joao Pedro Medeiros
	 * @created 23/11/2015
	 */
	
	public Collection<Object[]> obterRelatorioConsultarArquivoRetornoCobranca(Date dataVencimentoInicial,
		Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		dataVencimentoInicial = Util.formatarDataInicial(dataVencimentoInicial);
		dataVencimentoFinal = Util.formatarDataFinal(dataVencimentoFinal);
		String sql = "";

		sql = "SELECT" +
				" orse.imov_id 				AS imovel, " +
				" eocl.eocl_dscpf			AS cpf, " +
				" eocl.eocl_dscnpj			AS cnpj, " +
				" eocl.eocl_nmcliente		AS nome, " +
				" eocl.eocl_dsrg			AS numIdentidade, " +
				" oerg.oerg_dsabreviado		AS orgaoExp, " +
				" unfe.unfe_dsufsigla		AS unidadeFed, " +
				" eocl.eocl_dsdddtelefone	AS numDdd, " +
				" eocl.eocl_dstelefone		AS numFone, " +
				" eocl.eocl_dsramaltelefone	AS numRamal, " +
				" atoccl.clie_id			AS idCliente " +
				" FROM mobile.exe_os_cliente eocl " +
				" INNER JOIN atendimentopublico.ordem_servico orse 	ON orse.orse_id = eocl.orse_id " +
				" LEFT JOIN cadastro.orgao_expedidor_rg oerg 		ON oerg.oerg_id = eocl.oerg_id " +
				" LEFT JOIN cadastro.unidade_federacao unfe		ON unfe.unfe_id = eocl.unfe_id " +
				" LEFT JOIN mobile.arq_txt_os_cobranca_clie atoccl ON atoccl.orse_id = eocl.orse_id AND atoccl.aosc_id = eocl.aosc_id  " +
				" WHERE " +
				"eocl_tmultimaalteracao between (:dataVencimentoInicial) and (:dataVencimentoFinal) ";
		try {
			retorno = (Collection<Object[]>) session.createSQLQuery(sql)
			.addScalar("imovel", Hibernate.STRING) // 0
			.addScalar("cpf", Hibernate.STRING) //1
			.addScalar("cnpj", Hibernate.STRING) // 2
			.addScalar("nome", Hibernate.STRING) // 3
			.addScalar("numIdentidade", Hibernate.STRING)// 4
			.addScalar("orgaoExp", Hibernate.STRING) // 5
			.addScalar("unidadeFed", Hibernate.STRING) // 6
			.addScalar("numDdd", Hibernate.STRING) //7
			.addScalar("numFone", Hibernate.STRING) //8
			.addScalar("numRamal", Hibernate.STRING) //9
			.addScalar("idCliente", Hibernate.STRING) //10
			.setTimestamp("dataVencimentoInicial", dataVencimentoInicial)
			.setTimestamp("dataVencimentoFinal", dataVencimentoFinal)
			.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(	e,
												"Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 *[UC1498] - Consultar Arquivo Texto de Ordens de Serviço para Smartphone (Novo)
	 *[IT0018] Exibir Lista de Grupos de Cobrança
	 *
	 * @author Jean Varela
	 * @date 08/12/2015
	 */
	public Collection<Object[]> pesquisaGrupoCobrancaPorEmpresa(Integer idEmpresa) throws ErroRepositorioException{
		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();

		try{
				String sql = "select cbgr_id,cbgr_dscobrancagrupo " +
				             "from cobranca.cobranca_grupo grupo " +
				             "inner join micromedicao.contrato_empresa_servico cese " +
				             "on grupo.cese_id = cese.cese_id " +  
				             "where cese.empr_id= :idEmpresa order by cbgr_dscobrancagrupo";
				
				retorno = (Collection<Object[]>) session.createSQLQuery(sql)
												.addScalar("cbgr_id", Hibernate.INTEGER)
												.addScalar("cbgr_dscobrancagrupo", Hibernate.STRING)
												.setInteger("idEmpresa", idEmpresa).list();	
			 		
			 	return retorno;
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC1585] - Emitir Relatório Dívida Ativa Amortizada.
	 * 
	 * @author Joao Pedro Medeiros
	 * @throws ErroRepositorioException 
	 * @created 04/01/2016
	 * 
	 */
	public Collection<Object[]> obterDadosAmortizacoesDividaAtivaSintetico(
			Date dataInscricaoInicial, Date dataInscricaoFinal,
			Date dataAmortizacaoInicial, Date dataAmortizacaoFinal,
			Integer idImovel, Short indicadorIntra) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			Map parameters = new HashMap();

			String sql = ""
					+ "SELECT 	daat.daat_dstipoamortizacao AS tipoAmortizacao, "
					+ "			COUNT(daat.daat_dstipoamortizacao)       AS totalTipoAmortizacao, "
					+ "			SUM(daam.daam_vldebitoamortizado)      AS totalValorDebitoAmortizado "
					+ " FROM   	cobranca.divida_ativa_amortizacao daam  "
					+ "       	INNER JOIN cobranca.divida_ativa_debito dade "
					+ "               	ON dade.dade_id = daam.dade_id "
					+ "       	INNER JOIN cobranca.divida_ativa_imovel daim "
					+ "               	ON daim.daim_id = dade.daim_id "
					+ "       	INNER JOIN cobranca.divida_ativa_criterio dacr "
					+ "               	ON dacr.dacr_id = daim.dacr_id "
					+ "       	INNER JOIN cobranca.div_atv_amortizacao_tipo daat "
					+ "               	ON daat.daat_id = daam.daat_id "
					+ "       	INNER JOIN cadastro.imovel imov "
					+ "               	ON imov.imov_id = daim.imov_id "
					+ "       	INNER JOIN cadastro.localidade loca "
					+ "               	ON loca.loca_id = imov.loca_id "
					+ "      	WHERE daam.daat_id <> :idDividaAtivaTipo ";

			if (indicadorIntra == 1 || indicadorIntra == 2){
				sql +=  " AND daim.daim_icintra = :indicadorIntra ";
				parameters.put("indicadorIntra", indicadorIntra);
			}
			
			if (dataInscricaoInicial != null && dataInscricaoFinal != null) {
				sql += " AND dacr.dacr_dtinscricao BETWEEN :dataInscricaoInicial AND :dataInscricaoFinal ";
				parameters.put("dataInscricaoInicial", dataInscricaoInicial);
				parameters.put("dataInscricaoFinal", dataInscricaoFinal);
			}

			if (dataAmortizacaoInicial != null && dataAmortizacaoFinal != null) {
				sql += " AND daam.daam_dtamortizacao BETWEEN :dataAmortizacaoInicial AND :dataAmortizacaoFinal ";
				parameters
						.put("dataAmortizacaoInicial", dataAmortizacaoInicial);
				parameters.put("dataAmortizacaoFinal", dataAmortizacaoFinal);
			}

			if (idImovel != null) {
				sql += " AND daim.imov_id = :idImovel ";
				parameters.put("idImovel", idImovel);
			}

			sql +=
			" GROUP BY daat.daat_dstipoamortizacao ";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("tipoAmortizacao", Hibernate.STRING)
					.addScalar("totalTipoAmortizacao", Hibernate.BIG_DECIMAL)
					.addScalar("totalValorDebitoAmortizado", Hibernate.BIG_DECIMAL)
					.setInteger("idDividaAtivaTipo",
							DividaAtivaAmortizacaoTipo.PARCELAMENTO);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					q.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					q.setParameterList(key, collection);
				} else {
					q.setParameter(key, parameters.get(key));
				}
			}

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}
}